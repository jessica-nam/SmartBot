{
    "intents": [
        {
            "tag": "java",
            "patterns": [
                "How do I generate random integers within a specific range in Java?",
                "how do i generate random integers?",
                "how do i generate the random integers in java?",
                "is it possible to generate random integers using java?",
                "how do i generate random integers in java?",
                "how can i generate random integers within a certain range in java?"
            ],
            "responses": [
                "In Java 1.7 or later, the standard way to do this is as follows:Java 1.7 or laterimport java.util.concurrent.ThreadLocalRandom;\n\n// nextInt is normally exclusive of the top value,\n// so add 1 to make it inclusive\nint randomNum = ThreadLocalRandom.current().nextInt(min, max + 1);\nimport java.util.concurrent.ThreadLocalRandom;\n\n// nextInt is normally exclusive of the top value,\n// so add 1 to make it inclusive\nint randomNum = ThreadLocalRandom.current().nextInt(min, max + 1);\nSee the relevant JavaDoc.  This approach has the advantage of not needing to explicitly initialize a java.util.Random instance, which can be a source of confusion and error if used inappropriately.the relevant JavaDocjava.util.RandomHowever, conversely there is no way to explicitly set the seed so it can be difficult to reproduce results in situations where that is useful such as testing or saving game states or similar.  In those situations, the pre-Java 1.7 technique shown below can be used.Before Java 1.7, the standard way to do this is as follows:Before Java 1.7import java.util.Random;\n\n/**\n * Returns a pseudo-random number between min and max, inclusive.\n * The difference between min and max can be at most\n * <code>Integer.MAX_VALUE - 1</code>.\n *\n * @param min Minimum value\n * @param max Maximum value.  Must be greater than min.\n * @return Integer between min and max, inclusive.\n * @see java.util.Random#nextInt(int)\n */\npublic static int randInt(int min, int max) {\n\n    // NOTE: This will (intentionally) not run as written so that folks\n    // copy-pasting have to think about how to initialize their\n    // Random instance.  Initialization of the Random instance is outside\n    // the main scope of the question, but some decent options are to have\n    // a field that is initialized once and then re-used as needed or to\n    // use ThreadLocalRandom (if using at least Java 1.7).\n    // \n    // In particular, do NOT do 'Random rand = new Random()' here or you\n    // will get not very good / not very random results.\n    Random rand;\n\n    // nextInt is normally exclusive of the top value,\n    // so add 1 to make it inclusive\n    int randomNum = rand.nextInt((max - min) + 1) + min;\n\n    return randomNum;\n}\nimport java.util.Random;\n\n/**\n * Returns a pseudo-random number between min and max, inclusive.\n * The difference between min and max can be at most\n * <code>Integer.MAX_VALUE - 1</code>.\n *\n * @param min Minimum value\n * @param max Maximum value.  Must be greater than min.\n * @return Integer between min and max, inclusive.\n * @see java.util.Random#nextInt(int)\n */\npublic static int randInt(int min, int max) {\n\n    // NOTE: This will (intentionally) not run as written so that folks\n    // copy-pasting have to think about how to initialize their\n    // Random instance.  Initialization of the Random instance is outside\n    // the main scope of the question, but some decent options are to have\n    // a field that is initialized once and then re-used as needed or to\n    // use ThreadLocalRandom (if using at least Java 1.7).\n    // \n    // In particular, do NOT do 'Random rand = new Random()' here or you\n    // will get not very good / not very random results.\n    Random rand;\n\n    // nextInt is normally exclusive of the top value,\n    // so add 1 to make it inclusive\n    int randomNum = rand.nextInt((max - min) + 1) + min;\n\n    return randomNum;\n}\nSee the relevant JavaDoc.  In practice, the java.util.Random class is often preferable to java.lang.Math.random().the relevant JavaDocjava.util.Randomjava.lang.Math.random()In particular, there is no need to reinvent the random integer generation wheel when there is a straightforward API within the standard library to accomplish the task.",
                "Note that this approach is more biased and less efficient than a nextInt approach, https://stackoverflow.com/a/738651/360211nextInthttps://stackoverflow.com/a/738651/360211One standard pattern for accomplishing this is:Min + (int)(Math.random() * ((Max - Min) + 1))\nMin + (int)(Math.random() * ((Max - Min) + 1))\nThe Java Math library function Math.random() generates a double value in the range [0,1). Notice this range does not include the 1.Java[0,1)In order to get a specific range of values first, you need to multiply by the magnitude of the range of values you want covered. Math.random() * ( Max - Min )\nMath.random() * ( Max - Min )\nThis returns a value in the range [0,Max-Min), where 'Max-Min' is not included.[0,Max-Min)For example, if you want [5,10), you need to cover five integer values so you use[5,10)Math.random() * 5\nMath.random() * 5\nThis would return a value in the range [0,5), where 5 is not included.[0,5)Now you need to shift this range up to the range that you are targeting. You do this by adding the Min value.Min + (Math.random() * (Max - Min))\nMin + (Math.random() * (Max - Min))\nYou now will get a value in the range [Min,Max). Following our example, that means [5,10):[Min,Max)[5,10)5 + (Math.random() * (10 - 5))\n5 + (Math.random() * (10 - 5))\nBut, this still doesn't include Max and you are getting a double value. In order to get the Max value included, you need to add 1 to your range parameter (Max - Min) and then truncate the decimal part by casting to an int. This is accomplished via:MaxMax(Max - Min)Min + (int)(Math.random() * ((Max - Min) + 1))\nMin + (int)(Math.random() * ((Max - Min) + 1))\nAnd there you have it. A random integer value in the range [Min,Max], or per the example [5,10]:[Min,Max][5,10]5 + (int)(Math.random() * ((10 - 5) + 1))\n5 + (int)(Math.random() * ((10 - 5) + 1))\n",
                "Use:Random ran = new Random();\nint x = ran.nextInt(6) + 5;\nRandom ran = new Random();\nint x = ran.nextInt(6) + 5;\nThe integer x is now the random number that has a possible outcome of 5-10.x5-10",
                "Use:minValue + rn.nextInt(maxValue - minValue + 1)\nminValue + rn.nextInt(maxValue - minValue + 1)\n",
                "With java-8 they introduced the method ints(int randomNumberOrigin, int randomNumberBound) in the Random class.java-8ints(int randomNumberOrigin, int randomNumberBound)ints(int randomNumberOrigin, int randomNumberBound)RandomRandomFor example if you want to generate five random integers (or a single one) in the range [0, 10], just do:Random r = new Random();\nint[] fiveRandomNumbers = r.ints(5, 0, 11).toArray();\nint randomNumber = r.ints(1, 0, 11).findFirst().getAsInt();\nRandom r = new Random();\nint[] fiveRandomNumbers = r.ints(5, 0, 11).toArray();\nint randomNumber = r.ints(1, 0, 11).findFirst().getAsInt();\nThe first parameter indicates just the size of the IntStream generated (which is the overloaded method of the one that produces an unlimited IntStream).IntStreamIntStreamIf you need to do multiple separate calls, you can create an infinite primitive iterator from the stream:public final class IntRandomNumberGenerator {\n\n    private PrimitiveIterator.OfInt randomIterator;\n\n    /**\n     * Initialize a new random number generator that generates\n     * random numbers in the range [min, max]\n     * @param min - the min value (inclusive)\n     * @param max - the max value (inclusive)\n     */\n    public IntRandomNumberGenerator(int min, int max) {\n        randomIterator = new Random().ints(min, max + 1).iterator();\n    }\n\n    /**\n     * Returns a random number in the range (min, max)\n     * @return a random number in the range (min, max)\n     */\n    public int nextInt() {\n        return randomIterator.nextInt();\n    }\n}\npublic final class IntRandomNumberGenerator {\n\n    private PrimitiveIterator.OfInt randomIterator;\n\n    /**\n     * Initialize a new random number generator that generates\n     * random numbers in the range [min, max]\n     * @param min - the min value (inclusive)\n     * @param max - the max value (inclusive)\n     */\n    public IntRandomNumberGenerator(int min, int max) {\n        randomIterator = new Random().ints(min, max + 1).iterator();\n    }\n\n    /**\n     * Returns a random number in the range (min, max)\n     * @return a random number in the range (min, max)\n     */\n    public int nextInt() {\n        return randomIterator.nextInt();\n    }\n}\nYou can also do it for double and long values.doublelong",
                "You can edit your second code example to:Random rn = new Random();\nint range = maximum - minimum + 1;\nint randomNum =  rn.nextInt(range) + minimum;\nRandom rn = new Random();\nint range = maximum - minimum + 1;\nint randomNum =  rn.nextInt(range) + minimum;\n",
                "Just a small modification of your first solution would suffice.Random rand = new Random();\nrandomNum = minimum + rand.nextInt((maximum - minimum) + 1);\nRandom rand = new Random();\nrandomNum = minimum + rand.nextInt((maximum - minimum) + 1);\nSee more here for implementation of RandomRandomRandom",
                "ThreadLocalRandom equivalent of class java.util.Random for multithreaded environment. Generating a random number is carried out locally in each of the threads. So we have a better performance by reducing the conflicts. ThreadLocalRandomjava.util.Randomint rand = ThreadLocalRandom.current().nextInt(x,y);\nint rand = ThreadLocalRandom.current().nextInt(x,y);\nx,y - intervals e.g. (1,10)xy",
                "The Math.Random class in Java is 0-based. So, if you write something like this: Math.RandomJavaRandom rand = new Random();\nint x = rand.nextInt(10);\nRandom rand = new Random();\nint x = rand.nextInt(10);\nx will be between 0-9 inclusive.x0-9So, given the following array of 25 items, the code to generate a random number between 0 (the base of the array) and array.length would be:250array.lengthString[] i = new String[25];\nRandom rand = new Random();\nint index = 0;\n\nindex = rand.nextInt( i.length );\nString[] i = new String[25];\nRandom rand = new Random();\nint index = 0;\n\nindex = rand.nextInt( i.length );\nSince i.length will return 25, the nextInt( i.length ) will return a number between the range of 0-24. The other option is going with Math.Random which works in the same way.i.length25nextInt( i.length )0-24Math.Randomindex = (int) Math.floor(Math.random() * i.length);\nindex = (int) Math.floor(Math.random() * i.length);\nFor a better understanding, check out forum post Random Intervals (archive.org).Random Intervals (archive.org)Random Intervals (archive.org)",
                "It can be done by simply doing the statement:Randomizer.generate(0, 10); // Minimum of zero and maximum of ten\nRandomizer.generate(0, 10); // Minimum of zero and maximum of ten\nBelow is its source code.File Randomizer.javaRandomizer.javapublic class Randomizer {\n    public static int generate(int min, int max) {\n        return min + (int)(Math.random() * ((max - min) + 1));\n    }\n}\npublic class Randomizer {\n    public static int generate(int min, int max) {\n        return min + (int)(Math.random() * ((max - min) + 1));\n    }\n}\nIt is just clean and simple.",
                "Forgive me for being fastidious, but the solution suggested by the majority, i.e., min + rng.nextInt(max - min + 1)), seems perilous due to the fact that:min + rng.nextInt(max - min + 1))\nrng.nextInt(n) cannot reach Integer.MAX_VALUE.\n(max - min) may cause overflow when min is negative.\nrng.nextInt(n) cannot reach Integer.MAX_VALUE.rng.nextInt(n)Integer.MAX_VALUE(max - min) may cause overflow when min is negative.(max - min)minA foolproof solution would return correct results for any min <= max within [Integer.MIN_VALUE, Integer.MAX_VALUE]. Consider the following naive implementation:min <= maxInteger.MIN_VALUEInteger.MAX_VALUEint nextIntInRange(int min, int max, Random rng) {\n   if (min > max) {\n      throw new IllegalArgumentException(\"Cannot draw random int from invalid range [\" + min + \", \" + max + \"].\");\n   }\n   int diff = max - min;\n   if (diff >= 0 && diff != Integer.MAX_VALUE) {\n      return (min + rng.nextInt(diff + 1));\n   }\n   int i;\n   do {\n      i = rng.nextInt();\n   } while (i < min || i > max);\n   return i;\n}\nint nextIntInRange(int min, int max, Random rng) {\n   if (min > max) {\n      throw new IllegalArgumentException(\"Cannot draw random int from invalid range [\" + min + \", \" + max + \"].\");\n   }\n   int diff = max - min;\n   if (diff >= 0 && diff != Integer.MAX_VALUE) {\n      return (min + rng.nextInt(diff + 1));\n   }\n   int i;\n   do {\n      i = rng.nextInt();\n   } while (i < min || i > max);\n   return i;\n}\nAlthough inefficient, note that the probability of success in the while loop will always be 50% or higher.while",
                "I wonder if any of the random number generating methods provided by an Apache Commons Math library would fit the bill. Apache Commons MathFor example: RandomDataGenerator.nextInt or RandomDataGenerator.nextLongRandomDataGenerator.nextIntRandomDataGenerator.nextIntRandomDataGenerator.nextLongRandomDataGenerator.nextLong",
                "I use this: /**\n   * @param min - The minimum.\n   * @param max - The maximum.\n   * @return A random double between these numbers (inclusive the minimum and maximum).\n   */\n public static double getRandom(double min, double max) {\n   return (Math.random() * (max + 1 - min)) + min;\n }\n /**\n   * @param min - The minimum.\n   * @param max - The maximum.\n   * @return A random double between these numbers (inclusive the minimum and maximum).\n   */\n public static double getRandom(double min, double max) {\n   return (Math.random() * (max + 1 - min)) + min;\n }\nYou can cast it to an Integer if you want.",
                "\nAs of Java 7, you should no longer use Random. For most uses, the\n  random number generator of choice is now\n  ThreadLocalRandom.For fork join pools and parallel\n  streams, use SplittableRandom.\nAs of Java 7, you should no longer use Random. For most uses, the\n  random number generator of choice is now\n  ThreadLocalRandom.For fork join pools and parallel\n  streams, use SplittableRandom.RandomThreadLocalRandomThreadLocalRandomSplittableRandomSplittableRandomJoshua Bloch. Effective Java. Third Edition.Joshua Bloch. Effective Java. Third Edition.Starting from Java 8For fork join pools and parallel streams, use SplittableRandom that is usually faster, has a better statistical independence and uniformity properties in comparison with Random.SplittableRandomRandomTo generate a random int in the range [0, 1_000]:int[0, 1_000]:int n = new SplittableRandom().nextInt(0, 1_001);\nint n = new SplittableRandom().nextInt(0, 1_001);\nTo generate a random int[100] array of values in the range [0, 1_000]:int[100][0, 1_000]:int[] a = new SplittableRandom().ints(100, 0, 1_001).parallel().toArray();\nint[] a = new SplittableRandom().ints(100, 0, 1_001).parallel().toArray();\nTo return a Stream of random values:IntStream stream = new SplittableRandom().ints(100, 0, 1_001);\nIntStream stream = new SplittableRandom().ints(100, 0, 1_001);\n",
                " rand.nextInt((max+1) - min) + min;\n rand.nextInt((max+1) - min) + min;\n",
                "Let us take an example.Suppose I wish to generate a number between 5-10:5-10int max = 10;\nint min = 5;\nint diff = max - min;\nRandom rn = new Random();\nint i = rn.nextInt(diff + 1);\ni += min;\nSystem.out.print(\"The Random Number is \" + i);\nint max = 10;\nint min = 5;\nint diff = max - min;\nRandom rn = new Random();\nint i = rn.nextInt(diff + 1);\ni += min;\nSystem.out.print(\"The Random Number is \" + i);\nLet us understand this...Let us understand this\n\nInitialize max with highest value and min with the lowest value. \nNow, we need to determine how many possible values can be obtained. For this example, it would be:\n\n5, 6, 7, 8, 9, 10\n\nSo, count of this would be max - min + 1. \n\ni.e. 10 - 5 + 1 = 6\n\nThe random number will generate a number between 0-5. \n\ni.e. 0, 1, 2, 3, 4, 5\n\nAdding the min value to the random number would produce:\n\n5, 6, 7, 8, 9, 10      \n\nHence we obtain the desired range. \n\n\nInitialize max with highest value and min with the lowest value. \nNow, we need to determine how many possible values can be obtained. For this example, it would be:\n\n5, 6, 7, 8, 9, 10\n\nSo, count of this would be max - min + 1. \n\ni.e. 10 - 5 + 1 = 6\n\nThe random number will generate a number between 0-5. \n\ni.e. 0, 1, 2, 3, 4, 5\n\nAdding the min value to the random number would produce:\n\n5, 6, 7, 8, 9, 10      \n\nHence we obtain the desired range. \nInitialize max with highest value and min with the lowest value. Now, we need to determine how many possible values can be obtained. For this example, it would be:\n5, 6, 7, 8, 9, 10\n5, 6, 7, 8, 9, 105, 6, 7, 8, 9, 10So, count of this would be max - min + 1. \ni.e. 10 - 5 + 1 = 6\ni.e. 10 - 5 + 1 = 6The random number will generate a number between 0-5. 0-5\ni.e. 0, 1, 2, 3, 4, 5\ni.e. 0, 1, 2, 3, 4, 5Adding the min value to the random number would produce:min\n5, 6, 7, 8, 9, 10      \n5, 6, 7, 8, 9, 10      Hence we obtain the desired range. ",
                "Generate a random number for the difference of min and max by using the nextint(n) method and then add min number to the result:nextint(n)Random rn = new Random();\nint result = rn.nextInt(max - min + 1) + min;\nSystem.out.println(result);\nRandom rn = new Random();\nint result = rn.nextInt(max - min + 1) + min;\nSystem.out.println(result);\n",
                "To generate a random number \"in between two numbers\", use the following code:Random r = new Random();\nint lowerBound = 1;\nint upperBound = 11;\nint result = r.nextInt(upperBound-lowerBound) + lowerBound;\nRandom r = new Random();\nint lowerBound = 1;\nint upperBound = 11;\nint result = r.nextInt(upperBound-lowerBound) + lowerBound;\nThis gives you a random number in between 1 (inclusive) and 11 (exclusive), so initialize the upperBound value by adding 1. For example, if you want to generate random number between 1 to 10 then initialize the upperBound number with 11 instead of 10.",
                "Just use the Random class: RandomRandom ran = new Random();\n// Assumes max and min are non-negative.\nint randomInt = min + ran.nextInt(max - min + 1);\nRandom ran = new Random();\n// Assumes max and min are non-negative.\nint randomInt = min + ran.nextInt(max - min + 1);\n",
                "These methods might be convenient to use:This method will return a random number between the provided minimum and maximum value:betweenbetweenpublic static int getRandomNumberBetween(int min, int max) {\n    Random foo = new Random();\n    int randomNumber = foo.nextInt(max - min) + min;\n    if (randomNumber == min) {\n        // Since the random number is between the min and max values, simply add 1\n        return min + 1;\n    } else {\n        return randomNumber;\n    }\n}\npublic static int getRandomNumberBetween(int min, int max) {\n    Random foo = new Random();\n    int randomNumber = foo.nextInt(max - min) + min;\n    if (randomNumber == min) {\n        // Since the random number is between the min and max values, simply add 1\n        return min + 1;\n    } else {\n        return randomNumber;\n    }\n}\nand this method will return a random number from the provided minimum and maximum value (so the generated number could also be the minimum or maximum number):fromfrompublic static int getRandomNumberFrom(int min, int max) {\n    Random foo = new Random();\n    int randomNumber = foo.nextInt((max + 1) - min) + min;\n\n    return randomNumber;\n}\npublic static int getRandomNumberFrom(int min, int max) {\n    Random foo = new Random();\n    int randomNumber = foo.nextInt((max + 1) - min) + min;\n\n    return randomNumber;\n}\n",
                "In case of rolling a dice it would be random number between 1 to 6 (not 0 to 6), so: face = 1 + randomNumbers.nextInt(6);\nface = 1 + randomNumbers.nextInt(6);\n",
                "int random = minimum + Double.valueOf(Math.random()*(maximum-minimum )).intValue();\nint random = minimum + Double.valueOf(Math.random()*(maximum-minimum )).intValue();\nOr take a look to RandomUtils from Apache Commons.Apache Commons",
                "You can achieve that concisely in Java 8:Random random = new Random();\n\nint max = 10;\nint min = 5;\nint totalNumber = 10;\n\nIntStream stream = random.ints(totalNumber, min, max);\nstream.forEach(System.out::println);\nRandom random = new Random();\n\nint max = 10;\nint min = 5;\nint totalNumber = 10;\n\nIntStream stream = random.ints(totalNumber, min, max);\nstream.forEach(System.out::println);\n",
                "Here's a helpful class to generate random ints in a range with any combination of inclusive/exclusive bounds:intsimport java.util.Random;\n\npublic class RandomRange extends Random {\n    public int nextIncInc(int min, int max) {\n        return nextInt(max - min + 1) + min;\n    }\n\n    public int nextExcInc(int min, int max) {\n        return nextInt(max - min) + 1 + min;\n    }\n\n    public int nextExcExc(int min, int max) {\n        return nextInt(max - min - 1) + 1 + min;\n    }\n\n    public int nextIncExc(int min, int max) {\n        return nextInt(max - min) + min;\n    }\n}\nimport java.util.Random;\n\npublic class RandomRange extends Random {\n    public int nextIncInc(int min, int max) {\n        return nextInt(max - min + 1) + min;\n    }\n\n    public int nextExcInc(int min, int max) {\n        return nextInt(max - min) + 1 + min;\n    }\n\n    public int nextExcExc(int min, int max) {\n        return nextInt(max - min - 1) + 1 + min;\n    }\n\n    public int nextIncExc(int min, int max) {\n        return nextInt(max - min) + min;\n    }\n}\n",
                "Another option is just using Apache Commons: Apache Commonsimport org.apache.commons.math.random.RandomData;\nimport org.apache.commons.math.random.RandomDataImpl;\n\npublic void method() {\n    RandomData randomData = new RandomDataImpl();\n    int number = randomData.nextInt(5, 10);\n    // ...\n }\nimport org.apache.commons.math.random.RandomData;\nimport org.apache.commons.math.random.RandomDataImpl;\n\npublic void method() {\n    RandomData randomData = new RandomDataImpl();\n    int number = randomData.nextInt(5, 10);\n    // ...\n }\n",
                "I found this example Generate random numbers : Generate random numbersThis example generates random integers in a specific range. import java.util.Random;\n\n/** Generate random integers in a certain range. */\npublic final class RandomRange {\n\n  public static final void main(String... aArgs){\n    log(\"Generating random integers in the range 1..10.\");\n\n    int START = 1;\n    int END = 10;\n    Random random = new Random();\n    for (int idx = 1; idx <= 10; ++idx){\n      showRandomInteger(START, END, random);\n    }\n\n    log(\"Done.\");\n  }\n\n  private static void showRandomInteger(int aStart, int aEnd, Random aRandom){\n    if ( aStart > aEnd ) {\n      throw new IllegalArgumentException(\"Start cannot exceed End.\");\n    }\n    //get the range, casting to long to avoid overflow problems\n    long range = (long)aEnd - (long)aStart + 1;\n    // compute a fraction of the range, 0 <= frac < range\n    long fraction = (long)(range * aRandom.nextDouble());\n    int randomNumber =  (int)(fraction + aStart);    \n    log(\"Generated : \" + randomNumber);\n  }\n\n  private static void log(String aMessage){\n    System.out.println(aMessage);\n  }\n} \nimport java.util.Random;\n\n/** Generate random integers in a certain range. */\npublic final class RandomRange {\n\n  public static final void main(String... aArgs){\n    log(\"Generating random integers in the range 1..10.\");\n\n    int START = 1;\n    int END = 10;\n    Random random = new Random();\n    for (int idx = 1; idx <= 10; ++idx){\n      showRandomInteger(START, END, random);\n    }\n\n    log(\"Done.\");\n  }\n\n  private static void showRandomInteger(int aStart, int aEnd, Random aRandom){\n    if ( aStart > aEnd ) {\n      throw new IllegalArgumentException(\"Start cannot exceed End.\");\n    }\n    //get the range, casting to long to avoid overflow problems\n    long range = (long)aEnd - (long)aStart + 1;\n    // compute a fraction of the range, 0 <= frac < range\n    long fraction = (long)(range * aRandom.nextDouble());\n    int randomNumber =  (int)(fraction + aStart);    \n    log(\"Generated : \" + randomNumber);\n  }\n\n  private static void log(String aMessage){\n    System.out.println(aMessage);\n  }\n} \nAn example run of this class :Generating random integers in the range 1..10.\nGenerated : 9\nGenerated : 3\nGenerated : 3\nGenerated : 9\nGenerated : 4\nGenerated : 1\nGenerated : 3\nGenerated : 9\nGenerated : 10\nGenerated : 10\nDone.\nGenerating random integers in the range 1..10.\nGenerated : 9\nGenerated : 3\nGenerated : 3\nGenerated : 9\nGenerated : 4\nGenerated : 1\nGenerated : 3\nGenerated : 9\nGenerated : 10\nGenerated : 10\nDone.\n",
                "public static Random RANDOM = new Random(System.nanoTime());\n\npublic static final float random(final float pMin, final float pMax) {\n    return pMin + RANDOM.nextFloat() * (pMax - pMin);\n}\npublic static Random RANDOM = new Random(System.nanoTime());\n\npublic static final float random(final float pMin, final float pMax) {\n    return pMin + RANDOM.nextFloat() * (pMax - pMin);\n}\n",
                "Here is a simple sample that shows how to generate random number from closed [min, max] range, while min <= max is true[min, max]min <= max is trueYou can reuse it as field in hole class, also having all Random.class methods in one placeRandom.classResults example:Results example:RandomUtils random = new RandomUtils();\nrandom.nextInt(0, 0); // returns 0\nrandom.nextInt(10, 10); // returns 10\nrandom.nextInt(-10, 10); // returns numbers from -10 to 10 (-10, -9....9, 10)\nrandom.nextInt(10, -10); // throws assert\nRandomUtils random = new RandomUtils();\nrandom.nextInt(0, 0); // returns 0\nrandom.nextInt(10, 10); // returns 10\nrandom.nextInt(-10, 10); // returns numbers from -10 to 10 (-10, -9....9, 10)\nrandom.nextInt(10, -10); // throws assert\nSources:Sources:import junit.framework.Assert;\nimport java.util.Random;\n\npublic class RandomUtils extends Random {\n\n    /**\n     * @param min generated value. Can't be > then max\n     * @param max generated value\n     * @return values in closed range [min, max].\n     */\n    public int nextInt(int min, int max) {\n        Assert.assertFalse(\"min can't be > then max; values:[\" + min + \", \" + max + \"]\", min > max);\n        if (min == max) {\n            return max;\n        }\n\n        return nextInt(max - min + 1) + min;\n    }\n}\nimport junit.framework.Assert;\nimport java.util.Random;\n\npublic class RandomUtils extends Random {\n\n    /**\n     * @param min generated value. Can't be > then max\n     * @param max generated value\n     * @return values in closed range [min, max].\n     */\n    public int nextInt(int min, int max) {\n        Assert.assertFalse(\"min can't be > then max; values:[\" + min + \", \" + max + \"]\", min > max);\n        if (min == max) {\n            return max;\n        }\n\n        return nextInt(max - min + 1) + min;\n    }\n}\n",
                "It's better to use SecureRandom rather than just Random.SecureRandompublic static int generateRandomInteger(int min, int max) {\n    SecureRandom rand = new SecureRandom();\n    rand.setSeed(new Date().getTime());\n    int randomNum = rand.nextInt((max - min) + 1) + min;\n    return randomNum;\n}\npublic static int generateRandomInteger(int min, int max) {\n    SecureRandom rand = new SecureRandom();\n    rand.setSeed(new Date().getTime());\n    int randomNum = rand.nextInt((max - min) + 1) + min;\n    return randomNum;\n}\n",
                "rand.nextInt((max+1) - min) + min;\nrand.nextInt((max+1) - min) + min;\nThis is working fine. "
            ]
        },
        {
            "tag": "c#",
            "patterns": [
                "How do I cast int to enum in C#?",
                "How do I cast int to enum in C#?"
            ],
            "responses": [
                "From an int:YourEnum foo = (YourEnum)yourInt;\nYourEnum foo = (YourEnum)yourInt;\nFrom a string:YourEnum foo = (YourEnum) Enum.Parse(typeof(YourEnum), yourString);\n\n// The foo.ToString().Contains(\",\") check is necessary for \n// enumerations marked with a [Flags] attribute.\nif (!Enum.IsDefined(typeof(YourEnum), foo) && !foo.ToString().Contains(\",\"))\n{\n    throw new InvalidOperationException(\n        $\"{yourString} is not an underlying value of the YourEnum enumeration.\"\n    );\n}\nYourEnum foo = (YourEnum) Enum.Parse(typeof(YourEnum), yourString);\n\n// The foo.ToString().Contains(\",\") check is necessary for \n// enumerations marked with a [Flags] attribute.\nif (!Enum.IsDefined(typeof(YourEnum), foo) && !foo.ToString().Contains(\",\"))\n{\n    throw new InvalidOperationException(\n        $\"{yourString} is not an underlying value of the YourEnum enumeration.\"\n    );\n}\nFrom a number:YourEnum foo = (YourEnum)Enum.ToObject(typeof(YourEnum), yourInt);\nYourEnum foo = (YourEnum)Enum.ToObject(typeof(YourEnum), yourInt);\n",
                "Just cast it:MyEnum e = (MyEnum)3;\nMyEnum e = (MyEnum)3;\nCheck if it's in range using Enum.IsDefined:Enum.IsDefinedEnum.IsDefinedif (Enum.IsDefined(typeof(MyEnum), 3)) { ... }\nif (Enum.IsDefined(typeof(MyEnum), 3)) { ... }\n",
                "Alternatively, use an extension method instead of a one-liner:public static T ToEnum<T>(this string enumString)\n{\n    return (T) Enum.Parse(typeof (T), enumString);\n}\npublic static T ToEnum<T>(this string enumString)\n{\n    return (T) Enum.Parse(typeof (T), enumString);\n}\nUsage:Usage:Usage:Color colorEnum = \"Red\".ToEnum<Color>();\nColor colorEnum = \"Red\".ToEnum<Color>();\nORstring color = \"Red\";\nvar colorEnum = color.ToEnum<Color>();\nstring color = \"Red\";\nvar colorEnum = color.ToEnum<Color>();\n",
                "I think to get a complete answer, people have to know how enums work internally in .NET. How stuff worksHow stuff worksAn enum in .NET is a structure that maps a set of values (fields) to a basic type (the default is int). However, you can actually choose the integral type that your enum maps to:intpublic enum Foo : short\npublic enum Foo : short\nIn this case the enum is mapped to the short data type, which means it will be stored in memory as a short and will behave as a short when you cast and use it. shortIf you look at it from a IL point of view, a (normal, int) enum looks like this:.class public auto ansi serializable sealed BarFlag extends System.Enum\n{\n    .custom instance void System.FlagsAttribute::.ctor()\n    .custom instance void ComVisibleAttribute::.ctor(bool) = { bool(true) }\n\n    .field public static literal valuetype BarFlag AllFlags = int32(0x3fff)\n    .field public static literal valuetype BarFlag Foo1 = int32(1)\n    .field public static literal valuetype BarFlag Foo2 = int32(0x2000)\n\n    // and so on for all flags or enum values\n\n    .field public specialname rtspecialname int32 value__\n}\n.class public auto ansi serializable sealed BarFlag extends System.Enum\n{\n    .custom instance void System.FlagsAttribute::.ctor()\n    .custom instance void ComVisibleAttribute::.ctor(bool) = { bool(true) }\n\n    .field public static literal valuetype BarFlag AllFlags = int32(0x3fff)\n    .field public static literal valuetype BarFlag Foo1 = int32(1)\n    .field public static literal valuetype BarFlag Foo2 = int32(0x2000)\n\n    // and so on for all flags or enum values\n\n    .field public specialname rtspecialname int32 value__\n}\nWhat should get your attention here is that the value__ is stored separately from the enum values. In the case of the enum Foo above, the type of value__ is int16. This basically means that you can store whatever you want in an enum, as long as the types match.value__Foovalue__as long as the types matchAt this point I'd like to point out that System.Enum is a value type, which basically means that BarFlag will take up 4 bytes in memory and Foo will take up 2 -- e.g. the size of the underlying type (it's actually more complicated than that, but hey...).System.EnumBarFlagFooThe answerThe answerSo, if you have an integer that you want to map to an enum, the runtime only has to do 2 things: copy the 4 bytes and name it something else (the name of the enum). Copying is implicit because the data is stored as value type - this basically means that if you use unmanaged code, you can simply interchange enums and integers without copying data.To make it safe, I think it's a best practice to know that the underlying types are the same or implicitly convertible and to ensure the enum values exist (they aren't checked by default!).know that the underlying types are the same or implicitly convertibleTo see how this works, try the following code:public enum MyEnum : int\n{\n    Foo = 1,\n    Bar = 2,\n    Mek = 5\n}\n\nstatic void Main(string[] args)\n{\n    var e1 = (MyEnum)5;\n    var e2 = (MyEnum)6;\n\n    Console.WriteLine(\"{0} {1}\", e1, e2);\n    Console.ReadLine();\n}\npublic enum MyEnum : int\n{\n    Foo = 1,\n    Bar = 2,\n    Mek = 5\n}\n\nstatic void Main(string[] args)\n{\n    var e1 = (MyEnum)5;\n    var e2 = (MyEnum)6;\n\n    Console.WriteLine(\"{0} {1}\", e1, e2);\n    Console.ReadLine();\n}\nNote that casting to e2 also works! From the compiler perspective above this makes sense: the value__ field is simply filled with either 5 or 6 and when Console.WriteLine calls ToString(), the name of e1 is resolved while the name of e2 is not.e2value__Console.WriteLineToString()e1e2If that's not what you intended, use Enum.IsDefined(typeof(MyEnum), 6) to check if the value you are casting maps to a defined enum.Enum.IsDefined(typeof(MyEnum), 6)Also note that I'm explicit about the underlying type of the enum, even though the compiler actually checks this. I'm doing this to ensure I don't run into any surprises down the road. To see these surprises in action, you can use the following code (actually I've seen this happen a lot in database code):public enum MyEnum : short\n{\n    Mek = 5\n}\n\nstatic void Main(string[] args)\n{\n    var e1 = (MyEnum)32769; // will not compile, out of bounds for a short\n\n    object o = 5;\n    var e2 = (MyEnum)o;     // will throw at runtime, because o is of type int\n\n    Console.WriteLine(\"{0} {1}\", e1, e2);\n    Console.ReadLine();\n}\npublic enum MyEnum : short\n{\n    Mek = 5\n}\n\nstatic void Main(string[] args)\n{\n    var e1 = (MyEnum)32769; // will not compile, out of bounds for a short\n\n    object o = 5;\n    var e2 = (MyEnum)o;     // will throw at runtime, because o is of type int\n\n    Console.WriteLine(\"{0} {1}\", e1, e2);\n    Console.ReadLine();\n}\n",
                "Take the following example:int one = 1;\nMyEnum e = (MyEnum)one;\nint one = 1;\nMyEnum e = (MyEnum)one;\n",
                "I am using this piece of code to cast int to my enum:if (typeof(YourEnum).IsEnumDefined(valueToCast)) return (YourEnum)valueToCast;\nelse { //handle it here, if its not defined }\nif (typeof(YourEnum).IsEnumDefined(valueToCast)) return (YourEnum)valueToCast;\nelse { //handle it here, if its not defined }\nI find it the best solution.",
                "Below is a nice utility class for Enumspublic static class EnumHelper\n{\n    public static int[] ToIntArray<T>(T[] value)\n    {\n        int[] result = new int[value.Length];\n        for (int i = 0; i < value.Length; i++)\n            result[i] = Convert.ToInt32(value[i]);\n        return result;\n    }\n\n    public static T[] FromIntArray<T>(int[] value) \n    {\n        T[] result = new T[value.Length];\n        for (int i = 0; i < value.Length; i++)\n            result[i] = (T)Enum.ToObject(typeof(T),value[i]);\n        return result;\n    }\n\n\n    internal static T Parse<T>(string value, T defaultValue)\n    {\n        if (Enum.IsDefined(typeof(T), value))\n            return (T) Enum.Parse(typeof (T), value);\n\n        int num;\n        if(int.TryParse(value,out num))\n        {\n            if (Enum.IsDefined(typeof(T), num))\n                return (T)Enum.ToObject(typeof(T), num);\n        }\n\n        return defaultValue;\n    }\n}\npublic static class EnumHelper\n{\n    public static int[] ToIntArray<T>(T[] value)\n    {\n        int[] result = new int[value.Length];\n        for (int i = 0; i < value.Length; i++)\n            result[i] = Convert.ToInt32(value[i]);\n        return result;\n    }\n\n    public static T[] FromIntArray<T>(int[] value) \n    {\n        T[] result = new T[value.Length];\n        for (int i = 0; i < value.Length; i++)\n            result[i] = (T)Enum.ToObject(typeof(T),value[i]);\n        return result;\n    }\n\n\n    internal static T Parse<T>(string value, T defaultValue)\n    {\n        if (Enum.IsDefined(typeof(T), value))\n            return (T) Enum.Parse(typeof (T), value);\n\n        int num;\n        if(int.TryParse(value,out num))\n        {\n            if (Enum.IsDefined(typeof(T), num))\n                return (T)Enum.ToObject(typeof(T), num);\n        }\n\n        return defaultValue;\n    }\n}\n",
                "For numeric values, this is safer as it will return an object no matter what:public static class EnumEx\n{\n    static public bool TryConvert<T>(int value, out T result)\n    {\n        result = default(T);\n        bool success = Enum.IsDefined(typeof(T), value);\n        if (success)\n        {\n            result = (T)Enum.ToObject(typeof(T), value);\n        }\n        return success;\n    }\n}\npublic static class EnumEx\n{\n    static public bool TryConvert<T>(int value, out T result)\n    {\n        result = default(T);\n        bool success = Enum.IsDefined(typeof(T), value);\n        if (success)\n        {\n            result = (T)Enum.ToObject(typeof(T), value);\n        }\n        return success;\n    }\n}\n",
                "If you're ready for the 4.0 .NET Framework, there's a new Enum.TryParse() function that's very useful and plays well with the [Flags] attribute. See Enum.TryParse Method (String, TEnum%).NETEnum.TryParse()Enum.TryParse Method (String, TEnum%)Enum.TryParse Method (String, TEnum%)",
                "Sometimes you have an object to the MyEnum type. LikeMyEnumvar MyEnumType = typeof(MyEnum);\nvar MyEnumType = typeof(MyEnum);\nThen:Enum.ToObject(typeof(MyEnum), 3)\nEnum.ToObject(typeof(MyEnum), 3)\n",
                "If you have an integer that acts as a bitmask and could represent one or more values in a [Flags] enumeration, you can use this code to parse the individual flag values into a list:for (var flagIterator = 0; flagIterator < 32; flagIterator++)\n{\n    // Determine the bit value (1,2,4,...,Int32.MinValue)\n    int bitValue = 1 << flagIterator;\n\n    // Check to see if the current flag exists in the bit mask\n    if ((intValue & bitValue) != 0)\n    {\n        // If the current flag exists in the enumeration, then we can add that value to the list\n        // if the enumeration has that flag defined\n        if (Enum.IsDefined(typeof(MyEnum), bitValue))\n            Console.WriteLine((MyEnum)bitValue);\n    }\n}\nfor (var flagIterator = 0; flagIterator < 32; flagIterator++)\n{\n    // Determine the bit value (1,2,4,...,Int32.MinValue)\n    int bitValue = 1 << flagIterator;\n\n    // Check to see if the current flag exists in the bit mask\n    if ((intValue & bitValue) != 0)\n    {\n        // If the current flag exists in the enumeration, then we can add that value to the list\n        // if the enumeration has that flag defined\n        if (Enum.IsDefined(typeof(MyEnum), bitValue))\n            Console.WriteLine((MyEnum)bitValue);\n    }\n}\nNote that this assumes that the underlying type of the enum is a signed 32-bit integer. If it were a different numerical type, you'd have to change the hardcoded 32 to reflect the bits in that type (or programatically derive it using Enum.GetUnderlyingType())enumEnum.GetUnderlyingType()",
                "This is an flags enumeration aware safe convert method:public static bool TryConvertToEnum<T>(this int instance, out T result)\n  where T: Enum\n{\n  var enumType = typeof (T);\n  var success = Enum.IsDefined(enumType, instance);\n  if (success)\n  {\n    result = (T)Enum.ToObject(enumType, instance);\n  }\n  else\n  {\n    result = default(T);\n  }\n  return success;\n}\npublic static bool TryConvertToEnum<T>(this int instance, out T result)\n  where T: Enum\n{\n  var enumType = typeof (T);\n  var success = Enum.IsDefined(enumType, instance);\n  if (success)\n  {\n    result = (T)Enum.ToObject(enumType, instance);\n  }\n  else\n  {\n    result = default(T);\n  }\n  return success;\n}\n",
                "To convert a string to ENUM or int to ENUM constant we need to use Enum.Parse function. Here is a youtube video https://www.youtube.com/watch?v=4nhx4VwdRDk  which actually demonstrate's with string and the same applies for int.https://www.youtube.com/watch?v=4nhx4VwdRDkThe code goes as shown below where \"red\" is the string and \"MyColors\" is the color ENUM which has the color constants.MyColors EnumColors = (MyColors)Enum.Parse(typeof(MyColors), \"Red\");\nMyColors EnumColors = (MyColors)Enum.Parse(typeof(MyColors), \"Red\");\n",
                "Slightly getting away from the original question, but I found an answer to Stack\u00a0Overflow question Get int value from enum useful. Create a static class with public const int properties, allowing you to easily collect together a bunch of related int constants, and then not have to cast them to int when using them.an answer to Stack\u00a0Overflow question Get int value from enumGet int value from enumpublic const intintintpublic static class Question\n{\n    public static readonly int Role = 2;\n    public static readonly int ProjectFunding = 3;\n    public static readonly int TotalEmployee = 4;\n    public static readonly int NumberOfServers = 5;\n    public static readonly int TopBusinessConcern = 6;\n}\npublic static class Question\n{\n    public static readonly int Role = 2;\n    public static readonly int ProjectFunding = 3;\n    public static readonly int TotalEmployee = 4;\n    public static readonly int NumberOfServers = 5;\n    public static readonly int TopBusinessConcern = 6;\n}\nObviously, some of the enum type functionality will be lost, but for storing a bunch of database id constants, it seems like a pretty tidy solution.",
                "The following is a slightly better extension method:public static string ToEnumString<TEnum>(this int enumValue)\n{\n    var enumString = enumValue.ToString();\n    if (Enum.IsDefined(typeof(TEnum), enumValue))\n    {\n        enumString = ((TEnum) Enum.ToObject(typeof (TEnum), enumValue)).ToString();\n    }\n    return enumString;\n}\npublic static string ToEnumString<TEnum>(this int enumValue)\n{\n    var enumString = enumValue.ToString();\n    if (Enum.IsDefined(typeof(TEnum), enumValue))\n    {\n        enumString = ((TEnum) Enum.ToObject(typeof (TEnum), enumValue)).ToString();\n    }\n    return enumString;\n}\n",
                "This parses integers or strings to a target enum with partial matching in .NET 4.0 using generics like in Tawani's utility class. I am using it to convert command-line switch variables which may be incomplete.  Since an enum cannot be null, you should logically provide a default value.  It can be called like this:Tawani's utility classvar result = EnumParser<MyEnum>.Parse(valueToParse, MyEnum.FirstValue);\nvar result = EnumParser<MyEnum>.Parse(valueToParse, MyEnum.FirstValue);\nHere's the code:using System;\n\npublic class EnumParser<T> where T : struct\n{\n    public static T Parse(int toParse, T defaultVal)\n    {\n        return Parse(toParse + \"\", defaultVal);\n    }\n    public static T Parse(string toParse, T defaultVal)\n    {\n        T enumVal = defaultVal;\n        if (defaultVal is Enum && !String.IsNullOrEmpty(toParse))\n        {\n            int index;\n            if (int.TryParse(toParse, out index))\n            {\n                Enum.TryParse(index + \"\", out enumVal);\n            }\n            else\n            {\n                if (!Enum.TryParse<T>(toParse + \"\", true, out enumVal))\n                {\n                    MatchPartialName(toParse, ref enumVal);\n                }\n            }\n        }\n        return enumVal;\n    }\n\n    public static void MatchPartialName(string toParse, ref T enumVal)\n    {\n        foreach (string member in enumVal.GetType().GetEnumNames())\n        {\n            if (member.ToLower().Contains(toParse.ToLower()))\n            {\n                if (Enum.TryParse<T>(member + \"\", out enumVal))\n                {\n                    break;\n                }\n            }\n        }\n    }\n}\nusing System;\n\npublic class EnumParser<T> where T : struct\n{\n    public static T Parse(int toParse, T defaultVal)\n    {\n        return Parse(toParse + \"\", defaultVal);\n    }\n    public static T Parse(string toParse, T defaultVal)\n    {\n        T enumVal = defaultVal;\n        if (defaultVal is Enum && !String.IsNullOrEmpty(toParse))\n        {\n            int index;\n            if (int.TryParse(toParse, out index))\n            {\n                Enum.TryParse(index + \"\", out enumVal);\n            }\n            else\n            {\n                if (!Enum.TryParse<T>(toParse + \"\", true, out enumVal))\n                {\n                    MatchPartialName(toParse, ref enumVal);\n                }\n            }\n        }\n        return enumVal;\n    }\n\n    public static void MatchPartialName(string toParse, ref T enumVal)\n    {\n        foreach (string member in enumVal.GetType().GetEnumNames())\n        {\n            if (member.ToLower().Contains(toParse.ToLower()))\n            {\n                if (Enum.TryParse<T>(member + \"\", out enumVal))\n                {\n                    break;\n                }\n            }\n        }\n    }\n}\nFYI:  The question was about integers, which nobody mentioned will also explicitly convert in Enum.TryParse()FYI:",
                "From a string: (Enum.Parse is out of Date, use Enum.TryParse) enum Importance\n{}\n\nImportance importance;\n\nif (Enum.TryParse(value, out importance))\n{\n}\nenum Importance\n{}\n\nImportance importance;\n\nif (Enum.TryParse(value, out importance))\n{\n}\n",
                "You should build in some type matching relaxation to be more robust.public static T ToEnum<T>(dynamic value)\n{\n    if (value == null)\n    {\n        // default value of an enum is the object that corresponds to\n        // the default value of its underlying type\n        // https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/default-values-table\n        value = Activator.CreateInstance(Enum.GetUnderlyingType(typeof(T)));\n    }\n    else if (value is string name)\n    {\n        return (T)Enum.Parse(typeof(T), name);\n    }\n\n    return (T)Enum.ToObject(typeof(T),\n             Convert.ChangeType(value, Enum.GetUnderlyingType(typeof(T))));\n}\npublic static T ToEnum<T>(dynamic value)\n{\n    if (value == null)\n    {\n        // default value of an enum is the object that corresponds to\n        // the default value of its underlying type\n        // https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/default-values-table\n        value = Activator.CreateInstance(Enum.GetUnderlyingType(typeof(T)));\n    }\n    else if (value is string name)\n    {\n        return (T)Enum.Parse(typeof(T), name);\n    }\n\n    return (T)Enum.ToObject(typeof(T),\n             Convert.ChangeType(value, Enum.GetUnderlyingType(typeof(T))));\n}\nTest Case[Flags]\npublic enum A : uint\n{\n    None  = 0, \n    X     = 1 < 0,\n    Y     = 1 < 1\n}\n\nstatic void Main(string[] args)\n{\n    var value = EnumHelper.ToEnum<A>(7m);\n    var x = value.HasFlag(A.X); // true\n    var y = value.HasFlag(A.Y); // true\n\n    var value2 = EnumHelper.ToEnum<A>(\"X\");\n\n    var value3 = EnumHelper.ToEnum<A>(null);\n\n    Console.ReadKey();\n}\n[Flags]\npublic enum A : uint\n{\n    None  = 0, \n    X     = 1 < 0,\n    Y     = 1 < 1\n}\n\nstatic void Main(string[] args)\n{\n    var value = EnumHelper.ToEnum<A>(7m);\n    var x = value.HasFlag(A.X); // true\n    var y = value.HasFlag(A.Y); // true\n\n    var value2 = EnumHelper.ToEnum<A>(\"X\");\n\n    var value3 = EnumHelper.ToEnum<A>(null);\n\n    Console.ReadKey();\n}\n",
                "Here's an extension method that casts Int32 to Enum.Int32EnumIt honors bitwise flags even when the value is higher than the maximum possible. For example if you have an enum with possibilities 1, 2, and 4, but the int is 9, it understands that as 1 in absence of an 8. This lets you make data updates ahead of code updates.124918   public static TEnum ToEnum<TEnum>(this int val) where TEnum : struct, IComparable, IFormattable, IConvertible\n    {\n        if (!typeof(TEnum).IsEnum)\n        {\n            return default(TEnum);\n        }\n\n        if (Enum.IsDefined(typeof(TEnum), val))\n        {//if a straightforward single value, return that\n            return (TEnum)Enum.ToObject(typeof(TEnum), val);\n        }\n\n        var candidates = Enum\n            .GetValues(typeof(TEnum))\n            .Cast<int>()\n            .ToList();\n\n        var isBitwise = candidates\n            .Select((n, i) => {\n                if (i < 2) return n == 0 || n == 1;\n                return n / 2 == candidates[i - 1];\n            })\n            .All(y => y);\n\n        var maxPossible = candidates.Sum();\n\n        if (\n            Enum.TryParse(val.ToString(), out TEnum asEnum)\n            && (val <= maxPossible || !isBitwise)\n        ){//if it can be parsed as a bitwise enum with multiple flags,\n          //or is not bitwise, return the result of TryParse\n            return asEnum;\n        }\n\n        //If the value is higher than all possible combinations,\n        //remove the high imaginary values not accounted for in the enum\n        var excess = Enumerable\n            .Range(0, 32)\n            .Select(n => (int)Math.Pow(2, n))\n            .Where(n => n <= val && n > 0 && !candidates.Contains(n))\n            .Sum();\n\n        return Enum.TryParse((val - excess).ToString(), out asEnum) ? asEnum : default(TEnum);\n    }\n   public static TEnum ToEnum<TEnum>(this int val) where TEnum : struct, IComparable, IFormattable, IConvertible\n    {\n        if (!typeof(TEnum).IsEnum)\n        {\n            return default(TEnum);\n        }\n\n        if (Enum.IsDefined(typeof(TEnum), val))\n        {//if a straightforward single value, return that\n            return (TEnum)Enum.ToObject(typeof(TEnum), val);\n        }\n\n        var candidates = Enum\n            .GetValues(typeof(TEnum))\n            .Cast<int>()\n            .ToList();\n\n        var isBitwise = candidates\n            .Select((n, i) => {\n                if (i < 2) return n == 0 || n == 1;\n                return n / 2 == candidates[i - 1];\n            })\n            .All(y => y);\n\n        var maxPossible = candidates.Sum();\n\n        if (\n            Enum.TryParse(val.ToString(), out TEnum asEnum)\n            && (val <= maxPossible || !isBitwise)\n        ){//if it can be parsed as a bitwise enum with multiple flags,\n          //or is not bitwise, return the result of TryParse\n            return asEnum;\n        }\n\n        //If the value is higher than all possible combinations,\n        //remove the high imaginary values not accounted for in the enum\n        var excess = Enumerable\n            .Range(0, 32)\n            .Select(n => (int)Math.Pow(2, n))\n            .Where(n => n <= val && n > 0 && !candidates.Contains(n))\n            .Sum();\n\n        return Enum.TryParse((val - excess).ToString(), out asEnum) ? asEnum : default(TEnum);\n    }\n",
                "The easy and clear way for casting an int to enum in C#:public class Program\n{\n    public enum Color : int\n    {\n        Blue   = 0,\n        Black  = 1,\n        Green  = 2,\n        Gray   = 3,\n        Yellow = 4\n    }\n\n    public static void Main(string[] args)\n    {\n        // From string\n        Console.WriteLine((Color) Enum.Parse(typeof(Color), \"Green\"));\n\n        // From int\n        Console.WriteLine((Color)2);\n\n        // From number you can also\n        Console.WriteLine((Color)Enum.ToObject(typeof(Color), 2));\n    }\n}\npublic class Program\n{\n    public enum Color : int\n    {\n        Blue   = 0,\n        Black  = 1,\n        Green  = 2,\n        Gray   = 3,\n        Yellow = 4\n    }\n\n    public static void Main(string[] args)\n    {\n        // From string\n        Console.WriteLine((Color) Enum.Parse(typeof(Color), \"Green\"));\n\n        // From int\n        Console.WriteLine((Color)2);\n\n        // From number you can also\n        Console.WriteLine((Color)Enum.ToObject(typeof(Color), 2));\n    }\n}\n",
                "For string, you can do the following:For string, you can do the following:var result = Enum.TryParse(typeof(MyEnum), yourString, out yourEnum) \nvar result = Enum.TryParse(typeof(MyEnum), yourString, out yourEnum) \nAnd make sure to check the result to determine if the conversion failed.For int, you can do the following:For int, you can do the following:MyEnum someValue = (MyEnum)myIntValue;\nMyEnum someValue = (MyEnum)myIntValue;\n",
                "In my case, I needed to return the enum from a WCF service.  I also needed a friendly name, not just the enum.ToString().Here's my WCF Class.[DataContract]\npublic class EnumMember\n{\n    [DataMember]\n    public string Description { get; set; }\n\n    [DataMember]\n    public int Value { get; set; }\n\n    public static List<EnumMember> ConvertToList<T>()\n    {\n        Type type = typeof(T);\n\n        if (!type.IsEnum)\n        {\n            throw new ArgumentException(\"T must be of type enumeration.\");\n        }\n\n        var members = new List<EnumMember>();\n\n        foreach (string item in System.Enum.GetNames(type))\n        {\n            var enumType = System.Enum.Parse(type, item);\n\n            members.Add(\n                new EnumMember() { Description = enumType.GetDescriptionValue(), Value = ((IConvertible)enumType).ToInt32(null) });\n        }\n\n        return members;\n    }\n}\n[DataContract]\npublic class EnumMember\n{\n    [DataMember]\n    public string Description { get; set; }\n\n    [DataMember]\n    public int Value { get; set; }\n\n    public static List<EnumMember> ConvertToList<T>()\n    {\n        Type type = typeof(T);\n\n        if (!type.IsEnum)\n        {\n            throw new ArgumentException(\"T must be of type enumeration.\");\n        }\n\n        var members = new List<EnumMember>();\n\n        foreach (string item in System.Enum.GetNames(type))\n        {\n            var enumType = System.Enum.Parse(type, item);\n\n            members.Add(\n                new EnumMember() { Description = enumType.GetDescriptionValue(), Value = ((IConvertible)enumType).ToInt32(null) });\n        }\n\n        return members;\n    }\n}\nHere's the Extension method that gets the Description from the Enum.    public static string GetDescriptionValue<T>(this T source)\n    {\n        FieldInfo fileInfo = source.GetType().GetField(source.ToString());\n        DescriptionAttribute[] attributes = (DescriptionAttribute[])fileInfo.GetCustomAttributes(typeof(DescriptionAttribute), false);            \n\n        if (attributes != null && attributes.Length > 0)\n        {\n            return attributes[0].Description;\n        }\n        else\n        {\n            return source.ToString();\n        }\n    }\n    public static string GetDescriptionValue<T>(this T source)\n    {\n        FieldInfo fileInfo = source.GetType().GetField(source.ToString());\n        DescriptionAttribute[] attributes = (DescriptionAttribute[])fileInfo.GetCustomAttributes(typeof(DescriptionAttribute), false);            \n\n        if (attributes != null && attributes.Length > 0)\n        {\n            return attributes[0].Description;\n        }\n        else\n        {\n            return source.ToString();\n        }\n    }\nImplementation:return EnumMember.ConvertToList<YourType>();\nreturn EnumMember.ConvertToList<YourType>();\n",
                "It can help you to convert any input data to user desired enum. Suppose you have an enum like below which by default int. Please add a Default value at first of your enum. Which is used at helpers medthod when there is no match found with input value.enumintDefaultpublic enum FriendType  \n{\n    Default,\n    Audio,\n    Video,\n    Image\n}\n\npublic static class EnumHelper<T>\n{\n    public static T ConvertToEnum(dynamic value)\n    {\n        var result = default(T);\n        var tempType = 0;\n\n        //see Note below\n        if (value != null &&\n            int.TryParse(value.ToString(), out  tempType) && \n            Enum.IsDefined(typeof(T), tempType))\n        {\n            result = (T)Enum.ToObject(typeof(T), tempType); \n        }\n        return result;\n    }\n}\npublic enum FriendType  \n{\n    Default,\n    Audio,\n    Video,\n    Image\n}\n\npublic static class EnumHelper<T>\n{\n    public static T ConvertToEnum(dynamic value)\n    {\n        var result = default(T);\n        var tempType = 0;\n\n        //see Note below\n        if (value != null &&\n            int.TryParse(value.ToString(), out  tempType) && \n            Enum.IsDefined(typeof(T), tempType))\n        {\n            result = (T)Enum.ToObject(typeof(T), tempType); \n        }\n        return result;\n    }\n}\nN.B: Here I try to parse value into int, because enum is by default int\nIf you define enum like this which is byte type.N.B:intbytepublic enum MediaType : byte\n{\n    Default,\n    Audio,\n    Video,\n    Image\n} \npublic enum MediaType : byte\n{\n    Default,\n    Audio,\n    Video,\n    Image\n} \nYou need to change parsing at helper method from int.TryParse(value.ToString(), out  tempType)\nint.TryParse(value.ToString(), out  tempType)\ntobyte.TryParse(value.ToString(), out  tempType) byte.TryParse(value.ToString(), out  tempType)I check my method for following inputsEnumHelper<FriendType>.ConvertToEnum(null);\nEnumHelper<FriendType>.ConvertToEnum(\"\");\nEnumHelper<FriendType>.ConvertToEnum(\"-1\");\nEnumHelper<FriendType>.ConvertToEnum(\"6\");\nEnumHelper<FriendType>.ConvertToEnum(\"\");\nEnumHelper<FriendType>.ConvertToEnum(\"2\");\nEnumHelper<FriendType>.ConvertToEnum(-1);\nEnumHelper<FriendType>.ConvertToEnum(0);\nEnumHelper<FriendType>.ConvertToEnum(1);\nEnumHelper<FriendType>.ConvertToEnum(9);\nEnumHelper<FriendType>.ConvertToEnum(null);\nEnumHelper<FriendType>.ConvertToEnum(\"\");\nEnumHelper<FriendType>.ConvertToEnum(\"-1\");\nEnumHelper<FriendType>.ConvertToEnum(\"6\");\nEnumHelper<FriendType>.ConvertToEnum(\"\");\nEnumHelper<FriendType>.ConvertToEnum(\"2\");\nEnumHelper<FriendType>.ConvertToEnum(-1);\nEnumHelper<FriendType>.ConvertToEnum(0);\nEnumHelper<FriendType>.ConvertToEnum(1);\nEnumHelper<FriendType>.ConvertToEnum(9);\nsorry for my english",
                "Different ways to cast to and from Enumto and fromEnumenum orientation : byte\n{\n north = 1,\n south = 2,\n east = 3,\n west = 4\n}\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    orientation myDirection = orientation.north;\n    Console.WriteLine(\u201cmyDirection = {0}\u201d, myDirection); //output myDirection =north\n    Console.WriteLine((byte)myDirection); //output 1\n\n    string strDir = Convert.ToString(myDirection);\n        Console.WriteLine(strDir); //output north\n\n    string myString = \u201cnorth\u201d; //to convert string to Enum\n    myDirection = (orientation)Enum.Parse(typeof(orientation),myString);\n\n\n }\n}\nenum orientation : byte\n{\n north = 1,\n south = 2,\n east = 3,\n west = 4\n}\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    orientation myDirection = orientation.north;\n    Console.WriteLine(\u201cmyDirection = {0}\u201d, myDirection); //output myDirection =north\n    Console.WriteLine((byte)myDirection); //output 1\n\n    string strDir = Convert.ToString(myDirection);\n        Console.WriteLine(strDir); //output north\n\n    string myString = \u201cnorth\u201d; //to convert string to Enum\n    myDirection = (orientation)Enum.Parse(typeof(orientation),myString);\n\n\n }\n}\n",
                "I don't know anymore where I get the part of this enum extension, but it is from stackoverflow. I am sorry for this! But I took this one and modified it for enums with Flags. \nFor enums with Flags I did this:  public static class Enum<T> where T : struct\n  {\n     private static readonly IEnumerable<T> All = Enum.GetValues(typeof (T)).Cast<T>();\n     private static readonly Dictionary<int, T> Values = All.ToDictionary(k => Convert.ToInt32(k));\n\n     public static T? CastOrNull(int value)\n     {\n        T foundValue;\n        if (Values.TryGetValue(value, out foundValue))\n        {\n           return foundValue;\n        }\n\n        // For enums with Flags-Attribut.\n        try\n        {\n           bool isFlag = typeof(T).GetCustomAttributes(typeof(FlagsAttribute), false).Length > 0;\n           if (isFlag)\n           {\n              int existingIntValue = 0;\n\n              foreach (T t in Enum.GetValues(typeof(T)))\n              {\n                 if ((value & Convert.ToInt32(t)) > 0)\n                 {\n                    existingIntValue |= Convert.ToInt32(t);\n                 }\n              }\n              if (existingIntValue == 0)\n              {\n                 return null;\n              }\n\n              return (T)(Enum.Parse(typeof(T), existingIntValue.ToString(), true));\n           }\n        }\n        catch (Exception)\n        {\n           return null;\n        }\n        return null;\n     }\n  }\n  public static class Enum<T> where T : struct\n  {\n     private static readonly IEnumerable<T> All = Enum.GetValues(typeof (T)).Cast<T>();\n     private static readonly Dictionary<int, T> Values = All.ToDictionary(k => Convert.ToInt32(k));\n\n     public static T? CastOrNull(int value)\n     {\n        T foundValue;\n        if (Values.TryGetValue(value, out foundValue))\n        {\n           return foundValue;\n        }\n\n        // For enums with Flags-Attribut.\n        try\n        {\n           bool isFlag = typeof(T).GetCustomAttributes(typeof(FlagsAttribute), false).Length > 0;\n           if (isFlag)\n           {\n              int existingIntValue = 0;\n\n              foreach (T t in Enum.GetValues(typeof(T)))\n              {\n                 if ((value & Convert.ToInt32(t)) > 0)\n                 {\n                    existingIntValue |= Convert.ToInt32(t);\n                 }\n              }\n              if (existingIntValue == 0)\n              {\n                 return null;\n              }\n\n              return (T)(Enum.Parse(typeof(T), existingIntValue.ToString(), true));\n           }\n        }\n        catch (Exception)\n        {\n           return null;\n        }\n        return null;\n     }\n  }\nExample:  [Flags]\npublic enum PetType\n{\n  None = 0, Dog = 1, Cat = 2, Fish = 4, Bird = 8, Reptile = 16, Other = 32\n};\n\ninteger values \n1=Dog;\n13= Dog | Fish | Bird;\n96= Other;\n128= Null;\n[Flags]\npublic enum PetType\n{\n  None = 0, Dog = 1, Cat = 2, Fish = 4, Bird = 8, Reptile = 16, Other = 32\n};\n\ninteger values \n1=Dog;\n13= Dog | Fish | Bird;\n96= Other;\n128= Null;\n",
                "You simply use Explicit conversion Cast int to enum or enum to intExplicit conversionclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine((int)Number.three); //Output=3\n\n        Console.WriteLine((Number)3);// Outout three\n        Console.Read();\n    }\n\n    public enum Number\n    {\n        Zero = 0,\n        One = 1,\n        Two = 2,\n        three = 3\n    }\n}\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine((int)Number.three); //Output=3\n\n        Console.WriteLine((Number)3);// Outout three\n        Console.Read();\n    }\n\n    public enum Number\n    {\n        Zero = 0,\n        One = 1,\n        Two = 2,\n        three = 3\n    }\n}\n",
                "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace SamplePrograme\n{\n    public class Program\n    {\n        public enum Suit : int\n        {\n            Spades = 0,\n            Hearts = 1,\n            Clubs = 2,\n            Diamonds = 3\n        }\n\n        public static void Main(string[] args)\n        {\n            //from string\n            Console.WriteLine((Suit) Enum.Parse(typeof(Suit), \"Clubs\"));\n\n            //from int\n            Console.WriteLine((Suit)1);\n\n            //From number you can also\n            Console.WriteLine((Suit)Enum.ToObject(typeof(Suit) ,1));\n        }\n    }\n}\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace SamplePrograme\n{\n    public class Program\n    {\n        public enum Suit : int\n        {\n            Spades = 0,\n            Hearts = 1,\n            Clubs = 2,\n            Diamonds = 3\n        }\n\n        public static void Main(string[] args)\n        {\n            //from string\n            Console.WriteLine((Suit) Enum.Parse(typeof(Suit), \"Clubs\"));\n\n            //from int\n            Console.WriteLine((Suit)1);\n\n            //From number you can also\n            Console.WriteLine((Suit)Enum.ToObject(typeof(Suit) ,1));\n        }\n    }\n}\n",
                "I prefer a short way using a nullable enum type variable.var enumValue = (MyEnum?)enumInt;\n\nif (!enumValue.HasValue)\n{\n    throw new ArgumentException(nameof(enumValue));\n}\nvar enumValue = (MyEnum?)enumInt;\n\nif (!enumValue.HasValue)\n{\n    throw new ArgumentException(nameof(enumValue));\n}\n",
                "You just do like below:int intToCast = 1;\nTargetEnum f = (TargetEnum) intToCast ;\nint intToCast = 1;\nTargetEnum f = (TargetEnum) intToCast ;\nTo make sure that you only cast the right values \u200b\u200band that you can throw an exception otherwise:int intToCast = 1;\nif (Enum.IsDefined(typeof(TargetEnum), intToCast ))\n{\n    TargetEnum target = (TargetEnum)intToCast ;\n}\nelse\n{\n   // Throw your exception.\n}\nint intToCast = 1;\nif (Enum.IsDefined(typeof(TargetEnum), intToCast ))\n{\n    TargetEnum target = (TargetEnum)intToCast ;\n}\nelse\n{\n   // Throw your exception.\n}\nNote that using IsDefined is costly and even more than just casting, so it depends on your implementation to decide to use it or not.",
                "You can use an extension method.public static class Extensions\n{\n\n    public static T ToEnum<T>(this string data) where T : struct\n    {\n        if (!Enum.TryParse(data, true, out T enumVariable))\n        {\n            if (Enum.IsDefined(typeof(T), enumVariable))\n            {\n                return enumVariable;\n            }\n        }\n\n        return default;\n    }\n\n    public static T ToEnum<T>(this int data) where T : struct\n    {\n        return (T)Enum.ToObject(typeof(T), data);\n    }\n}\npublic static class Extensions\n{\n\n    public static T ToEnum<T>(this string data) where T : struct\n    {\n        if (!Enum.TryParse(data, true, out T enumVariable))\n        {\n            if (Enum.IsDefined(typeof(T), enumVariable))\n            {\n                return enumVariable;\n            }\n        }\n\n        return default;\n    }\n\n    public static T ToEnum<T>(this int data) where T : struct\n    {\n        return (T)Enum.ToObject(typeof(T), data);\n    }\n}\nUse it like the below code:Enum:Enum:public enum DaysOfWeeks\n{\n    Monday = 1,\n    Tuesday = 2,\n    Wednesday = 3,\n    Thursday = 4,\n    Friday = 5,\n    Saturday = 6,\n    Sunday = 7,\n}\npublic enum DaysOfWeeks\n{\n    Monday = 1,\n    Tuesday = 2,\n    Wednesday = 3,\n    Thursday = 4,\n    Friday = 5,\n    Saturday = 6,\n    Sunday = 7,\n}\nUsage:Usage: string Monday = \"Mon\";\n int Wednesday = 3;\n var Mon = Monday.ToEnum<DaysOfWeeks>();\n var Wed = Wednesday.ToEnum<DaysOfWeeks>();\n string Monday = \"Mon\";\n int Wednesday = 3;\n var Mon = Monday.ToEnum<DaysOfWeeks>();\n var Wed = Wednesday.ToEnum<DaysOfWeeks>();\n"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "How do I convert a String to an int in Java?",
                "how can you convert a string into an integer?",
                "how do i convert a string to int in java?",
                "how can i convert a string to an int in java?",
                "how do i convert a string to an int in java?"
            ],
            "responses": [
                "String myString = \"1234\";\nint foo = Integer.parseInt(myString);\nString myString = \"1234\";\nint foo = Integer.parseInt(myString);\nIf you look at the Java documentation you'll notice the \"catch\" is that this function can throw a NumberFormatException, which you can handle:Java documentationNumberFormatExceptionint foo;\ntry {\n   foo = Integer.parseInt(myString);\n}\ncatch (NumberFormatException e) {\n   foo = 0;\n}\nint foo;\ntry {\n   foo = Integer.parseInt(myString);\n}\ncatch (NumberFormatException e) {\n   foo = 0;\n}\n(This treatment defaults a malformed number to 0, but you can do something else if you like.)0Alternatively, you can use an Ints method from the Guava library, which in combination with Java 8's Optional, makes for a powerful and concise way to convert a string into an int:IntsOptionalimport com.google.common.primitives.Ints;\n\nint foo = Optional.ofNullable(myString)\n .map(Ints::tryParse)\n .orElse(0)\nimport com.google.common.primitives.Ints;\n\nint foo = Optional.ofNullable(myString)\n .map(Ints::tryParse)\n .orElse(0)\n",
                "For example, here are two ways:Integer x = Integer.valueOf(str);\n// or\nint y = Integer.parseInt(str);\nInteger x = Integer.valueOf(str);\n// or\nint y = Integer.parseInt(str);\nThere is a slight difference between these methods: \nvalueOf returns a new or cached instance of java.lang.Integer\nparseInt returns primitive int. \nvalueOf returns a new or cached instance of java.lang.IntegervalueOfjava.lang.IntegerparseInt returns primitive int. parseIntintThe same is for all cases: Short.valueOf/parseShort, Long.valueOf/parseLong, etc.Short.valueOfparseShortLong.valueOfparseLong",
                "Well, a very important point to consider is that the Integer parser throws NumberFormatException as stated in Javadoc. Javadocint foo;\nString StringThatCouldBeANumberOrNot = \"26263Hello\"; //will throw exception\nString StringThatCouldBeANumberOrNot2 = \"26263\"; //will not throw exception\ntry {\n      foo = Integer.parseInt(StringThatCouldBeANumberOrNot);\n} catch (NumberFormatException e) {\n      //Will Throw exception!\n      //do something! anything to handle the exception.\n}\n\ntry {\n      foo = Integer.parseInt(StringThatCouldBeANumberOrNot2);\n} catch (NumberFormatException e) {\n      //No problem this time, but still it is good practice to care about exceptions.\n      //Never trust user input :)\n      //Do something! Anything to handle the exception.\n}\nint foo;\nString StringThatCouldBeANumberOrNot = \"26263Hello\"; //will throw exception\nString StringThatCouldBeANumberOrNot2 = \"26263\"; //will not throw exception\ntry {\n      foo = Integer.parseInt(StringThatCouldBeANumberOrNot);\n} catch (NumberFormatException e) {\n      //Will Throw exception!\n      //do something! anything to handle the exception.\n}\n\ntry {\n      foo = Integer.parseInt(StringThatCouldBeANumberOrNot2);\n} catch (NumberFormatException e) {\n      //No problem this time, but still it is good practice to care about exceptions.\n      //Never trust user input :)\n      //Do something! Anything to handle the exception.\n}\nIt is important to handle this exception when trying to get integer values from split arguments or dynamically parsing something.",
                "Do it manually:public static int strToInt(String str){\n    int i = 0;\n    int num = 0;\n    boolean isNeg = false;\n\n    // Check for negative sign; if it's there, set the isNeg flag\n    if (str.charAt(0) == '-') {\n        isNeg = true;\n        i = 1;\n    }\n\n    // Process each character of the string;\n    while( i < str.length()) {\n        num *= 10;\n        num += str.charAt(i++) - '0'; // Minus the ASCII code of '0' to get the value of the charAt(i++).\n    }\n\n    if (isNeg)\n        num = -num;\n    return num;\n}\npublic static int strToInt(String str){\n    int i = 0;\n    int num = 0;\n    boolean isNeg = false;\n\n    // Check for negative sign; if it's there, set the isNeg flag\n    if (str.charAt(0) == '-') {\n        isNeg = true;\n        i = 1;\n    }\n\n    // Process each character of the string;\n    while( i < str.length()) {\n        num *= 10;\n        num += str.charAt(i++) - '0'; // Minus the ASCII code of '0' to get the value of the charAt(i++).\n    }\n\n    if (isNeg)\n        num = -num;\n    return num;\n}\n",
                "An alternate solution is to use Apache Commons' NumberUtils:Apache Commons'int num = NumberUtils.toInt(\"1234\");\nint num = NumberUtils.toInt(\"1234\");\nThe Apache utility is nice because if the string is an invalid number format then 0 is always returned. Hence saving you the try catch block.Apache NumberUtils API Version 3.4Apache NumberUtils API Version 3.4",
                "Integer.decodeInteger.decodeInteger.decodeYou can also use public static Integer decode(String nm) throws NumberFormatException.public static Integer decode(String nm) throws NumberFormatExceptionIt also works for base 8 and 16:// base 10\nInteger.parseInt(\"12\");     // 12 - int\nInteger.valueOf(\"12\");      // 12 - Integer\nInteger.decode(\"12\");       // 12 - Integer\n// base 8\n// 10 (0,1,...,7,10,11,12)\nInteger.parseInt(\"12\", 8);  // 10 - int\nInteger.valueOf(\"12\", 8);   // 10 - Integer\nInteger.decode(\"012\");      // 10 - Integer\n// base 16\n// 18 (0,1,...,F,10,11,12)\nInteger.parseInt(\"12\",16);  // 18 - int\nInteger.valueOf(\"12\",16);   // 18 - Integer\nInteger.decode(\"#12\");      // 18 - Integer\nInteger.decode(\"0x12\");     // 18 - Integer\nInteger.decode(\"0X12\");     // 18 - Integer\n// base 2\nInteger.parseInt(\"11\",2);   // 3 - int\nInteger.valueOf(\"11\",2);    // 3 - Integer\n// base 10\nInteger.parseInt(\"12\");     // 12 - int\nInteger.valueOf(\"12\");      // 12 - Integer\nInteger.decode(\"12\");       // 12 - Integer\n// base 8\n// 10 (0,1,...,7,10,11,12)\nInteger.parseInt(\"12\", 8);  // 10 - int\nInteger.valueOf(\"12\", 8);   // 10 - Integer\nInteger.decode(\"012\");      // 10 - Integer\n// base 16\n// 18 (0,1,...,F,10,11,12)\nInteger.parseInt(\"12\",16);  // 18 - int\nInteger.valueOf(\"12\",16);   // 18 - Integer\nInteger.decode(\"#12\");      // 18 - Integer\nInteger.decode(\"0x12\");     // 18 - Integer\nInteger.decode(\"0X12\");     // 18 - Integer\n// base 2\nInteger.parseInt(\"11\",2);   // 3 - int\nInteger.valueOf(\"11\",2);    // 3 - Integer\nIf you want to get int instead of Integer you can use:intInteger\nUnboxing:\nint val = Integer.decode(\"12\"); \n\nintValue():\nInteger.decode(\"12\").intValue();\n\nUnboxing:\nint val = Integer.decode(\"12\"); \nUnboxing:int val = Integer.decode(\"12\"); \nint val = Integer.decode(\"12\"); \nintValue():\nInteger.decode(\"12\").intValue();\nintValue():intValue()Integer.decode(\"12\").intValue();\nInteger.decode(\"12\").intValue();\n",
                "Currently I'm doing an assignment for college, where I can't use certain expressions, such as the ones above, and by looking at the ASCII table, I managed to do it. It's a far more complex code, but it could help others that are restricted like I was.The first thing to do is to receive the input, in this case, a string of digits; I'll call it String number, and in this case, I'll exemplify it using the number 12, therefore String number = \"12\";String numberString number = \"12\";Another limitation was the fact that I couldn't use repetitive cycles, therefore, a for cycle (which would have been perfect) can't be used either. This limits us a bit, but then again, that's the goal. Since I only needed two digits (taking the last two digits), a simple charAtsolved it:forcharAt // Obtaining the integer values of the char 1 and 2 in ASCII\n int semilastdigitASCII = number.charAt(number.length() - 2);\n int lastdigitASCII = number.charAt(number.length() - 1);\n // Obtaining the integer values of the char 1 and 2 in ASCII\n int semilastdigitASCII = number.charAt(number.length() - 2);\n int lastdigitASCII = number.charAt(number.length() - 1);\nHaving the codes, we just need to look up at the table, and make the necessary adjustments: double semilastdigit = semilastdigitASCII - 48;  // A quick look, and -48 is the key\n double lastdigit = lastdigitASCII - 48;\n double semilastdigit = semilastdigitASCII - 48;  // A quick look, and -48 is the key\n double lastdigit = lastdigitASCII - 48;\nNow, why double? Well, because of a really \"weird\" step. Currently we have two doubles, 1 and 2, but we need to turn it into 12, there isn't any mathematic operation that we can do.We're dividing the latter (lastdigit) by 10 in the fashion 2/10 = 0.2 (hence why double) like this:2/10 = 0.2 lastdigit = lastdigit / 10;\n lastdigit = lastdigit / 10;\nThis is merely playing with numbers. We were turning the last digit into a decimal. But now, look at what happens: double jointdigits = semilastdigit + lastdigit; // 1.0 + 0.2 = 1.2\n double jointdigits = semilastdigit + lastdigit; // 1.0 + 0.2 = 1.2\nWithout getting too into the math, we're simply isolating units the digits of a number. You see, since we only consider 0-9, dividing by a multiple of 10 is like creating a \"box\" where you store it (think back at when your first grade teacher explained you what a unit and a hundred were). So: int finalnumber = (int) (jointdigits*10); // Be sure to use parentheses \"()\"\n int finalnumber = (int) (jointdigits*10); // Be sure to use parentheses \"()\"\nAnd there you go. You turned a String of digits (in this case, two digits), into an integer composed of those two digits, considering the following limitations:\nNo repetitive cycles\nNo \"Magic\" Expressions such as parseInt\nNo repetitive cyclesNo \"Magic\" Expressions such as parseInt",
                "Methods to do that:\nInteger.parseInt(s)\nInteger.parseInt(s, radix)\nInteger.parseInt(s, beginIndex, endIndex, radix)\nInteger.parseUnsignedInt(s)\nInteger.parseUnsignedInt(s, radix)\nInteger.parseUnsignedInt(s, beginIndex, endIndex, radix)\nInteger.valueOf(s)\nInteger.valueOf(s, radix)\nInteger.decode(s)\nNumberUtils.toInt(s)\nNumberUtils.toInt(s, defaultValue)\nInteger.parseInt(s)Integer.parseInt(s)Integer.parseInt(s, radix)Integer.parseInt(s, radix)Integer.parseInt(s, beginIndex, endIndex, radix)Integer.parseInt(s, beginIndex, endIndex, radix)Integer.parseUnsignedInt(s)Integer.parseUnsignedInt(s)Integer.parseUnsignedInt(s, radix)Integer.parseUnsignedInt(s, radix)Integer.parseUnsignedInt(s, beginIndex, endIndex, radix)Integer.parseUnsignedInt(s, beginIndex, endIndex, radix)Integer.valueOf(s)Integer.valueOf(s)Integer.valueOf(s, radix)Integer.valueOf(s, radix)Integer.decode(s)Integer.decode(s)NumberUtils.toInt(s)NumberUtils.toInt(s)NumberUtils.toInt(s, defaultValue)NumberUtils.toInt(s, defaultValue)Integer.valueOf produces an Integer object and all other methods a primitive int.Integer.valueOfIntegerThe last two methods are from commons-lang3 and a big article about converting here.commons-lang3here",
                "Whenever there is the slightest possibility that the given String does not contain an Integer, you have to handle this special case. Sadly, the standard Java methods Integer::parseInt and Integer::valueOf throw a NumberFormatException to signal this special case. Thus, you have to use exceptions for flow control, which is generally considered bad coding style.Integer::parseIntInteger::valueOfNumberFormatExceptionIn my opinion, this special case should be handled by returning an empty Optional<Integer>. Since Java does not offer such a method, I use the following wrapper:Optional<Integer>private Optional<Integer> tryParseInteger(String string) {\n    try {\n        return Optional.of(Integer.valueOf(string));\n    } catch (NumberFormatException e) {\n        return Optional.empty();\n    }\n}\nprivate Optional<Integer> tryParseInteger(String string) {\n    try {\n        return Optional.of(Integer.valueOf(string));\n    } catch (NumberFormatException e) {\n        return Optional.empty();\n    }\n}\nExample usage:// prints \"12\"\nSystem.out.println(tryParseInteger(\"12\").map(i -> i.toString()).orElse(\"invalid\"));\n// prints \"-1\"\nSystem.out.println(tryParseInteger(\"-1\").map(i -> i.toString()).orElse(\"invalid\"));\n// prints \"invalid\"\nSystem.out.println(tryParseInteger(\"ab\").map(i -> i.toString()).orElse(\"invalid\"));\n// prints \"12\"\nSystem.out.println(tryParseInteger(\"12\").map(i -> i.toString()).orElse(\"invalid\"));\n// prints \"-1\"\nSystem.out.println(tryParseInteger(\"-1\").map(i -> i.toString()).orElse(\"invalid\"));\n// prints \"invalid\"\nSystem.out.println(tryParseInteger(\"ab\").map(i -> i.toString()).orElse(\"invalid\"));\nWhile this is still using exceptions for flow control internally, the usage code becomes very clean. Also, you can clearly distinguish the case where -1 is parsed as a valid value and the case where an invalid String could not be parsed.-1",
                "Use Integer.parseInt(yourString).Integer.parseInt(yourString)Integer.parseInt(yourString)Remember the following things:Remember the following things:Integer.parseInt(\"1\");      // okInteger.parseInt(\"1\");Integer.parseInt(\"-1\");     // okInteger.parseInt(\"-1\");Integer.parseInt(\"+1\");     // okInteger.parseInt(\"+1\");Integer.parseInt(\" 1\");     // Exception (blank space)Integer.parseInt(\" 1\");Integer.parseInt(\"2147483648\"); // Exception (Integer is limited to a maximum value of 2,147,483,647)Integer.parseInt(\"2147483648\");maximum valueInteger.parseInt(\"1.1\"); // Exception (. or , or whatever is not allowed)Integer.parseInt(\"1.1\");.,Integer.parseInt(\"\"); // Exception (not 0 or something)Integer.parseInt(\"\");There is only one type of exception: NumberFormatExceptionNumberFormatExceptionNumberFormatException",
                "Converting a string to an int is more complicated than just converting a number. You have think about the following issues:\nDoes the string only contain numbers 0-9?\nWhat's up with -/+ before or after the string? Is that possible (referring to accounting numbers)?\nWhat's up with MAX_-/MIN_INFINITY? What will happen if the string is 99999999999999999999? Can the machine treat this string as an int?\nDoes the string only contain numbers 0-9?0-9What's up with -/+ before or after the string? Is that possible (referring to accounting numbers)?-/+What's up with MAX_-/MIN_INFINITY? What will happen if the string is 99999999999999999999? Can the machine treat this string as an int?MAX_-/MIN_INFINITY?",
                "We can use the parseInt(String str) method of the Integer wrapper class for converting a String value to an integer value.parseInt(String str)IntegerFor example:String strValue = \"12345\";\nInteger intValue = Integer.parseInt(strVal);\nString strValue = \"12345\";\nInteger intValue = Integer.parseInt(strVal);\nThe Integer class also provides the valueOf(String str) method:IntegervalueOf(String str)String strValue = \"12345\";\nInteger intValue = Integer.valueOf(strValue);\nString strValue = \"12345\";\nInteger intValue = Integer.valueOf(strValue);\nWe can also use toInt(String strValue) of NumberUtils Utility Class for the conversion:toInt(String strValue)NumberUtils Utility ClassString strValue = \"12345\";\nInteger intValue = NumberUtils.toInt(strValue);\nString strValue = \"12345\";\nInteger intValue = NumberUtils.toInt(strValue);\n",
                "I'm have a solution, but I do not know how effective it is. But it works well, and I think you could improve it. On the other hand, I did a couple of tests with JUnit which step correctly. I attached the function and testing:JUnitstatic public Integer str2Int(String str) {\n    Integer result = null;\n    if (null == str || 0 == str.length()) {\n        return null;\n    }\n    try {\n        result = Integer.parseInt(str);\n    } \n    catch (NumberFormatException e) {\n        String negativeMode = \"\";\n        if(str.indexOf('-') != -1)\n            negativeMode = \"-\";\n        str = str.replaceAll(\"-\", \"\" );\n        if (str.indexOf('.') != -1) {\n            str = str.substring(0, str.indexOf('.'));\n            if (str.length() == 0) {\n                return (Integer)0;\n            }\n        }\n        String strNum = str.replaceAll(\"[^\\\\d]\", \"\" );\n        if (0 == strNum.length()) {\n            return null;\n        }\n        result = Integer.parseInt(negativeMode + strNum);\n    }\n    return result;\n}\nstatic public Integer str2Int(String str) {\n    Integer result = null;\n    if (null == str || 0 == str.length()) {\n        return null;\n    }\n    try {\n        result = Integer.parseInt(str);\n    } \n    catch (NumberFormatException e) {\n        String negativeMode = \"\";\n        if(str.indexOf('-') != -1)\n            negativeMode = \"-\";\n        str = str.replaceAll(\"-\", \"\" );\n        if (str.indexOf('.') != -1) {\n            str = str.substring(0, str.indexOf('.'));\n            if (str.length() == 0) {\n                return (Integer)0;\n            }\n        }\n        String strNum = str.replaceAll(\"[^\\\\d]\", \"\" );\n        if (0 == strNum.length()) {\n            return null;\n        }\n        result = Integer.parseInt(negativeMode + strNum);\n    }\n    return result;\n}\nTesting with JUnit:@Test\npublic void testStr2Int() {\n    assertEquals(\"is numeric\", (Integer)(-5), Helper.str2Int(\"-5\"));\n    assertEquals(\"is numeric\", (Integer)50, Helper.str2Int(\"50.00\"));\n    assertEquals(\"is numeric\", (Integer)20, Helper.str2Int(\"$ 20.90\"));\n    assertEquals(\"is numeric\", (Integer)5, Helper.str2Int(\" 5.321\"));\n    assertEquals(\"is numeric\", (Integer)1000, Helper.str2Int(\"1,000.50\"));\n    assertEquals(\"is numeric\", (Integer)0, Helper.str2Int(\"0.50\"));\n    assertEquals(\"is numeric\", (Integer)0, Helper.str2Int(\".50\"));\n    assertEquals(\"is numeric\", (Integer)0, Helper.str2Int(\"-.10\"));\n    assertEquals(\"is numeric\", (Integer)Integer.MAX_VALUE, Helper.str2Int(\"\"+Integer.MAX_VALUE));\n    assertEquals(\"is numeric\", (Integer)Integer.MIN_VALUE, Helper.str2Int(\"\"+Integer.MIN_VALUE));\n    assertEquals(\"Not\n     is numeric\", null, Helper.str2Int(\"czv.,xcvsa\"));\n    /**\n     * Dynamic test\n     */\n    for(Integer num = 0; num < 1000; num++) {\n        for(int spaces = 1; spaces < 6; spaces++) {\n            String numStr = String.format(\"%0\"+spaces+\"d\", num);\n            Integer numNeg = num * -1;\n            assertEquals(numStr + \": is numeric\", num, Helper.str2Int(numStr));\n            assertEquals(numNeg + \": is numeric\", numNeg, Helper.str2Int(\"- \" + numStr));\n        }\n    }\n}\n@Test\npublic void testStr2Int() {\n    assertEquals(\"is numeric\", (Integer)(-5), Helper.str2Int(\"-5\"));\n    assertEquals(\"is numeric\", (Integer)50, Helper.str2Int(\"50.00\"));\n    assertEquals(\"is numeric\", (Integer)20, Helper.str2Int(\"$ 20.90\"));\n    assertEquals(\"is numeric\", (Integer)5, Helper.str2Int(\" 5.321\"));\n    assertEquals(\"is numeric\", (Integer)1000, Helper.str2Int(\"1,000.50\"));\n    assertEquals(\"is numeric\", (Integer)0, Helper.str2Int(\"0.50\"));\n    assertEquals(\"is numeric\", (Integer)0, Helper.str2Int(\".50\"));\n    assertEquals(\"is numeric\", (Integer)0, Helper.str2Int(\"-.10\"));\n    assertEquals(\"is numeric\", (Integer)Integer.MAX_VALUE, Helper.str2Int(\"\"+Integer.MAX_VALUE));\n    assertEquals(\"is numeric\", (Integer)Integer.MIN_VALUE, Helper.str2Int(\"\"+Integer.MIN_VALUE));\n    assertEquals(\"Not\n     is numeric\", null, Helper.str2Int(\"czv.,xcvsa\"));\n    /**\n     * Dynamic test\n     */\n    for(Integer num = 0; num < 1000; num++) {\n        for(int spaces = 1; spaces < 6; spaces++) {\n            String numStr = String.format(\"%0\"+spaces+\"d\", num);\n            Integer numNeg = num * -1;\n            assertEquals(numStr + \": is numeric\", num, Helper.str2Int(numStr));\n            assertEquals(numNeg + \": is numeric\", numNeg, Helper.str2Int(\"- \" + numStr));\n        }\n    }\n}\n",
                "You can also begin by removing all non-numerical characters and then parsing the integer:String mystr = mystr.replaceAll(\"[^\\\\d]\", \"\");\nint number = Integer.parseInt(mystr);\nString mystr = mystr.replaceAll(\"[^\\\\d]\", \"\");\nint number = Integer.parseInt(mystr);\nBut be warned that this only works for non-negative numbers. ",
                "Google Guava has tryParse(String), which returns null if the string couldn't be parsed, for example:Google GuavatryParse(String)nullInteger fooInt = Ints.tryParse(fooString);\nif (fooInt != null) {\n  ...\n}\nInteger fooInt = Ints.tryParse(fooString);\nif (fooInt != null) {\n  ...\n}\n",
                "Apart from the previous answers, I would like to add several functions. These are results while you use them:public static void main(String[] args) {\n  System.out.println(parseIntOrDefault(\"123\", 0)); // 123\n  System.out.println(parseIntOrDefault(\"aaa\", 0)); // 0\n  System.out.println(parseIntOrDefault(\"aaa456\", 3, 0)); // 456\n  System.out.println(parseIntOrDefault(\"aaa789bbb\", 3, 6, 0)); // 789\n}\npublic static void main(String[] args) {\n  System.out.println(parseIntOrDefault(\"123\", 0)); // 123\n  System.out.println(parseIntOrDefault(\"aaa\", 0)); // 0\n  System.out.println(parseIntOrDefault(\"aaa456\", 3, 0)); // 456\n  System.out.println(parseIntOrDefault(\"aaa789bbb\", 3, 6, 0)); // 789\n}\nImplementation:public static int parseIntOrDefault(String value, int defaultValue) {\n  int result = defaultValue;\n  try {\n    result = Integer.parseInt(value);\n  }\n  catch (Exception e) {\n  }\n  return result;\n}\n\npublic static int parseIntOrDefault(String value, int beginIndex, int defaultValue) {\n  int result = defaultValue;\n  try {\n    String stringValue = value.substring(beginIndex);\n    result = Integer.parseInt(stringValue);\n  }\n  catch (Exception e) {\n  }\n  return result;\n}\n\npublic static int parseIntOrDefault(String value, int beginIndex, int endIndex, int defaultValue) {\n  int result = defaultValue;\n  try {\n    String stringValue = value.substring(beginIndex, endIndex);\n    result = Integer.parseInt(stringValue);\n  }\n  catch (Exception e) {\n  }\n  return result;\n}\npublic static int parseIntOrDefault(String value, int defaultValue) {\n  int result = defaultValue;\n  try {\n    result = Integer.parseInt(value);\n  }\n  catch (Exception e) {\n  }\n  return result;\n}\n\npublic static int parseIntOrDefault(String value, int beginIndex, int defaultValue) {\n  int result = defaultValue;\n  try {\n    String stringValue = value.substring(beginIndex);\n    result = Integer.parseInt(stringValue);\n  }\n  catch (Exception e) {\n  }\n  return result;\n}\n\npublic static int parseIntOrDefault(String value, int beginIndex, int endIndex, int defaultValue) {\n  int result = defaultValue;\n  try {\n    String stringValue = value.substring(beginIndex, endIndex);\n    result = Integer.parseInt(stringValue);\n  }\n  catch (Exception e) {\n  }\n  return result;\n}\n",
                "As mentioned, Apache Commons' NumberUtils can do it. It returns 0 if it cannot convert a string to an int.NumberUtils0You can also define your own default value:NumberUtils.toInt(String str, int defaultValue)\nNumberUtils.toInt(String str, int defaultValue)\nExample:NumberUtils.toInt(\"3244\", 1) = 3244\nNumberUtils.toInt(\"\", 1)     = 1\nNumberUtils.toInt(null, 5)   = 5\nNumberUtils.toInt(\"Hi\", 6)   = 6\nNumberUtils.toInt(\" 32 \", 1) = 1 // Space in numbers are not allowed\nNumberUtils.toInt(StringUtils.trimToEmpty(\"  32 \", 1)) = 32;\nNumberUtils.toInt(\"3244\", 1) = 3244\nNumberUtils.toInt(\"\", 1)     = 1\nNumberUtils.toInt(null, 5)   = 5\nNumberUtils.toInt(\"Hi\", 6)   = 6\nNumberUtils.toInt(\" 32 \", 1) = 1 // Space in numbers are not allowed\nNumberUtils.toInt(StringUtils.trimToEmpty(\"  32 \", 1)) = 32;\n",
                "You can use new Scanner(\"1244\").nextInt(). Or ask if even an int exists: new Scanner(\"1244\").hasNextInt()new Scanner(\"1244\").nextInt()new Scanner(\"1244\").hasNextInt()",
                "You can use this code also, with some precautions.\nOption #1: Handle the exception explicitly, for example, showing a message dialog and then stop the execution of the current workflow. For example:\ntry\n    {\n        String stringValue = \"1234\";\n\n        // From String to Integer\n        int integerValue = Integer.valueOf(stringValue);\n\n        // Or\n        int integerValue = Integer.ParseInt(stringValue);\n\n        // Now from integer to back into string\n        stringValue = String.valueOf(integerValue);\n    }\ncatch (NumberFormatException ex) {\n    //JOptionPane.showMessageDialog(frame, \"Invalid input string!\");\n    System.out.println(\"Invalid input string!\");\n    return;\n}\n\nOption #2: Reset the affected variable if the execution flow can continue in case of an exception. For example, with some modifications in the catch block\ncatch (NumberFormatException ex) {\n    integerValue = 0;\n}\n\nOption #1: Handle the exception explicitly, for example, showing a message dialog and then stop the execution of the current workflow. For example:\ntry\n    {\n        String stringValue = \"1234\";\n\n        // From String to Integer\n        int integerValue = Integer.valueOf(stringValue);\n\n        // Or\n        int integerValue = Integer.ParseInt(stringValue);\n\n        // Now from integer to back into string\n        stringValue = String.valueOf(integerValue);\n    }\ncatch (NumberFormatException ex) {\n    //JOptionPane.showMessageDialog(frame, \"Invalid input string!\");\n    System.out.println(\"Invalid input string!\");\n    return;\n}\nOption #1: Handle the exception explicitly, for example, showing a message dialog and then stop the execution of the current workflow. For example:try\n    {\n        String stringValue = \"1234\";\n\n        // From String to Integer\n        int integerValue = Integer.valueOf(stringValue);\n\n        // Or\n        int integerValue = Integer.ParseInt(stringValue);\n\n        // Now from integer to back into string\n        stringValue = String.valueOf(integerValue);\n    }\ncatch (NumberFormatException ex) {\n    //JOptionPane.showMessageDialog(frame, \"Invalid input string!\");\n    System.out.println(\"Invalid input string!\");\n    return;\n}\ntry\n    {\n        String stringValue = \"1234\";\n\n        // From String to Integer\n        int integerValue = Integer.valueOf(stringValue);\n\n        // Or\n        int integerValue = Integer.ParseInt(stringValue);\n\n        // Now from integer to back into string\n        stringValue = String.valueOf(integerValue);\n    }\ncatch (NumberFormatException ex) {\n    //JOptionPane.showMessageDialog(frame, \"Invalid input string!\");\n    System.out.println(\"Invalid input string!\");\n    return;\n}\nOption #2: Reset the affected variable if the execution flow can continue in case of an exception. For example, with some modifications in the catch block\ncatch (NumberFormatException ex) {\n    integerValue = 0;\n}\nOption #2: Reset the affected variable if the execution flow can continue in case of an exception. For example, with some modifications in the catch blockcatch (NumberFormatException ex) {\n    integerValue = 0;\n}\ncatch (NumberFormatException ex) {\n    integerValue = 0;\n}\nUsing a string constant for comparison or any sort of computing is always a good idea, because a constant never returns a null value.",
                "In programming competitions, where you're assured that number will always be a valid integer, then you can write your own method to parse input. This will skip all validation related code (since you don't need any of that) and will be a bit more efficient.\nFor valid positive integer:\nprivate static int parseInt(String str) {\n    int i, n = 0;\n\n    for (i = 0; i < str.length(); i++) {\n        n *= 10;\n        n += str.charAt(i) - 48;\n    }\n    return n;\n}\n\nFor both positive and negative integers:\nprivate static int parseInt(String str) {\n    int i=0, n=0, sign=1;\n    if (str.charAt(0) == '-') {\n        i = 1;\n        sign = -1;\n    }\n    for(; i<str.length(); i++) {\n        n* = 10;\n        n += str.charAt(i) - 48;\n    }\n    return sign*n;\n}\n\nIf you are expecting a whitespace before or after these numbers,\nthen make sure to do a str = str.trim() before processing further.\nFor valid positive integer:\nprivate static int parseInt(String str) {\n    int i, n = 0;\n\n    for (i = 0; i < str.length(); i++) {\n        n *= 10;\n        n += str.charAt(i) - 48;\n    }\n    return n;\n}\nFor valid positive integer:private static int parseInt(String str) {\n    int i, n = 0;\n\n    for (i = 0; i < str.length(); i++) {\n        n *= 10;\n        n += str.charAt(i) - 48;\n    }\n    return n;\n}\nprivate static int parseInt(String str) {\n    int i, n = 0;\n\n    for (i = 0; i < str.length(); i++) {\n        n *= 10;\n        n += str.charAt(i) - 48;\n    }\n    return n;\n}\nFor both positive and negative integers:\nprivate static int parseInt(String str) {\n    int i=0, n=0, sign=1;\n    if (str.charAt(0) == '-') {\n        i = 1;\n        sign = -1;\n    }\n    for(; i<str.length(); i++) {\n        n* = 10;\n        n += str.charAt(i) - 48;\n    }\n    return sign*n;\n}\nFor both positive and negative integers:private static int parseInt(String str) {\n    int i=0, n=0, sign=1;\n    if (str.charAt(0) == '-') {\n        i = 1;\n        sign = -1;\n    }\n    for(; i<str.length(); i++) {\n        n* = 10;\n        n += str.charAt(i) - 48;\n    }\n    return sign*n;\n}\nprivate static int parseInt(String str) {\n    int i=0, n=0, sign=1;\n    if (str.charAt(0) == '-') {\n        i = 1;\n        sign = -1;\n    }\n    for(; i<str.length(); i++) {\n        n* = 10;\n        n += str.charAt(i) - 48;\n    }\n    return sign*n;\n}\nIf you are expecting a whitespace before or after these numbers,\nthen make sure to do a str = str.trim() before processing further.If you are expecting a whitespace before or after these numbers,\nthen make sure to do a str = str.trim() before processing further.str = str.trim()",
                "For a normal string you can use:int number = Integer.parseInt(\"1234\");\nint number = Integer.parseInt(\"1234\");\nFor a String builder and String buffer you can use:Integer.parseInt(myBuilderOrBuffer.toString());\nInteger.parseInt(myBuilderOrBuffer.toString());\n",
                "Simply you can try this:\nUse Integer.parseInt(your_string); to convert a String to int\nUse Double.parseDouble(your_string); to convert a String to double\nUse Integer.parseInt(your_string); to convert a String to intInteger.parseInt(your_string);StringintUse Double.parseDouble(your_string); to convert a String to doubleDouble.parseDouble(your_string);StringdoubleExampleString str = \"8955\";\nint q = Integer.parseInt(str);\nSystem.out.println(\"Output>>> \" + q); // Output: 8955\nString str = \"8955\";\nint q = Integer.parseInt(str);\nSystem.out.println(\"Output>>> \" + q); // Output: 8955\nString str = \"89.55\";\ndouble q = Double.parseDouble(str);\nSystem.out.println(\"Output>>> \" + q); // Output: 89.55\nString str = \"89.55\";\ndouble q = Double.parseDouble(str);\nSystem.out.println(\"Output>>> \" + q); // Output: 89.55\n",
                "int foo = Integer.parseInt(\"1234\");\nint foo = Integer.parseInt(\"1234\");\nMake sure there is no non-numeric data in the string.",
                "Here we goString str = \"1234\";\nint number = Integer.parseInt(str);\nprint number; // 1234\nString str = \"1234\";\nint number = Integer.parseInt(str);\nprint number; // 1234\n",
                "I am a little bit surprised that nobody mentioned the Integer constructor that takes String as a parameter.So, here it is:String myString = \"1234\";\nint i1 = new Integer(myString);\nString myString = \"1234\";\nint i1 = new Integer(myString);\nJava 8 - Integer(String).Java 8 - Integer(String)Of course, the constructor will return type Integer, and an unboxing operation converts the value to int.IntegerintNote 1: It's important to mention: This constructor calls the parseInt method.Note 1: It's important to mentionparseIntpublic Integer(String var1) throws NumberFormatException {\n    this.value = parseInt(var1, 10);\n}\npublic Integer(String var1) throws NumberFormatException {\n    this.value = parseInt(var1, 10);\n}\nNote 2: It's deprecated: @Deprecated(since=\"9\") - JavaDoc.Note 2: It's deprecated@Deprecated(since=\"9\")JavaDoc",
                "Use Integer.parseInt() and put it inside a try...catch block to handle any errors just in case a non-numeric character is entered, for example,try...catchprivate void ConvertToInt(){\n    String string = txtString.getText();\n    try{\n        int integerValue=Integer.parseInt(string);\n        System.out.println(integerValue);\n    }\n    catch(Exception e){\n       JOptionPane.showMessageDialog(\n         \"Error converting string to integer\\n\" + e.toString,\n         \"Error\",\n         JOptionPane.ERROR_MESSAGE);\n    }\n }\nprivate void ConvertToInt(){\n    String string = txtString.getText();\n    try{\n        int integerValue=Integer.parseInt(string);\n        System.out.println(integerValue);\n    }\n    catch(Exception e){\n       JOptionPane.showMessageDialog(\n         \"Error converting string to integer\\n\" + e.toString,\n         \"Error\",\n         JOptionPane.ERROR_MESSAGE);\n    }\n }\n",
                "It can be done in seven ways:It can be done in seven ways:import com.google.common.primitives.Ints;\nimport org.apache.commons.lang.math.NumberUtils;\n\nString number = \"999\";\nimport com.google.common.primitives.Ints;\nimport org.apache.commons.lang.math.NumberUtils;\n\nString number = \"999\";\n\nInts.tryParse:\nint result = Ints.tryParse(number);\n\nNumberUtils.createInteger:\nInteger result = NumberUtils.createInteger(number);\n\nNumberUtils.toInt:\nint result = NumberUtils.toInt(number);\n\nInteger.valueOf:\nInteger result = Integer.valueOf(number);\n\nInteger.parseInt:\nint result = Integer.parseInt(number);\n\nInteger.decode:\nint result = Integer.decode(number);\n\nInteger.parseUnsignedInt:\nint result = Integer.parseUnsignedInt(number);\n\nInts.tryParse:\nint result = Ints.tryParse(number);\nInts.tryParse:Ints.tryParseint result = Ints.tryParse(number);NumberUtils.createInteger:\nInteger result = NumberUtils.createInteger(number);\nNumberUtils.createInteger:NumberUtils.createIntegerInteger result = NumberUtils.createInteger(number);NumberUtils.toInt:\nint result = NumberUtils.toInt(number);\nNumberUtils.toInt:NumberUtils.toIntint result = NumberUtils.toInt(number);Integer.valueOf:\nInteger result = Integer.valueOf(number);\nInteger.valueOf:Integer.valueOfInteger result = Integer.valueOf(number);Integer.parseInt:\nint result = Integer.parseInt(number);\nInteger.parseInt:Integer.parseIntint result = Integer.parseInt(number);Integer.decode:\nint result = Integer.decode(number);\nInteger.decode:Integer.decodeint result = Integer.decode(number);Integer.parseUnsignedInt:\nint result = Integer.parseUnsignedInt(number);\nInteger.parseUnsignedInt:Integer.parseUnsignedIntint result = Integer.parseUnsignedInt(number);",
                "This is a complete program with all conditions positive and negative without using a libraryThis is a complete program with all conditions positive and negative without using a librarycompleteimport java.util.Scanner;\n\n\npublic class StringToInt {\n\n    public static void main(String args[]) {\n        String inputString;\n        Scanner s = new Scanner(System.in);\n        inputString = s.nextLine();\n\n        if (!inputString.matches(\"([+-]?([0-9]*[.])?[0-9]+)\")) {\n            System.out.println(\"Not a Number\");\n        }\n        else {\n            Double result2 = getNumber(inputString);\n            System.out.println(\"result = \" + result2);\n        }\n    }\n\n\n    public static Double getNumber(String number) {\n        Double result = 0.0;\n        Double beforeDecimal = 0.0;\n        Double afterDecimal = 0.0;\n        Double afterDecimalCount = 0.0;\n        int signBit = 1;\n        boolean flag = false;\n\n        int count = number.length();\n        if (number.charAt(0) == '-') {\n            signBit = -1;\n            flag = true;\n        }\n        else if (number.charAt(0) == '+') {\n            flag = true;\n        }\n        for (int i = 0; i < count; i++) {\n            if (flag && i == 0) {\n                continue;\n            }\n            if (afterDecimalCount == 0.0) {\n                if (number.charAt(i) - '.' == 0) {\n                    afterDecimalCount++;\n                }\n                else {\n                    beforeDecimal = beforeDecimal * 10 + (number.charAt(i) - '0');\n                }\n            }\n            else {\n                afterDecimal = afterDecimal * 10 + number.charAt(i) - ('0');\n                afterDecimalCount = afterDecimalCount * 10;\n            }\n        }\n        if (afterDecimalCount != 0.0) {\n            afterDecimal = afterDecimal / afterDecimalCount;\n            result = beforeDecimal + afterDecimal;\n        }\n        else {\n            result = beforeDecimal;\n        }\n        return result * signBit;\n    }\n}\nimport java.util.Scanner;\n\n\npublic class StringToInt {\n\n    public static void main(String args[]) {\n        String inputString;\n        Scanner s = new Scanner(System.in);\n        inputString = s.nextLine();\n\n        if (!inputString.matches(\"([+-]?([0-9]*[.])?[0-9]+)\")) {\n            System.out.println(\"Not a Number\");\n        }\n        else {\n            Double result2 = getNumber(inputString);\n            System.out.println(\"result = \" + result2);\n        }\n    }\n\n\n    public static Double getNumber(String number) {\n        Double result = 0.0;\n        Double beforeDecimal = 0.0;\n        Double afterDecimal = 0.0;\n        Double afterDecimalCount = 0.0;\n        int signBit = 1;\n        boolean flag = false;\n\n        int count = number.length();\n        if (number.charAt(0) == '-') {\n            signBit = -1;\n            flag = true;\n        }\n        else if (number.charAt(0) == '+') {\n            flag = true;\n        }\n        for (int i = 0; i < count; i++) {\n            if (flag && i == 0) {\n                continue;\n            }\n            if (afterDecimalCount == 0.0) {\n                if (number.charAt(i) - '.' == 0) {\n                    afterDecimalCount++;\n                }\n                else {\n                    beforeDecimal = beforeDecimal * 10 + (number.charAt(i) - '0');\n                }\n            }\n            else {\n                afterDecimal = afterDecimal * 10 + number.charAt(i) - ('0');\n                afterDecimalCount = afterDecimalCount * 10;\n            }\n        }\n        if (afterDecimalCount != 0.0) {\n            afterDecimal = afterDecimal / afterDecimalCount;\n            result = beforeDecimal + afterDecimal;\n        }\n        else {\n            result = beforeDecimal;\n        }\n        return result * signBit;\n    }\n}\n",
                "One method is parseInt(String). It returns a primitive int:String number = \"10\";\nint result = Integer.parseInt(number);\nSystem.out.println(result);\nString number = \"10\";\nint result = Integer.parseInt(number);\nSystem.out.println(result);\nThe second method is valueOf(String), and it returns a new Integer() object:String number = \"10\";\nInteger result = Integer.valueOf(number);\nSystem.out.println(result);\nString number = \"10\";\nInteger result = Integer.valueOf(number);\nSystem.out.println(result);\n",
                "public static int parseInt(String s)throws NumberFormatExceptionpublic static int parseInt(String s)throws NumberFormatExceptionYou can use Integer.parseInt() to convert a String to an int.Integer.parseInt()Convert a String, \"20\", to a primitive int:String n = \"20\";\nint r = Integer.parseInt(n); // Returns a primitive int\nSystem.out.println(r);\nString n = \"20\";\nint r = Integer.parseInt(n); // Returns a primitive int\nSystem.out.println(r);\n\nOutput-20\nOutput-20If the string does not contain a parsable integer, it will throw NumberFormatException:NumberFormatExceptionString n = \"20I\"; // Throws NumberFormatException\nint r = Integer.parseInt(n);\nSystem.out.println(r);\nString n = \"20I\"; // Throws NumberFormatException\nint r = Integer.parseInt(n);\nSystem.out.println(r);\npublic static Integer valueOf(String s)throws NumberFormatExceptionpublic static Integer valueOf(String s)throws NumberFormatExceptionYou can use Integer.valueOf(). In this it will return an Integer object.Integer.valueOf()IntegerString n = \"20\";\nInteger r = Integer.valueOf(n); // Returns a new Integer() object.\nSystem.out.println(r);\nString n = \"20\";\nInteger r = Integer.valueOf(n); // Returns a new Integer() object.\nSystem.out.println(r);\n\nOutput-20\nOutput-20References\nhttps://docs.oracle.com/en/https://docs.oracle.com/en/"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "How do I parse a string to a float or int?",
                "how do i convert a string to a variable like float?",
                "tell me the best way to parse strings for a float or int format?",
                "how do i parse strings to float?",
                "how can i parse a string to float?",
                "how do i convert a string to a floating point?",
                "how do i parse a string for a float?",
                "how do i parse a string to an int?",
                "how do i parse a string to a float or int?"
            ],
            "responses": [
                ">>> a = \"545.2222\"\n>>> float(a)\n545.22220000000004\n>>> int(float(a))\n545\n>>> a = \"545.2222\"\n>>> float(a)\n545.22220000000004\n>>> int(float(a))\n545\n",
                "Python2 method to check if a string is a float:def is_float(value):\n  if value is None:\n      return False\n  try:\n      float(value)\n      return True\n  except:\n      return False\ndef is_float(value):\n  if value is None:\n      return False\n  try:\n      float(value)\n      return True\n  except:\n      return False\nFor the Python3 version of is_float see: Checking if a string can be converted to float in PythonChecking if a string can be converted to float in PythonA longer and more accurate name for this function could be: is_convertible_to_float(value)is_convertible_to_float(value)What is, and is not a float in Python may surprise you:PythonThe below unit tests were done using python2.  Check it that Python3 has different behavior for what strings are convertable to float.  One confounding difference is that any number of interior underscores are now allowed:  (float(\"1_3.4\") == float(13.4)) is True(float(\"1_3.4\") == float(13.4))val                   is_float(val) Note\n--------------------  ----------   --------------------------------\n\"\"                    False        Blank string\n\"127\"                 True         Passed string\nTrue                  True         Pure sweet Truth\n\"True\"                False        Vile contemptible lie\nFalse                 True         So false it becomes true\n\"123.456\"             True         Decimal\n\"      -127    \"      True         Spaces trimmed\n\"\\t\\n12\\r\\n\"          True         whitespace ignored\n\"NaN\"                 True         Not a number\n\"NaNanananaBATMAN\"    False        I am Batman\n\"-iNF\"                True         Negative infinity\n\"123.E4\"              True         Exponential notation\n\".1\"                  True         mantissa only\n\"1_2_3.4\"             False        Underscores not allowed\n\"12 34\"               False        Spaces not allowed on interior\n\"1,234\"               False        Commas gtfo\nu'\\x30'               True         Unicode is fine.\n\"NULL\"                False        Null is not special\n0x3fade               True         Hexadecimal\n\"6e7777777777777\"     True         Shrunk to infinity\n\"1.797693e+308\"       True         This is max value\n\"infinity\"            True         Same as inf\n\"infinityandBEYOND\"   False        Extra characters wreck it\n\"12.34.56\"            False        Only one dot allowed\nu'\u56db'                 False        Japanese '4' is not a float.\n\"#56\"                 False        Pound sign\n\"56%\"                 False        Percent of what?\n\"0E0\"                 True         Exponential, move dot 0 places\n0**0                  True         0___0  Exponentiation\n\"-5e-5\"               True         Raise to a negative number\n\"+1e1\"                True         Plus is OK with exponent\n\"+1e1^5\"              False        Fancy exponent not interpreted\n\"+1e1.3\"              False        No decimals in exponent\n\"-+1\"                 False        Make up your mind\n\"(1)\"                 False        Parenthesis is bad\nval                   is_float(val) Note\n--------------------  ----------   --------------------------------\n\"\"                    False        Blank string\n\"127\"                 True         Passed string\nTrue                  True         Pure sweet Truth\n\"True\"                False        Vile contemptible lie\nFalse                 True         So false it becomes true\n\"123.456\"             True         Decimal\n\"      -127    \"      True         Spaces trimmed\n\"\\t\\n12\\r\\n\"          True         whitespace ignored\n\"NaN\"                 True         Not a number\n\"NaNanananaBATMAN\"    False        I am Batman\n\"-iNF\"                True         Negative infinity\n\"123.E4\"              True         Exponential notation\n\".1\"                  True         mantissa only\n\"1_2_3.4\"             False        Underscores not allowed\n\"12 34\"               False        Spaces not allowed on interior\n\"1,234\"               False        Commas gtfo\nu'\\x30'               True         Unicode is fine.\n\"NULL\"                False        Null is not special\n0x3fade               True         Hexadecimal\n\"6e7777777777777\"     True         Shrunk to infinity\n\"1.797693e+308\"       True         This is max value\n\"infinity\"            True         Same as inf\n\"infinityandBEYOND\"   False        Extra characters wreck it\n\"12.34.56\"            False        Only one dot allowed\nu'\u56db'                 False        Japanese '4' is not a float.\n\"#56\"                 False        Pound sign\n\"56%\"                 False        Percent of what?\n\"0E0\"                 True         Exponential, move dot 0 places\n0**0                  True         0___0  Exponentiation\n\"-5e-5\"               True         Raise to a negative number\n\"+1e1\"                True         Plus is OK with exponent\n\"+1e1^5\"              False        Fancy exponent not interpreted\n\"+1e1.3\"              False        No decimals in exponent\n\"-+1\"                 False        Make up your mind\n\"(1)\"                 False        Parenthesis is bad\nYou think you know what numbers are? You are not so good as you think! Not big surprise.Don't use this code on life-critical software!Catching broad exceptions this way, killing canaries and gobbling the exception creates a tiny chance that a valid float as string will return false.  The float(...) line of code can failed for any of a thousand reasons that have nothing to do with the contents of the string.  But if you're writing life-critical software in a duck-typing prototype language like Python, then you've got much larger problems.float(...)",
                "def num(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\ndef num(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n",
                "This is another method which deserves to be mentioned here, ast.literal_eval:ast.literal_eval\nThis can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself.\nThis can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself.That is, a safe 'eval'>>> import ast\n>>> ast.literal_eval(\"545.2222\")\n545.2222\n>>> ast.literal_eval(\"31\")\n31\n>>> import ast\n>>> ast.literal_eval(\"545.2222\")\n545.2222\n>>> ast.literal_eval(\"31\")\n31\n",
                "Localization and commasYou should consider the possibility of commas in the string representation of a number, for cases like  float(\"545,545.2222\") which throws an exception. Instead, use methods in locale to convert the strings to numbers and interpret commas correctly. The locale.atof method converts to a float in one step once the locale has been set for the desired number convention.float(\"545,545.2222\")localelocale.atofExample 1 -- United States number conventions Example 1 -- United States number conventionsIn the United States and the UK, commas can be used as a thousands separator.  In this example with American locale, the comma is handled properly as a separator:>>> import locale\n>>> a = u'545,545.2222'\n>>> locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n'en_US.UTF-8'\n>>> locale.atof(a)\n545545.2222\n>>> int(locale.atof(a))\n545545\n>>>\n>>> import locale\n>>> a = u'545,545.2222'\n>>> locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n'en_US.UTF-8'\n>>> locale.atof(a)\n545545.2222\n>>> int(locale.atof(a))\n545545\n>>>\nExample 2 -- European number conventionsExample 2 -- European number conventionsIn the majority of countries of the world,  commas are used for decimal marks instead of periods.  In this example with French locale, the comma is correctly handled as a decimal mark:majority of countries of the world>>> import locale\n>>> b = u'545,2222'\n>>> locale.setlocale(locale.LC_ALL, 'fr_FR')\n'fr_FR'\n>>> locale.atof(b)\n545.2222\n>>> import locale\n>>> b = u'545,2222'\n>>> locale.setlocale(locale.LC_ALL, 'fr_FR')\n'fr_FR'\n>>> locale.atof(b)\n545.2222\nThe method locale.atoi is also available, but the argument should be an integer.locale.atoi",
                "float(x) if '.' in x else int(x)\nfloat(x) if '.' in x else int(x)\n",
                "If you aren't averse to third-party modules, you could check out the fastnumbers module. It provides a function called fast_real that does exactly what this question is asking for and does it faster than a pure-Python implementation:fastnumbersfast_real>>> from fastnumbers import fast_real\n>>> fast_real(\"545.2222\")\n545.2222\n>>> type(fast_real(\"545.2222\"))\nfloat\n>>> fast_real(\"31\")\n31\n>>> type(fast_real(\"31\"))\nint\n>>> from fastnumbers import fast_real\n>>> fast_real(\"545.2222\")\n545.2222\n>>> type(fast_real(\"545.2222\"))\nfloat\n>>> fast_real(\"31\")\n31\n>>> type(fast_real(\"31\"))\nint\n",
                "Users codelogic and harley are correct, but keep in mind if you know the string is an integer (for example, 545) you can call int(\"545\") without first casting to float.codelogicharleyIf your strings are in a list, you could use the map function as well. >>> x = [\"545.0\", \"545.6\", \"999.2\"]\n>>> map(float, x)\n[545.0, 545.60000000000002, 999.20000000000005]\n>>>\n>>> x = [\"545.0\", \"545.6\", \"999.2\"]\n>>> map(float, x)\n[545.0, 545.60000000000002, 999.20000000000005]\n>>>\nIt is only good if they're all the same type.",
                "\nIn Python, how can I parse a numeric string like \"545.2222\" to its corresponding float value, 542.2222? Or parse the string \"31\" to an integer, 31?\n  I just want to know how to parse a float string to a float, and (separately) an int string to an int.\nIn Python, how can I parse a numeric string like \"545.2222\" to its corresponding float value, 542.2222? Or parse the string \"31\" to an integer, 31?\n  I just want to know how to parse a float string to a float, and (separately) an int string to an int.In Python, how can I parse a numeric string like \"545.2222\" to its corresponding float value, 542.2222? Or parse the string \"31\" to an integer, 31?It's good that you ask to do these separately. If you're mixing them, you may be setting yourself up for problems later. The simple answer is:\"545.2222\" to float:\"545.2222\" to float:\"545.2222\">>> float(\"545.2222\")\n545.2222\n>>> float(\"545.2222\")\n545.2222\n\"31\" to an integer:\"31\" to an integer:\"31\">>> int(\"31\")\n31\n>>> int(\"31\")\n31\nOther conversions, ints to and from strings and literals:Conversions from various bases, and you should know the base in advance (10 is the default). Note you can prefix them with what Python expects for its literals (see below) or remove the prefix:>>> int(\"0b11111\", 2)\n31\n>>> int(\"11111\", 2)\n31\n>>> int('0o37', 8)\n31\n>>> int('37', 8)\n31\n>>> int('0x1f', 16)\n31\n>>> int('1f', 16)\n31\n>>> int(\"0b11111\", 2)\n31\n>>> int(\"11111\", 2)\n31\n>>> int('0o37', 8)\n31\n>>> int('37', 8)\n31\n>>> int('0x1f', 16)\n31\n>>> int('1f', 16)\n31\nIf you don't know the base in advance, but you do know they will have the correct prefix, Python can infer this for you if you pass 0 as the base:0>>> int(\"0b11111\", 0)\n31\n>>> int('0o37', 0)\n31\n>>> int('0x1f', 0)\n31\n>>> int(\"0b11111\", 0)\n31\n>>> int('0o37', 0)\n31\n>>> int('0x1f', 0)\n31\nNon-Decimal (i.e. Integer) Literals from other BasesIf your motivation is to have your own code clearly represent hard-coded specific values, however, you may not need to convert from the bases - you can let Python do it for you automatically with the correct syntax.You can use the apropos prefixes to get automatic conversion to integers with the following literals. These are valid for Python 2 and 3:the following literalsBinary, prefix 0b0b>>> 0b11111\n31\n>>> 0b11111\n31\nOctal, prefix 0o0o>>> 0o37\n31\n>>> 0o37\n31\nHexadecimal, prefix 0x0x>>> 0x1f\n31\n>>> 0x1f\n31\nThis can be useful when describing binary flags, file permissions in code, or hex values for colors - for example, note no quotes:>>> 0b10101 # binary flags\n21\n>>> 0o755 # read, write, execute perms for owner, read & ex for group & others\n493\n>>> 0xffffff # the color, white, max values for red, green, and blue\n16777215\n>>> 0b10101 # binary flags\n21\n>>> 0o755 # read, write, execute perms for owner, read & ex for group & others\n493\n>>> 0xffffff # the color, white, max values for red, green, and blue\n16777215\nMaking ambiguous Python 2 octals compatible with Python 3If you see an integer that starts with a 0, in Python 2, this is (deprecated) octal syntax.>>> 037\n31\n>>> 037\n31\nIt is bad because it looks like the value should be 37. So in Python 3, it now raises a SyntaxError:37SyntaxError>>> 037\n  File \"<stdin>\", line 1\n    037\n      ^\nSyntaxError: invalid token\n>>> 037\n  File \"<stdin>\", line 1\n    037\n      ^\nSyntaxError: invalid token\nConvert your Python 2 octals to octals that work in both 2 and 3 with the 0o prefix:0o>>> 0o37\n31\n>>> 0o37\n31\n",
                "The question seems a little bit old. But let me suggest a function, parseStr, which makes something similar, that is, returns integer or float and if a given ASCII string cannot be converted to none of them it returns it untouched. The code of course might be adjusted to do only what you want:   >>> import string\n   >>> parseStr = lambda x: x.isalpha() and x or x.isdigit() and \\\n   ...                      int(x) or x.isalnum() and x or \\\n   ...                      len(set(string.punctuation).intersection(x)) == 1 and \\\n   ...                      x.count('.') == 1 and float(x) or x\n   >>> parseStr('123')\n   123\n   >>> parseStr('123.3')\n   123.3\n   >>> parseStr('3HC1')\n   '3HC1'\n   >>> parseStr('12.e5')\n   1200000.0\n   >>> parseStr('12$5')\n   '12$5'\n   >>> parseStr('12.2.2')\n   '12.2.2'\n   >>> import string\n   >>> parseStr = lambda x: x.isalpha() and x or x.isdigit() and \\\n   ...                      int(x) or x.isalnum() and x or \\\n   ...                      len(set(string.punctuation).intersection(x)) == 1 and \\\n   ...                      x.count('.') == 1 and float(x) or x\n   >>> parseStr('123')\n   123\n   >>> parseStr('123.3')\n   123.3\n   >>> parseStr('3HC1')\n   '3HC1'\n   >>> parseStr('12.e5')\n   1200000.0\n   >>> parseStr('12$5')\n   '12$5'\n   >>> parseStr('12.2.2')\n   '12.2.2'\n",
                "float(\"545.2222\") and int(float(\"545.2222\"))float(\"545.2222\")int(float(\"545.2222\"))",
                "The YAML parser can help you figure out what datatype your string is. Use yaml.load(), and then you can use type(result) to test for type:YAMLyaml.load()type(result)>>> import yaml\n\n>>> a = \"545.2222\"\n>>> result = yaml.load(a)\n>>> result\n545.22220000000004\n>>> type(result)\n<type 'float'>\n\n>>> b = \"31\"\n>>> result = yaml.load(b)\n>>> result\n31\n>>> type(result)\n<type 'int'>\n\n>>> c = \"HI\"\n>>> result = yaml.load(c)\n>>> result\n'HI'\n>>> type(result)\n<type 'str'>\n>>> import yaml\n\n>>> a = \"545.2222\"\n>>> result = yaml.load(a)\n>>> result\n545.22220000000004\n>>> type(result)\n<type 'float'>\n\n>>> b = \"31\"\n>>> result = yaml.load(b)\n>>> result\n31\n>>> type(result)\n<type 'int'>\n\n>>> c = \"HI\"\n>>> result = yaml.load(c)\n>>> result\n'HI'\n>>> type(result)\n<type 'str'>\n",
                "I use this function for thatimport ast\n\ndef parse_str(s):\n   try:\n      return ast.literal_eval(str(s))\n   except:\n      return\nimport ast\n\ndef parse_str(s):\n   try:\n      return ast.literal_eval(str(s))\n   except:\n      return\nIt will convert the string to its typevalue = parse_str('1')  # Returns Integer\nvalue = parse_str('1.5')  # Returns Float\nvalue = parse_str('1')  # Returns Integer\nvalue = parse_str('1.5')  # Returns Float\n",
                "def get_int_or_float(v):\n    number_as_float = float(v)\n    number_as_int = int(number_as_float)\n    return number_as_int if number_as_float == number_as_int else number_as_float\ndef get_int_or_float(v):\n    number_as_float = float(v)\n    number_as_int = int(number_as_float)\n    return number_as_int if number_as_float == number_as_int else number_as_float\n",
                "def num(s):\n    \"\"\"num(s)\n    num(3),num(3.7)-->3\n    num('3')-->3, num('3.7')-->3.7\n    num('3,700')-->ValueError\n    num('3a'),num('a3'),-->ValueError\n    num('3e4') --> 30000.0\n    \"\"\"\n    try:\n        return int(s)\n    except ValueError:\n        try:\n            return float(s)\n        except ValueError:\n            raise ValueError('argument is not a string of number')\ndef num(s):\n    \"\"\"num(s)\n    num(3),num(3.7)-->3\n    num('3')-->3, num('3.7')-->3.7\n    num('3,700')-->ValueError\n    num('3a'),num('a3'),-->ValueError\n    num('3e4') --> 30000.0\n    \"\"\"\n    try:\n        return int(s)\n    except ValueError:\n        try:\n            return float(s)\n        except ValueError:\n            raise ValueError('argument is not a string of number')\n",
                "You could use json.loads:json.loads>>> import json\n>>> json.loads('123.456')\n123.456\n>>> type(_)\n<class 'float'>\n>>> \n>>> import json\n>>> json.loads('123.456')\n123.456\n>>> type(_)\n<class 'float'>\n>>> \nAs you can see it becomes a type of float.float",
                "You need to take into account rounding to do this properly.i.e. - int(5.1) => 5\nint(5.6) => 5  -- wrong, should be 6 so we do int(5.6 + 0.5) => 6int(5.1)int(5.6)int(5.6 + 0.5)def convert(n):\n    try:\n        return int(n)\n    except ValueError:\n        return float(n + 0.5)\ndef convert(n):\n    try:\n        return int(n)\n    except ValueError:\n        return float(n + 0.5)\n",
                "To typecast in Python use the constructor functions of the type, passing the string (or whatever value you are trying to cast) as a parameter.typecastFor example:>>>float(\"23.333\")\n   23.333\n>>>float(\"23.333\")\n   23.333\nBehind the scenes, Python is calling the objects __float__ method, which should return a float representation of the parameter. This is especially powerful, as you can define your own types (using classes) with a __float__ method so that it can be casted into a float using float(myobject).__float____float__float(myobject)",
                "Handles hex, octal, binary, decimal, and floatHandles hex, octal, binary, decimal, and floatThis solution will handle all of the string conventions for numbers (all that I know about).def to_number(n):\n    ''' Convert any number representation to a number\n    This covers: float, decimal, hex, and octal numbers.\n    '''\n\n    try:\n        return int(str(n), 0)\n    except:\n        try:\n            # Python 3 doesn't accept \"010\" as a valid octal.  You must use the\n            # '0o' prefix\n            return int('0o' + n, 0)\n        except:\n            return float(n)\ndef to_number(n):\n    ''' Convert any number representation to a number\n    This covers: float, decimal, hex, and octal numbers.\n    '''\n\n    try:\n        return int(str(n), 0)\n    except:\n        try:\n            # Python 3 doesn't accept \"010\" as a valid octal.  You must use the\n            # '0o' prefix\n            return int('0o' + n, 0)\n        except:\n            return float(n)\nThis test case output illustrates what I'm talking about.======================== CAPTURED OUTPUT =========================\nto_number(3735928559)   = 3735928559 == 3735928559\nto_number(\"0xFEEDFACE\") = 4277009102 == 4277009102\nto_number(\"0x0\")        =          0 ==          0\nto_number(100)          =        100 ==        100\nto_number(\"42\")         =         42 ==         42\nto_number(8)            =          8 ==          8\nto_number(\"0o20\")       =         16 ==         16\nto_number(\"020\")        =         16 ==         16\nto_number(3.14)         =       3.14 ==       3.14\nto_number(\"2.72\")       =       2.72 ==       2.72\nto_number(\"1e3\")        =     1000.0 ==       1000\nto_number(0.001)        =      0.001 ==      0.001\nto_number(\"0xA\")        =         10 ==         10\nto_number(\"012\")        =         10 ==         10\nto_number(\"0o12\")       =         10 ==         10\nto_number(\"0b01010\")    =         10 ==         10\nto_number(\"10\")         =         10 ==         10\nto_number(\"10.0\")       =       10.0 ==         10\nto_number(\"1e1\")        =       10.0 ==         10\n======================== CAPTURED OUTPUT =========================\nto_number(3735928559)   = 3735928559 == 3735928559\nto_number(\"0xFEEDFACE\") = 4277009102 == 4277009102\nto_number(\"0x0\")        =          0 ==          0\nto_number(100)          =        100 ==        100\nto_number(\"42\")         =         42 ==         42\nto_number(8)            =          8 ==          8\nto_number(\"0o20\")       =         16 ==         16\nto_number(\"020\")        =         16 ==         16\nto_number(3.14)         =       3.14 ==       3.14\nto_number(\"2.72\")       =       2.72 ==       2.72\nto_number(\"1e3\")        =     1000.0 ==       1000\nto_number(0.001)        =      0.001 ==      0.001\nto_number(\"0xA\")        =         10 ==         10\nto_number(\"012\")        =         10 ==         10\nto_number(\"0o12\")       =         10 ==         10\nto_number(\"0b01010\")    =         10 ==         10\nto_number(\"10\")         =         10 ==         10\nto_number(\"10.0\")       =       10.0 ==         10\nto_number(\"1e1\")        =       10.0 ==         10\nHere is the test:class test_to_number(unittest.TestCase):\n\n    def test_hex(self):\n        # All of the following should be converted to an integer\n        #\n        values = [\n\n                 #          HEX\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (0xDEADBEEF  , 3735928559), # Hex\n                (\"0xFEEDFACE\", 4277009102), # Hex\n                (\"0x0\"       ,          0), # Hex\n\n                 #        Decimals\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (100         ,        100), # Decimal\n                (\"42\"        ,         42), # Decimal\n            ]\n\n\n\n        values += [\n                 #        Octals\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (0o10        ,          8), # Octal\n                (\"0o20\"      ,         16), # Octal\n                (\"020\"       ,         16), # Octal\n            ]\n\n\n        values += [\n                 #        Floats\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (3.14        ,       3.14), # Float\n                (\"2.72\"      ,       2.72), # Float\n                (\"1e3\"       ,       1000), # Float\n                (1e-3        ,      0.001), # Float\n            ]\n\n        values += [\n                 #        All ints\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (\"0xA\"       ,         10),\n                (\"012\"       ,         10),\n                (\"0o12\"      ,         10),\n                (\"0b01010\"   ,         10),\n                (\"10\"        ,         10),\n                (\"10.0\"      ,         10),\n                (\"1e1\"       ,         10),\n            ]\n\n        for _input, expected in values:\n            value = to_number(_input)\n\n            if isinstance(_input, str):\n                cmd = 'to_number(\"{}\")'.format(_input)\n            else:\n                cmd = 'to_number({})'.format(_input)\n\n            print(\"{:23} = {:10} == {:10}\".format(cmd, value, expected))\n            self.assertEqual(value, expected)\nclass test_to_number(unittest.TestCase):\n\n    def test_hex(self):\n        # All of the following should be converted to an integer\n        #\n        values = [\n\n                 #          HEX\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (0xDEADBEEF  , 3735928559), # Hex\n                (\"0xFEEDFACE\", 4277009102), # Hex\n                (\"0x0\"       ,          0), # Hex\n\n                 #        Decimals\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (100         ,        100), # Decimal\n                (\"42\"        ,         42), # Decimal\n            ]\n\n\n\n        values += [\n                 #        Octals\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (0o10        ,          8), # Octal\n                (\"0o20\"      ,         16), # Octal\n                (\"020\"       ,         16), # Octal\n            ]\n\n\n        values += [\n                 #        Floats\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (3.14        ,       3.14), # Float\n                (\"2.72\"      ,       2.72), # Float\n                (\"1e3\"       ,       1000), # Float\n                (1e-3        ,      0.001), # Float\n            ]\n\n        values += [\n                 #        All ints\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (\"0xA\"       ,         10),\n                (\"012\"       ,         10),\n                (\"0o12\"      ,         10),\n                (\"0b01010\"   ,         10),\n                (\"10\"        ,         10),\n                (\"10.0\"      ,         10),\n                (\"1e1\"       ,         10),\n            ]\n\n        for _input, expected in values:\n            value = to_number(_input)\n\n            if isinstance(_input, str):\n                cmd = 'to_number(\"{}\")'.format(_input)\n            else:\n                cmd = 'to_number({})'.format(_input)\n\n            print(\"{:23} = {:10} == {:10}\".format(cmd, value, expected))\n            self.assertEqual(value, expected)\n",
                "Pass your string to this function:def string_to_number(str):\n  if(\".\" in str):\n    try:\n      res = float(str)\n    except:\n      res = str\n  elif(str.isdigit()):\n    res = int(str)\n  else:\n    res = str\n  return(res)\ndef string_to_number(str):\n  if(\".\" in str):\n    try:\n      res = float(str)\n    except:\n      res = str\n  elif(str.isdigit()):\n    res = int(str)\n  else:\n    res = str\n  return(res)\nIt will return int, float or string depending on what was passed.String that is an intprint(type(string_to_number(\"124\")))\n<class 'int'>\nprint(type(string_to_number(\"124\")))\n<class 'int'>\nString that is a floatprint(type(string_to_number(\"12.4\")))\n<class 'float'>\nprint(type(string_to_number(\"12.4\")))\n<class 'float'>\nString that is a stringprint(type(string_to_number(\"hello\")))\n<class 'str'>\nprint(type(string_to_number(\"hello\")))\n<class 'str'>\nString that looks like a floatprint(type(string_to_number(\"hel.lo\")))\n<class 'str'>\nprint(type(string_to_number(\"hel.lo\")))\n<class 'str'>\n",
                "There is also regex, because sometimes string must be prepared and normalized before casting to a number:import re\n\ndef parseNumber(value, as_int=False):\n    try:\n        number = float(re.sub('[^.\\-\\d]', '', value))\n        if as_int:\n            return int(number + 0.5)\n        else:\n            return number\n    except ValueError:\n        return float('nan')  # or None if you wish\nimport re\n\ndef parseNumber(value, as_int=False):\n    try:\n        number = float(re.sub('[^.\\-\\d]', '', value))\n        if as_int:\n            return int(number + 0.5)\n        else:\n            return number\n    except ValueError:\n        return float('nan')  # or None if you wish\nUsage:parseNumber('13,345')\n> 13345.0\n\nparseNumber('- 123 000')\n> -123000.0\n\nparseNumber('99999\\n')\n> 99999.0\nparseNumber('13,345')\n> 13345.0\n\nparseNumber('- 123 000')\n> -123000.0\n\nparseNumber('99999\\n')\n> 99999.0\nAnd by the way, something to verify you have a number:import numbers\ndef is_number(value):\n    return isinstance(value, numbers.Number)\n    # Will work with int, float, long, Decimal\nimport numbers\ndef is_number(value):\n    return isinstance(value, numbers.Number)\n    # Will work with int, float, long, Decimal\n",
                "a = int(float(a)) if int(float(a)) == float(a) else float(a)\na = int(float(a)) if int(float(a)) == float(a) else float(a)\n",
                "This is a corrected version of Totoro's answer.This is a corrected versionTotoro's answerThis will try to parse a string and return either int or float depending on what the string represents. It might rise parsing exceptions or have some unexpected behaviour.intfloathave some unexpected behaviour  def get_int_or_float(v):\n        number_as_float = float(v)\n        number_as_int = int(number_as_float)\n        return number_as_int if number_as_float == number_as_int else\n        number_as_float\n  def get_int_or_float(v):\n        number_as_float = float(v)\n        number_as_int = int(number_as_float)\n        return number_as_int if number_as_float == number_as_int else\n        number_as_float\n",
                "If you are dealing with mixed integers and floats and want a consistent way to deal with your mixed data, here is my solution with the proper docstring:docstringdef parse_num(candidate):\n    \"\"\"Parse string to number if possible\n    It work equally well with negative and positive numbers, integers and floats.\n\n    Args:\n        candidate (str): string to convert\n\n    Returns:\n        float | int | None: float or int if possible otherwise None\n    \"\"\"\n    try:\n        float_value = float(candidate)\n    except ValueError:\n        return None\n\n    # Optional part if you prefer int to float when decimal part is 0\n    if float_value.is_integer():\n        return int(float_value)\n    # end of the optional part\n\n    return float_value\n\n# Test\ncandidates = ['34.77', '-13', 'jh', '8990', '76_3234_54']\nres_list = list(map(parse_num, candidates))\nprint('Before:')\nprint(candidates)\nprint('After:')\nprint(res_list)\ndef parse_num(candidate):\n    \"\"\"Parse string to number if possible\n    It work equally well with negative and positive numbers, integers and floats.\n\n    Args:\n        candidate (str): string to convert\n\n    Returns:\n        float | int | None: float or int if possible otherwise None\n    \"\"\"\n    try:\n        float_value = float(candidate)\n    except ValueError:\n        return None\n\n    # Optional part if you prefer int to float when decimal part is 0\n    if float_value.is_integer():\n        return int(float_value)\n    # end of the optional part\n\n    return float_value\n\n# Test\ncandidates = ['34.77', '-13', 'jh', '8990', '76_3234_54']\nres_list = list(map(parse_num, candidates))\nprint('Before:')\nprint(candidates)\nprint('After:')\nprint(res_list)\nOutput:Before:\n['34.77', '-13', 'jh', '8990', '76_3234_54']\n\nAfter:\n[34.77, -13, None, 8990, 76323454]\nBefore:\n['34.77', '-13', 'jh', '8990', '76_3234_54']\n\nAfter:\n[34.77, -13, None, 8990, 76323454]\n",
                "Use:def num(s):\n    try:\n        for each in s:\n            yield int(each)\n    except ValueError:\n        yield float(each)\na = num([\"123.55\",\"345\",\"44\"])\nprint a.next()\nprint a.next()\ndef num(s):\n    try:\n        for each in s:\n            yield int(each)\n    except ValueError:\n        yield float(each)\na = num([\"123.55\",\"345\",\"44\"])\nprint a.next()\nprint a.next()\nThis is the most Pythonic way I could come up with. ",
                "You can simply do this bys = '542.22'\n\nf = float(s) # This converts string data to float data with a decimal point\nprint(f) \n\ni = int(f) # This converts string data to integer data by just taking the whole number part of it\nprint(i) \ns = '542.22'\n\nf = float(s) # This converts string data to float data with a decimal point\nprint(f) \n\ni = int(f) # This converts string data to integer data by just taking the whole number part of it\nprint(i) \nFor more information on parsing of data types check on python documentation!",
                "This is a function which will convert any object (not just str) to int or float, based on if the actual string supplied looks like int or float. Further if it's an object which has both __float and __int__ methods, it defaults to using __float__objectstrintfloatlooks likeintfloat__float__int____float__def conv_to_num(x, num_type='asis'):\n    '''Converts an object to a number if possible.\n    num_type: int, float, 'asis'\n    Defaults to floating point in case of ambiguity.\n    '''\n    import numbers\n\n    is_num, is_str, is_other = [False]*3\n\n    if isinstance(x, numbers.Number):\n        is_num = True\n    elif isinstance(x, str):\n        is_str = True\n\n    is_other = not any([is_num, is_str])\n\n    if is_num:\n        res = x\n    elif is_str:\n        is_float, is_int, is_char = [False]*3\n        try:\n            res = float(x)\n            if '.' in x:\n                is_float = True\n            else:\n                is_int = True\n        except ValueError:\n            res = x\n            is_char = True\n\n    else:\n        if num_type == 'asis':\n            funcs = [int, float]\n        else:\n            funcs = [num_type]\n\n        for func in funcs:\n            try:\n                res = func(x)\n                break\n            except TypeError:\n                continue\n        else:\n            res = x\ndef conv_to_num(x, num_type='asis'):\n    '''Converts an object to a number if possible.\n    num_type: int, float, 'asis'\n    Defaults to floating point in case of ambiguity.\n    '''\n    import numbers\n\n    is_num, is_str, is_other = [False]*3\n\n    if isinstance(x, numbers.Number):\n        is_num = True\n    elif isinstance(x, str):\n        is_str = True\n\n    is_other = not any([is_num, is_str])\n\n    if is_num:\n        res = x\n    elif is_str:\n        is_float, is_int, is_char = [False]*3\n        try:\n            res = float(x)\n            if '.' in x:\n                is_float = True\n            else:\n                is_int = True\n        except ValueError:\n            res = x\n            is_char = True\n\n    else:\n        if num_type == 'asis':\n            funcs = [int, float]\n        else:\n            funcs = [num_type]\n\n        for func in funcs:\n            try:\n                res = func(x)\n                break\n            except TypeError:\n                continue\n        else:\n            res = x\n",
                "By using int and float methods we can convert a string to integer and floats.s=\"45.8\"\nprint(float(s))\n\ny='67'\nprint(int(y))\ns=\"45.8\"\nprint(float(s))\n\ny='67'\nprint(int(y))\n",
                "For numbers and characters together:string_for_int = \"498 results should get\"\nstring_for_float = \"498.45645765 results should get\"\nstring_for_int = \"498 results should get\"\nstring_for_float = \"498.45645765 results should get\"\nFirst import re:re import re\n\n # For getting the integer part:\n print(int(re.search(r'\\d+', string_for_int).group())) #498\n\n # For getting the float part:\n print(float(re.search(r'\\d+\\.\\d+', string_for_float).group())) #498.45645765\n import re\n\n # For getting the integer part:\n print(int(re.search(r'\\d+', string_for_int).group())) #498\n\n # For getting the float part:\n print(float(re.search(r'\\d+\\.\\d+', string_for_float).group())) #498.45645765\nFor easy model:value1 = \"10\"\nvalue2 = \"10.2\"\nprint(int(value1)) # 10\nprint(float(value2)) # 10.2\nvalue1 = \"10\"\nvalue2 = \"10.2\"\nprint(int(value1)) # 10\nprint(float(value2)) # 10.2\n",
                "If you don't want to use third party modules the following might be the most robust solution:def string_to_int_or_float(s):\n    try:\n        f = float(s) # replace s with str(s) if you are not sure that s is a string\n    except ValueError:\n        print(\"Provided string '\" + s + \"' is not interpretable as a literal number.\")\n        raise\n    try:\n        i = int(str(f).rstrip('0').rstrip('.'))\n    except:\n        return f\n    return i\ndef string_to_int_or_float(s):\n    try:\n        f = float(s) # replace s with str(s) if you are not sure that s is a string\n    except ValueError:\n        print(\"Provided string '\" + s + \"' is not interpretable as a literal number.\")\n        raise\n    try:\n        i = int(str(f).rstrip('0').rstrip('.'))\n    except:\n        return f\n    return i\nIt might not be the fastest, but it handles correctly literal numbers where many other solutions fail, such as:>>> string_to_int_or_float('789.')\n789\n>>> string_to_int_or_float('789.0')\n789\n>>> string_to_int_or_float('12.3e2')\n1230\n>>> string_to_int_or_float('12.3e-2')\n0.123\n>>> string_to_int_or_float('4560e-1')\n456\n>>> string_to_int_or_float('4560e-2')\n45.6\n>>> string_to_int_or_float('789.')\n789\n>>> string_to_int_or_float('789.0')\n789\n>>> string_to_int_or_float('12.3e2')\n1230\n>>> string_to_int_or_float('12.3e-2')\n0.123\n>>> string_to_int_or_float('4560e-1')\n456\n>>> string_to_int_or_float('4560e-2')\n45.6\n"
            ]
        },
        {
            "tag": "javascript",
            "patterns": [
                "Generating random whole numbers in JavaScript in a specific range",
                "generation of random whole numbers in javascript in a specific range",
                "generate random whole numbers in javascript in a specific range",
                "generating random whole numbers in javascript in a specific range"
            ],
            "responses": [
                "There are some examples on the Mozilla Developer Network page:Mozilla Developer Network/**\n * Returns a random number between min (inclusive) and max (exclusive)\n */\nfunction getRandomArbitrary(min, max) {\n    return Math.random() * (max - min) + min;\n}\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive).\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * Returns a random number between min (inclusive) and max (exclusive)\n */\nfunction getRandomArbitrary(min, max) {\n    return Math.random() * (max - min) + min;\n}\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive).\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nHere's the logic behind it. It's a simple rule of three:Math.random() returns a Number between 0 (inclusive) and 1 (exclusive). So we have an interval like this:Math.random()Number[0 .................................... 1)\n[0 .................................... 1)\nNow, we'd like a number between min (inclusive) and max (exclusive):minmax[0 .................................... 1)\n[min .................................. max)\n[0 .................................... 1)\n[min .................................. max)\nWe can use the Math.random to get the correspondent in the [min, max) interval. But, first we should factor a little bit the problem by subtracting min from the second interval:Math.randommin[0 .................................... 1)\n[min - min ............................ max - min)\n[0 .................................... 1)\n[min - min ............................ max - min)\nThis gives:[0 .................................... 1)\n[0 .................................... max - min)\n[0 .................................... 1)\n[0 .................................... max - min)\nWe may now apply Math.random and then calculate the correspondent. Let's choose a random number:Math.random                Math.random()\n                    |\n[0 .................................... 1)\n[0 .................................... max - min)\n                    |\n                    x (what we need)\n                Math.random()\n                    |\n[0 .................................... 1)\n[0 .................................... max - min)\n                    |\n                    x (what we need)\nSo, in order to find x, we would do:xx = Math.random() * (max - min);\nx = Math.random() * (max - min);\nDon't forget to add min back, so that we get a number in the [min, max) interval:minx = Math.random() * (max - min) + min;\nx = Math.random() * (max - min) + min;\nThat was the first function from MDN. The second one, returns an integer between min and max, both inclusive.minmaxNow for getting integers, you could use round, ceil or floor.roundceilfloorYou could use Math.round(Math.random() * (max - min)) + min, this however gives a non-even distribution. Both, min and max only have approximately half the chance to roll:Math.round(Math.random() * (max - min)) + minminmaxmin...min+0.5...min+1...min+1.5   ...    max-0.5....max\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2518   \u2190 Math.round()\n   min          min+1                          max\nmin...min+0.5...min+1...min+1.5   ...    max-0.5....max\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2518   \u2190 Math.round()\n   min          min+1                          max\nWith max excluded from the interval, it has an even less chance to roll than min.maxminWith Math.floor(Math.random() * (max - min +1)) + min you have a perfectly even distribution.Math.floor(Math.random() * (max - min +1)) + min min...  min+1...    ...      max-1... max....   (max+1 is excluded from interval)\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500 ... \u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518   \u2190 Math.floor()\n   min     min+1               max-1    max\n min...  min+1...    ...      max-1... max....   (max+1 is excluded from interval)\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500 ... \u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518   \u2190 Math.floor()\n   min     min+1               max-1    max\nYou can't use ceil() and -1 in that equation because max now had a slightly less chance to roll, but you can roll the (unwanted) min-1 result too.ceil()-1maxmin-1",
                "var randomnumber = Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;\nvar randomnumber = Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;\n",
                "Math.random()Math.random()Returns an integer random number between min (included) and max (included):integer random numberincludedincludedfunction randomInteger(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nfunction randomInteger(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nOr any random number between min (included) and max (not included):any random numberincludednot includedfunction randomNumber(min, max) {\n  return Math.random() * (max - min) + min;\n}\nfunction randomNumber(min, max) {\n  return Math.random() * (max - min) + min;\n}\nUseful examples (integers):// 0 -> 10\nMath.floor(Math.random() * 11);\n\n// 1 -> 10\nMath.floor(Math.random() * 10) + 1;\n\n// 5 -> 20\nMath.floor(Math.random() * 16) + 5;\n\n// -10 -> (-2)\nMath.floor(Math.random() * 9) - 10;\n// 0 -> 10\nMath.floor(Math.random() * 11);\n\n// 1 -> 10\nMath.floor(Math.random() * 10) + 1;\n\n// 5 -> 20\nMath.floor(Math.random() * 16) + 5;\n\n// -10 -> (-2)\nMath.floor(Math.random() * 9) - 10;\n** And always nice to be reminded (Mozilla):\nMath.random() does not provide cryptographically secure random\nnumbers. Do not use them for anything related to security. Use the Web\nCrypto API instead, and more precisely the\nwindow.crypto.getRandomValues() method.\nMath.random() does not provide cryptographically secure random\nnumbers. Do not use them for anything related to security. Use the Web\nCrypto API instead, and more precisely the\nwindow.crypto.getRandomValues() method.",
                "Use:function getRandomizer(bottom, top) {\n    return function() {\n        return Math.floor( Math.random() * ( 1 + top - bottom ) ) + bottom;\n    }\n}\nfunction getRandomizer(bottom, top) {\n    return function() {\n        return Math.floor( Math.random() * ( 1 + top - bottom ) ) + bottom;\n    }\n}\nUsage:var rollDie = getRandomizer( 1, 6 );\n\nvar results = \"\"\nfor ( var i = 0; i<1000; i++ ) {\n    results += rollDie() + \" \";    // Make a string filled with 1000 random numbers in the range 1-6.\n}\nvar rollDie = getRandomizer( 1, 6 );\n\nvar results = \"\"\nfor ( var i = 0; i<1000; i++ ) {\n    results += rollDie() + \" \";    // Make a string filled with 1000 random numbers in the range 1-6.\n}\nBreakdown:We are returning a function (borrowing from functional programming) that when called, will return a random integer between the the values bottom and top, inclusive. We say 'inclusive' because we want to include both bottom and top in the range of numbers that can be returned. This way, getRandomizer( 1, 6 ) will return either 1, 2, 3, 4, 5, or 6.bottomtopgetRandomizer( 1, 6 )('bottom' is the lower number, and 'top' is the greater number)Math.random() * ( 1 + top - bottom )\nMath.random() * ( 1 + top - bottom )\nMath.random() returns a random double between 0 and 1, and if we multiply it by one plus the difference between top and bottom, we'll get a double somewhere between 0 and 1+b-a.Math.random()topbottom01+b-aMath.floor( Math.random() * ( 1 + top - bottom ) )\nMath.floor( Math.random() * ( 1 + top - bottom ) )\nMath.floor rounds the number down to the nearest integer. So we now have all the integers between 0 and top-bottom. The 1 looks confusing, but it needs to be there because we are always rounding down, so the top number will never actually be reached without it. The random decimal we generate needs to be in the range 0 to (1+top-bottom) so we can round down and get an integer in the range 0 to top-bottom:Math.floor0top-bottom0(1+top-bottom)0top-bottomMath.floor( Math.random() * ( 1 + top - bottom ) ) + bottom\nMath.floor( Math.random() * ( 1 + top - bottom ) ) + bottom\nThe code in the previous example gave us an integer in the range 0 and top-bottom, so all we need to do now is add bottom to that result to get an integer in the range bottom and top inclusive. :D0top-bottombottombottomtop\nNOTE: If you pass in a non-integer value or the greater number first you'll get undesirable behavior, but unless anyone requests it I am not going to delve into the argument checking code as it\u2019s rather far from the intent of the original question.\nNOTE: If you pass in a non-integer value or the greater number first you'll get undesirable behavior, but unless anyone requests it I am not going to delve into the argument checking code as it\u2019s rather far from the intent of the original question.",
                "All these solutions are using way too much firepower. You only need to call one function: Math.random();Math.random();Math.random() * max | 0;\nMath.random() * max | 0;\nThis returns a random integer between 0 (inclusive) and max (non-inclusive).",
                "Return a random number between 1 and 10:Math.floor((Math.random()*10) + 1); \nMath.floor((Math.random()*10) + 1); \nReturn a random number between 1 and 100:Math.floor((Math.random()*100) + 1)\nMath.floor((Math.random()*100) + 1)\n",
                "function randomRange(min, max) {\n  return ~~(Math.random() * (max - min + 1)) + min\n}\nfunction randomRange(min, max) {\n  return ~~(Math.random() * (max - min + 1)) + min\n}\nAlternative if you are using Underscore.js you can useUnderscore.jsUnderscore.js_.random(min, max)\n_.random(min, max)\n",
                "If you need a variable between 0 and max, you can use:Math.floor(Math.random() *  max);\nMath.floor(Math.random() *  max);\n",
                "The other answers don't account for the perfectly reasonable parameters of 0 and 1. Instead you should use the round instead of ceil or floor:01roundinsteadceilfloorfunction randomNumber(minimum, maximum){\n    return Math.round( Math.random() * (maximum - minimum) + minimum);\n}\n\nconsole.log(randomNumber(0,1));  # 0 1 1 0 1 0\nconsole.log(randomNumber(5,6));  # 5 6 6 5 5 6\nconsole.log(randomNumber(3,-1)); # 1 3 1 -1 -1 -1\nfunction randomNumber(minimum, maximum){\n    return Math.round( Math.random() * (maximum - minimum) + minimum);\n}\n\nconsole.log(randomNumber(0,1));  # 0 1 1 0 1 0\nconsole.log(randomNumber(5,6));  # 5 6 6 5 5 6\nconsole.log(randomNumber(3,-1)); # 1 3 1 -1 -1 -1\n",
                "Cryptographically strongTo get a cryptographically strong random integer number in the range [x,y], try:cryptographically strong\n\nlet cs = (x,y) => x + (y - x + 1)*crypto.getRandomValues(new Uint32Array(1))[0]/2**32 | 0\n\nconsole.log(cs(4, 8))\n\n\n\n\nlet cs = (x,y) => x + (y - x + 1)*crypto.getRandomValues(new Uint32Array(1))[0]/2**32 | 0\n\nconsole.log(cs(4, 8))\n\n\nlet cs = (x,y) => x + (y - x + 1)*crypto.getRandomValues(new Uint32Array(1))[0]/2**32 | 0\n\nconsole.log(cs(4, 8))\nlet cs = (x,y) => x + (y - x + 1)*crypto.getRandomValues(new Uint32Array(1))[0]/2**32 | 0\n\nconsole.log(cs(4, 8))let cs = (x,y) => x + (y - x + 1)*crypto.getRandomValues(new Uint32Array(1))[0]/2**32 | 0\n\nconsole.log(cs(4, 8))",
                "Use this function to get random numbers in a given range:function rnd(min, max) {\n    return Math.floor(Math.random()*(max - min + 1) + min);\n}\nfunction rnd(min, max) {\n    return Math.floor(Math.random()*(max - min + 1) + min);\n}\n",
                "Here's what I use to generate random numbers.function random(min,max) {\n    return Math.floor((Math.random())*(max-min+1))+min;\n}\nfunction random(min,max) {\n    return Math.floor((Math.random())*(max-min+1))+min;\n}\nMath.random() returns a number between 0 (inclusive) and 1 (exclusive). We multiply this number by the range (max-min). This results in a number between 0 (inclusive), and the range.Math.random()For example, take random(2,5). We multiply the random number 0\u2264x<1 by the range (5-2=3), so we now have a number, x where 0\u2264x<3.random(2,5)In order to force the function to treat both the max and min as inclusive, we add 1 to our range calculation: Math.random()*(max-min+1). Now, we multiply the random number by the (5-2+1=4), resulting in an number, x, such that 0\u2264x<4. If we floor this calculation, we get an integer: 0\u2264x\u22643, with an equal likelihood of each result (1/4).Math.random()*(max-min+1)Finally, we need to convert this into an integer between the requested values. Since we already have an integer between 0 and the (max-min), we can simply map the value into the correct range by adding the minimum value. In our example, we add 2 our integer between 0 and 3, resulting in an integer between 2 and 5.",
                "Here is the Microsoft .NET Implementation of the Random class in JavaScript\u2014Randomvar Random = (function () {\n    function Random(Seed) {\n        if (!Seed) {\n            Seed = this.milliseconds();\n        }\n        this.SeedArray = [];\n        for (var i = 0; i < 56; i++)\n            this.SeedArray.push(0);\n        var num = (Seed == -2147483648) ? 2147483647 : Math.abs(Seed);\n        var num2 = 161803398 - num;\n        this.SeedArray[55] = num2;\n        var num3 = 1;\n        for (var i_1 = 1; i_1 < 55; i_1++) {\n            var num4 = 21 * i_1 % 55;\n            this.SeedArray[num4] = num3;\n            num3 = num2 - num3;\n            if (num3 < 0) {\n                num3 += 2147483647;\n            }\n            num2 = this.SeedArray[num4];\n        }\n        for (var j = 1; j < 5; j++) {\n            for (var k = 1; k < 56; k++) {\n                this.SeedArray[k] -= this.SeedArray[1 + (k + 30) % 55];\n                if (this.SeedArray[k] < 0) {\n                    this.SeedArray[k] += 2147483647;\n                }\n            }\n        }\n        this.inext = 0;\n        this.inextp = 21;\n        Seed = 1;\n    }\n\n    Random.prototype.milliseconds = function () {\n        var str = new Date().valueOf().toString();\n        return parseInt(str.substr(str.length - 6));\n    };\n\n    Random.prototype.InternalSample = function () {\n        var num = this.inext;\n        var num2 = this.inextp;\n        if (++num >= 56) {\n            num = 1;\n        }\n        if (++num2 >= 56) {\n            num2 = 1;\n        }\n        var num3 = this.SeedArray[num] - this.SeedArray[num2];\n        if (num3 == 2147483647) {\n            num3--;\n        }\n        if (num3 < 0) {\n            num3 += 2147483647;\n        }\n        this.SeedArray[num] = num3;\n        this.inext = num;\n        this.inextp = num2;\n        return num3;\n    };\n\n    Random.prototype.Sample = function () {\n        return this.InternalSample() * 4.6566128752457969E-10;\n    };\n\n    Random.prototype.GetSampleForLargeRange = function () {\n        var num = this.InternalSample();\n        var flag = this.InternalSample() % 2 == 0;\n        if (flag) {\n            num = -num;\n        }\n        var num2 = num;\n        num2 += 2147483646.0;\n        return num2 / 4294967293.0;\n    };\n\n    Random.prototype.Next = function (minValue, maxValue) {\n        if (!minValue && !maxValue)\n            return this.InternalSample();\n        var num = maxValue - minValue;\n        if (num <= 2147483647) {\n            return parseInt((this.Sample() * num + minValue).toFixed(0));\n        }\n        return this.GetSampleForLargeRange() * num + minValue;\n    };\n\n    Random.prototype.NextDouble = function () {\n        return this.Sample();\n    };\n\n    Random.prototype.NextBytes = function (buffer) {\n        for (var i = 0; i < buffer.length; i++) {\n            buffer[i] = this.InternalSample() % 256;\n        }\n    };\n    return Random;\n}());\nvar Random = (function () {\n    function Random(Seed) {\n        if (!Seed) {\n            Seed = this.milliseconds();\n        }\n        this.SeedArray = [];\n        for (var i = 0; i < 56; i++)\n            this.SeedArray.push(0);\n        var num = (Seed == -2147483648) ? 2147483647 : Math.abs(Seed);\n        var num2 = 161803398 - num;\n        this.SeedArray[55] = num2;\n        var num3 = 1;\n        for (var i_1 = 1; i_1 < 55; i_1++) {\n            var num4 = 21 * i_1 % 55;\n            this.SeedArray[num4] = num3;\n            num3 = num2 - num3;\n            if (num3 < 0) {\n                num3 += 2147483647;\n            }\n            num2 = this.SeedArray[num4];\n        }\n        for (var j = 1; j < 5; j++) {\n            for (var k = 1; k < 56; k++) {\n                this.SeedArray[k] -= this.SeedArray[1 + (k + 30) % 55];\n                if (this.SeedArray[k] < 0) {\n                    this.SeedArray[k] += 2147483647;\n                }\n            }\n        }\n        this.inext = 0;\n        this.inextp = 21;\n        Seed = 1;\n    }\n\n    Random.prototype.milliseconds = function () {\n        var str = new Date().valueOf().toString();\n        return parseInt(str.substr(str.length - 6));\n    };\n\n    Random.prototype.InternalSample = function () {\n        var num = this.inext;\n        var num2 = this.inextp;\n        if (++num >= 56) {\n            num = 1;\n        }\n        if (++num2 >= 56) {\n            num2 = 1;\n        }\n        var num3 = this.SeedArray[num] - this.SeedArray[num2];\n        if (num3 == 2147483647) {\n            num3--;\n        }\n        if (num3 < 0) {\n            num3 += 2147483647;\n        }\n        this.SeedArray[num] = num3;\n        this.inext = num;\n        this.inextp = num2;\n        return num3;\n    };\n\n    Random.prototype.Sample = function () {\n        return this.InternalSample() * 4.6566128752457969E-10;\n    };\n\n    Random.prototype.GetSampleForLargeRange = function () {\n        var num = this.InternalSample();\n        var flag = this.InternalSample() % 2 == 0;\n        if (flag) {\n            num = -num;\n        }\n        var num2 = num;\n        num2 += 2147483646.0;\n        return num2 / 4294967293.0;\n    };\n\n    Random.prototype.Next = function (minValue, maxValue) {\n        if (!minValue && !maxValue)\n            return this.InternalSample();\n        var num = maxValue - minValue;\n        if (num <= 2147483647) {\n            return parseInt((this.Sample() * num + minValue).toFixed(0));\n        }\n        return this.GetSampleForLargeRange() * num + minValue;\n    };\n\n    Random.prototype.NextDouble = function () {\n        return this.Sample();\n    };\n\n    Random.prototype.NextBytes = function (buffer) {\n        for (var i = 0; i < buffer.length; i++) {\n            buffer[i] = this.InternalSample() % 256;\n        }\n    };\n    return Random;\n}());\nUse:Use:var r = new Random();\nvar nextInt = r.Next(1, 100); // Returns an integer between range\nvar nextDbl = r.NextDouble(); // Returns a random decimal\nvar r = new Random();\nvar nextInt = r.Next(1, 100); // Returns an integer between range\nvar nextDbl = r.NextDouble(); // Returns a random decimal\n",
                "I wanted to explain using an example:Function to generate random whole numbers in JavaScript within a range of 5 to 25Function to generate random whole numbers in JavaScript within a range of 5 to 25\nGeneral Overview:\n(i) First convert it to the range - starting from 0.\n(ii) Then convert it to your desired range ( which then will be very\neasy to complete).\nGeneral Overview:(i) First convert it to the range - starting from 0.(ii) Then convert it to your desired range ( which then will be very\neasy to complete).So basically, if you want to generate random whole numbers from 5 to 25 then:First step: Converting it to range - starting from 0Subtract \"lower/minimum number\" from both \"max\" and \"min\". i.e(5-5) - (25-5)So the range will be:0-20  ...right?Step twoNow if you want both numbers inclusive in range - i.e \"both 0 and 20\", the equation will be:Mathematical equation: Math.floor((Math.random() * 21))Math.floor((Math.random() * 21))General equation: Math.floor((Math.random() * (max-min +1)))Math.floor((Math.random() * (max-min +1)))Now if we add subtracted/minimum number (i.e., 5) to the range - then automatically we can get range from 0 to 20 => 5 to 25Step threeNow add the difference you subtracted in equation (i.e., 5) and add \"Math.floor\" to the whole equation:Mathematical equation: Math.floor((Math.random() * 21) + 5)Math.floor((Math.random() * 21) + 5)General equation: Math.floor((Math.random() * (max-min +1)) + min)Math.floor((Math.random() * (max-min +1)) + min)So finally the function will be:So finally the function will be:function randomRange(min, max) {\n   return Math.floor((Math.random() * (max - min + 1)) + min);\n}\nfunction randomRange(min, max) {\n   return Math.floor((Math.random() * (max - min + 1)) + min);\n}\n",
                "After generating a random number using a computer program, it is still considered as a random number if the picked number is a part or the full one of the initial one. But if it was changed, then mathematicians do not accept it as a random number and they can call it a biased number.mathematiciansBut if you are developing a program for a simple task, this will not be a case to consider. But if you are developing a program to generate a random number for a valuable stuff such as lottery program, or gambling game, then your program will be rejected by the management if you are not consider about the above case.rejectedSo for those kind of people, here is my suggestion:Generate a random number using Math.random() (say this n):Math.random()nNow for [0,10) ==>  n*10 (i.e. one digit) and for[10,100) ==> n*100 (i.e., two digits) and so on. Here square bracket indicates that the boundary is inclusive and a round bracket indicates the boundary is exclusive.\nNow for [0,10) ==>  n*10 (i.e. one digit) and for[10,100) ==> n*100 (i.e., two digits) and so on. Here square bracket indicates that the boundary is inclusive and a round bracket indicates the boundary is exclusive.\nThen remove the rest after the decimal point. (i.e., get the floor) - using Math.floor(). This can be done.If you know how to read the random number table to pick a random number, you know the above process (multiplying by 1, 10, 100 and so on) does not violate the one that I was mentioned at the beginning (because it changes only the place of the decimal point).Study the following example and develop it to your needs.If you need a sample [0,9] then the floor of n10 is your answer and if you need [0,99] then the floor of n100 is your answer and so on.10 is your answer and if you need [0,99] then the floor of nNow let\u2019s enter into your role:You've asked for numbers in a specific range. (In this case you are biased among that range. By taking a number from [1,6] by roll a die, then you are biased into [1,6], but still it is a random number if and only if the die is unbiased.)So consider your range ==> [78, 247]\nnumber of elements of the range = 247 - 78 + 1 = 170; (since both the boundaries are inclusive)./* Method 1: */\n    var i = 78, j = 247, k = 170, a = [], b = [], c, d, e, f, l = 0;\n    for(; i <= j; i++){ a.push(i); }\n    while(l < 170){\n        c = Math.random()*100; c = Math.floor(c);\n        d = Math.random()*100; d = Math.floor(d);\n        b.push(a[c]); e = c + d;\n        if((b.length != k) && (e < k)){  b.push(a[e]); }\n        l = b.length;\n    }\n    console.log('Method 1:');\n    console.log(b);\n\n/* Method 2: */\n\n    var a, b, c, d = [], l = 0;\n    while(l < 170){\n        a = Math.random()*100; a = Math.floor(a);\n        b = Math.random()*100; b = Math.floor(b);\n        c = a + b;\n        if(c <= 247 || c >= 78){ d.push(c); }else{ d.push(a); }\n        l = d.length;\n    }\n    console.log('Method 2:');\n    console.log(d);\n/* Method 1: */\n    var i = 78, j = 247, k = 170, a = [], b = [], c, d, e, f, l = 0;\n    for(; i <= j; i++){ a.push(i); }\n    while(l < 170){\n        c = Math.random()*100; c = Math.floor(c);\n        d = Math.random()*100; d = Math.floor(d);\n        b.push(a[c]); e = c + d;\n        if((b.length != k) && (e < k)){  b.push(a[e]); }\n        l = b.length;\n    }\n    console.log('Method 1:');\n    console.log(b);\n\n/* Method 2: */\n\n    var a, b, c, d = [], l = 0;\n    while(l < 170){\n        a = Math.random()*100; a = Math.floor(a);\n        b = Math.random()*100; b = Math.floor(b);\n        c = a + b;\n        if(c <= 247 || c >= 78){ d.push(c); }else{ d.push(a); }\n        l = d.length;\n    }\n    console.log('Method 2:');\n    console.log(d);\nNote: In method one, first I created an array which contains numbers that you need and then randomly put them into another array.In method two, generate numbers randomly and check those are in the range that you need. Then put it into an array. Here I generated two random numbers and used the total of them to maximize the speed of the program by minimizing the failure rate that obtaining a useful number. However, adding generated numbers will also give some biasedness. So I would recommend my first method to generate random numbers within a specific range.In both methods, your console will show the result (press F12 in Chrome to open the console).F12Chrome",
                "function getRandomInt(lower, upper)\n{\n    //to create an even sample distribution\n    return Math.floor(lower + (Math.random() * (upper - lower + 1)));\n\n    //to produce an uneven sample distribution\n    //return Math.round(lower + (Math.random() * (upper - lower)));\n\n    //to exclude the max value from the possible values\n    //return Math.floor(lower + (Math.random() * (upper - lower)));\n}\nfunction getRandomInt(lower, upper)\n{\n    //to create an even sample distribution\n    return Math.floor(lower + (Math.random() * (upper - lower + 1)));\n\n    //to produce an uneven sample distribution\n    //return Math.round(lower + (Math.random() * (upper - lower)));\n\n    //to exclude the max value from the possible values\n    //return Math.floor(lower + (Math.random() * (upper - lower)));\n}\nTo test this function, and variations of this function, save the below HTML/JavaScript to a file and open with a browser.  The code will produce a graph showing the distribution of one million function calls.  The code will also record the edge cases, so if the the function produces a value greater than the max, or less than the min, you.will.know.about.it.graph<html>\n    <head>\n        <script type=\"text/javascript\">\n        function getRandomInt(lower, upper)\n        {\n            //to create an even sample distribution\n            return Math.floor(lower + (Math.random() * (upper - lower + 1)));\n\n            //to produce an uneven sample distribution\n            //return Math.round(lower + (Math.random() * (upper - lower)));\n\n            //to exclude the max value from the possible values\n            //return Math.floor(lower + (Math.random() * (upper - lower)));\n        }\n\n        var min = -5;\n        var max = 5;\n\n        var array = new Array();\n\n        for(var i = 0; i <= (max - min) + 2; i++) {\n          array.push(0);\n        }\n\n        for(var i = 0; i < 1000000; i++) {\n            var random = getRandomInt(min, max);\n            array[random - min + 1]++;\n        }\n\n        var maxSample = 0;\n        for(var i = 0; i < max - min; i++) {\n            maxSample = Math.max(maxSample, array[i]);\n        }\n\n        //create a bar graph to show the sample distribution\n        var maxHeight = 500;\n        for(var i = 0; i <= (max - min) + 2; i++) {\n            var sampleHeight = (array[i]/maxSample) * maxHeight;\n\n            document.write('<span style=\"display:inline-block;color:'+(sampleHeight == 0 ? 'black' : 'white')+';background-color:black;height:'+sampleHeight+'px\">&nbsp;[' + (i + min - 1) + ']:&nbsp;'+array[i]+'</span>&nbsp;&nbsp;');\n        }\n        document.write('<hr/>');\n        </script>\n    </head>\n    <body>\n\n    </body>\n</html>\n<html>\n    <head>\n        <script type=\"text/javascript\">\n        function getRandomInt(lower, upper)\n        {\n            //to create an even sample distribution\n            return Math.floor(lower + (Math.random() * (upper - lower + 1)));\n\n            //to produce an uneven sample distribution\n            //return Math.round(lower + (Math.random() * (upper - lower)));\n\n            //to exclude the max value from the possible values\n            //return Math.floor(lower + (Math.random() * (upper - lower)));\n        }\n\n        var min = -5;\n        var max = 5;\n\n        var array = new Array();\n\n        for(var i = 0; i <= (max - min) + 2; i++) {\n          array.push(0);\n        }\n\n        for(var i = 0; i < 1000000; i++) {\n            var random = getRandomInt(min, max);\n            array[random - min + 1]++;\n        }\n\n        var maxSample = 0;\n        for(var i = 0; i < max - min; i++) {\n            maxSample = Math.max(maxSample, array[i]);\n        }\n\n        //create a bar graph to show the sample distribution\n        var maxHeight = 500;\n        for(var i = 0; i <= (max - min) + 2; i++) {\n            var sampleHeight = (array[i]/maxSample) * maxHeight;\n\n            document.write('<span style=\"display:inline-block;color:'+(sampleHeight == 0 ? 'black' : 'white')+';background-color:black;height:'+sampleHeight+'px\">&nbsp;[' + (i + min - 1) + ']:&nbsp;'+array[i]+'</span>&nbsp;&nbsp;');\n        }\n        document.write('<hr/>');\n        </script>\n    </head>\n    <body>\n\n    </body>\n</html>\n",
                "For a random integer with a range, try:function random(minimum, maximum) {\n  var bool = true;\n\n  while (bool) {\n    var number = (Math.floor(Math.random() * maximum + 1) + minimum);\n    if (number > 20) {\n      bool = true;\n    } else {\n      bool = false;\n    }\n  }\n\n  return number;\n}\nfunction random(minimum, maximum) {\n  var bool = true;\n\n  while (bool) {\n    var number = (Math.floor(Math.random() * maximum + 1) + minimum);\n    if (number > 20) {\n      bool = true;\n    } else {\n      bool = false;\n    }\n  }\n\n  return number;\n}\n",
                "Here is a function that generates a random number between min and max, both inclusive.const randomInt = (max, min) => Math.round(Math.random() * (max - min)) + min;\nconst randomInt = (max, min) => Math.round(Math.random() * (max - min)) + min;\n",
                "To get a random number say between 1 and 6, first do:0.5 + (Math.random() * ((6 - 1) + 1))\n0.5 + (Math.random() * ((6 - 1) + 1))\nThis multiplies a random number by 6 and then adds 0.5 to it. Next round the number to a positive integer by doing:Math.round(0.5 + (Math.random() * ((6 - 1) + 1))\nMath.round(0.5 + (Math.random() * ((6 - 1) + 1))\nThis round the number to the nearest whole number.Or to make it more understandable do this:var value = 0.5 + (Math.random() * ((6 - 1) + 1))\nvar roll = Math.round(value);\nreturn roll;\nvar value = 0.5 + (Math.random() * ((6 - 1) + 1))\nvar roll = Math.round(value);\nreturn roll;\nIn general, the code for doing this using variables is:var value = (Min - 0.5) + (Math.random() * ((Max - Min) + 1))\nvar roll = Math.round(value);\nreturn roll;\nvar value = (Min - 0.5) + (Math.random() * ((Max - Min) + 1))\nvar roll = Math.round(value);\nreturn roll;\nThe reason for taking away 0.5 from the minimum value is because using the minimum value alone would allow you to get an integer that was one more than your maximum value. By taking away 0.5 from the minimum value you are essentially preventing the maximum value from being rounded up.",
                "Using the following code, you can generate an array of random numbers, without repeating, in a given range.function genRandomNumber(how_many_numbers, min, max) {\n\n    // Parameters\n    //\n    //   how_many_numbers: How many numbers you want to\n    //                     generate. For example, it is 5.\n    //\n    //   min (inclusive):  Minimum/low value of a range. It\n    //                     must be any positive integer, but\n    //                     less than max. I.e., 4.\n    //\n    //   max (inclusive):  Maximum value of a range. it must\n    //                     be any positive integer. I.e., 50\n    //\n    //   Return type: array\n\n    var random_number = [];\n    for (var i = 0; i < how_many_numbers; i++) {\n        var gen_num = parseInt((Math.random() * (max-min+1)) + min);\n        do {\n            var is_exist = random_number.indexOf(gen_num);\n            if (is_exist >= 0) {\n                gen_num = parseInt((Math.random() * (max-min+1)) + min);\n            }\n            else {\n                random_number.push(gen_num);\n                is_exist = -2;\n            }\n        }\n        while (is_exist > -1);\n    }\n    document.getElementById('box').innerHTML = random_number;\n}\nfunction genRandomNumber(how_many_numbers, min, max) {\n\n    // Parameters\n    //\n    //   how_many_numbers: How many numbers you want to\n    //                     generate. For example, it is 5.\n    //\n    //   min (inclusive):  Minimum/low value of a range. It\n    //                     must be any positive integer, but\n    //                     less than max. I.e., 4.\n    //\n    //   max (inclusive):  Maximum value of a range. it must\n    //                     be any positive integer. I.e., 50\n    //\n    //   Return type: array\n\n    var random_number = [];\n    for (var i = 0; i < how_many_numbers; i++) {\n        var gen_num = parseInt((Math.random() * (max-min+1)) + min);\n        do {\n            var is_exist = random_number.indexOf(gen_num);\n            if (is_exist >= 0) {\n                gen_num = parseInt((Math.random() * (max-min+1)) + min);\n            }\n            else {\n                random_number.push(gen_num);\n                is_exist = -2;\n            }\n        }\n        while (is_exist > -1);\n    }\n    document.getElementById('box').innerHTML = random_number;\n}\n",
                "Random whole number between lowest and highest:function randomRange(low, high) {\n  var range = (high-low);\n  var random = Math.floor(Math.random()*range);\n  if (random === 0) {\n    random += 1;\n  }\n  return low + random;\n}\nfunction randomRange(low, high) {\n  var range = (high-low);\n  var random = Math.floor(Math.random()*range);\n  if (random === 0) {\n    random += 1;\n  }\n  return low + random;\n}\nIt is not the most elegant solution, but something quick.",
                "I found this simple method on W3Schools:W3SchoolsMath.floor((Math.random() * max) + min);\nMath.floor((Math.random() * max) + min);\n",
                "Math.random() is fast and suitable for many purposes, but it's not appropriate if you need cryptographically-secure values (it's not secure), or if you need integers from a completely uniform unbiased distribution (the multiplication approach used in others answers produces certain values slightly more often than others).Math.random()In such cases, we can use crypto.getRandomValues() to generate secure integers, and reject any generated values that we can't map uniformly into the target range. This will be slower, but it shouldn't be significant unless you're generating extremely large numbers of values.crypto.getRandomValues()To clarify the biased distribution concern, consider the case where we want to generate a value between 1 and 5, but we have a random number generator that produces values between 1 and 16 (a 4-bit value). We want to have the same number of generated values mapping to each output value, but 16 does not evenly divide by 5: it leaves a remainder of 1. So we need to reject 1 of the possible generated values, and only continue when we get one of the 15 lesser values that can be uniformly mapped into our target range. Our behaviour could look like this pseudocode:Generate a 4-bit integer in the range 1-16.\nIf we generated  1,  6, or 11 then output 1.\nIf we generated  2,  7, or 12 then output 2.\nIf we generated  3,  8, or 13 then output 3.\nIf we generated  4,  9, or 14 then output 4.\nIf we generated  5, 10, or 15 then output 5.\nIf we generated 16 then reject it and try again.\nGenerate a 4-bit integer in the range 1-16.\nIf we generated  1,  6, or 11 then output 1.\nIf we generated  2,  7, or 12 then output 2.\nIf we generated  3,  8, or 13 then output 3.\nIf we generated  4,  9, or 14 then output 4.\nIf we generated  5, 10, or 15 then output 5.\nIf we generated 16 then reject it and try again.\nThe following code uses similar logic, but generates a 32-bit integer instead, because that's the largest common integer size that can be represented by JavaScript's standard number type. (This could be modified to use BigInts if you need a larger range.) Regardless of the chosen range, the fraction of generated values that are rejected will always be less than 0.5, so the expected number of rejections will always be less than 1.0 and usually close to 0.0; you don't need to worry about it looping forever.numberBigInt\n\nconst randomInteger = (min, max) => {\r\n  const range = max - min;\r\n  const maxGeneratedValue = 0xFFFFFFFF;\r\n  const possibleResultValues = range + 1;\r\n  const possibleGeneratedValues = maxGeneratedValue + 1;\r\n  const remainder = possibleGeneratedValues % possibleResultValues;\r\n  const maxUnbiased = maxGeneratedValue - remainder;\r\n\r\n  if (!Number.isInteger(min) || !Number.isInteger(max) ||\r\n       max > Number.MAX_SAFE_INTEGER || min < Number.MIN_SAFE_INTEGER) {\r\n    throw new Error('Arguments must be safe integers.');\r\n  } else if (range > maxGeneratedValue) {\r\n    throw new Error(`Range of ${range} (from ${min} to ${max}) > ${maxGeneratedValue}.`);\r\n  } else if (max < min) {\r\n    throw new Error(`max (${max}) must be >= min (${min}).`);\r\n  } else if (min === max) {\r\n    return min;\r\n  } \r\n\r\n  let generated;\r\n  do {\r\n    generated = crypto.getRandomValues(new Uint32Array(1))[0];\r\n  } while (generated > maxUnbiased);\r\n\r\n  return min + (generated % possibleResultValues);\r\n};\r\n\r\nconsole.log(randomInteger(-8, 8));          // -2\r\nconsole.log(randomInteger(0, 0));           // 0\r\nconsole.log(randomInteger(0, 0xFFFFFFFF));  // 944450079\r\nconsole.log(randomInteger(-1, 0xFFFFFFFF));\r\n// Error: Range of 4294967296 covering -1 to 4294967295 is > 4294967295.\r\nconsole.log(new Array(12).fill().map(n => randomInteger(8, 12)));\r\n// [11, 8, 8, 11, 10, 8, 8, 12, 12, 12, 9, 9]\n\n\n\n\nconst randomInteger = (min, max) => {\r\n  const range = max - min;\r\n  const maxGeneratedValue = 0xFFFFFFFF;\r\n  const possibleResultValues = range + 1;\r\n  const possibleGeneratedValues = maxGeneratedValue + 1;\r\n  const remainder = possibleGeneratedValues % possibleResultValues;\r\n  const maxUnbiased = maxGeneratedValue - remainder;\r\n\r\n  if (!Number.isInteger(min) || !Number.isInteger(max) ||\r\n       max > Number.MAX_SAFE_INTEGER || min < Number.MIN_SAFE_INTEGER) {\r\n    throw new Error('Arguments must be safe integers.');\r\n  } else if (range > maxGeneratedValue) {\r\n    throw new Error(`Range of ${range} (from ${min} to ${max}) > ${maxGeneratedValue}.`);\r\n  } else if (max < min) {\r\n    throw new Error(`max (${max}) must be >= min (${min}).`);\r\n  } else if (min === max) {\r\n    return min;\r\n  } \r\n\r\n  let generated;\r\n  do {\r\n    generated = crypto.getRandomValues(new Uint32Array(1))[0];\r\n  } while (generated > maxUnbiased);\r\n\r\n  return min + (generated % possibleResultValues);\r\n};\r\n\r\nconsole.log(randomInteger(-8, 8));          // -2\r\nconsole.log(randomInteger(0, 0));           // 0\r\nconsole.log(randomInteger(0, 0xFFFFFFFF));  // 944450079\r\nconsole.log(randomInteger(-1, 0xFFFFFFFF));\r\n// Error: Range of 4294967296 covering -1 to 4294967295 is > 4294967295.\r\nconsole.log(new Array(12).fill().map(n => randomInteger(8, 12)));\r\n// [11, 8, 8, 11, 10, 8, 8, 12, 12, 12, 9, 9]\n\n\nconst randomInteger = (min, max) => {\r\n  const range = max - min;\r\n  const maxGeneratedValue = 0xFFFFFFFF;\r\n  const possibleResultValues = range + 1;\r\n  const possibleGeneratedValues = maxGeneratedValue + 1;\r\n  const remainder = possibleGeneratedValues % possibleResultValues;\r\n  const maxUnbiased = maxGeneratedValue - remainder;\r\n\r\n  if (!Number.isInteger(min) || !Number.isInteger(max) ||\r\n       max > Number.MAX_SAFE_INTEGER || min < Number.MIN_SAFE_INTEGER) {\r\n    throw new Error('Arguments must be safe integers.');\r\n  } else if (range > maxGeneratedValue) {\r\n    throw new Error(`Range of ${range} (from ${min} to ${max}) > ${maxGeneratedValue}.`);\r\n  } else if (max < min) {\r\n    throw new Error(`max (${max}) must be >= min (${min}).`);\r\n  } else if (min === max) {\r\n    return min;\r\n  } \r\n\r\n  let generated;\r\n  do {\r\n    generated = crypto.getRandomValues(new Uint32Array(1))[0];\r\n  } while (generated > maxUnbiased);\r\n\r\n  return min + (generated % possibleResultValues);\r\n};\r\n\r\nconsole.log(randomInteger(-8, 8));          // -2\r\nconsole.log(randomInteger(0, 0));           // 0\r\nconsole.log(randomInteger(0, 0xFFFFFFFF));  // 944450079\r\nconsole.log(randomInteger(-1, 0xFFFFFFFF));\r\n// Error: Range of 4294967296 covering -1 to 4294967295 is > 4294967295.\r\nconsole.log(new Array(12).fill().map(n => randomInteger(8, 12)));\r\n// [11, 8, 8, 11, 10, 8, 8, 12, 12, 12, 9, 9]\nconst randomInteger = (min, max) => {\r\n  const range = max - min;\r\n  const maxGeneratedValue = 0xFFFFFFFF;\r\n  const possibleResultValues = range + 1;\r\n  const possibleGeneratedValues = maxGeneratedValue + 1;\r\n  const remainder = possibleGeneratedValues % possibleResultValues;\r\n  const maxUnbiased = maxGeneratedValue - remainder;\r\n\r\n  if (!Number.isInteger(min) || !Number.isInteger(max) ||\r\n       max > Number.MAX_SAFE_INTEGER || min < Number.MIN_SAFE_INTEGER) {\r\n    throw new Error('Arguments must be safe integers.');\r\n  } else if (range > maxGeneratedValue) {\r\n    throw new Error(`Range of ${range} (from ${min} to ${max}) > ${maxGeneratedValue}.`);\r\n  } else if (max < min) {\r\n    throw new Error(`max (${max}) must be >= min (${min}).`);\r\n  } else if (min === max) {\r\n    return min;\r\n  } \r\n\r\n  let generated;\r\n  do {\r\n    generated = crypto.getRandomValues(new Uint32Array(1))[0];\r\n  } while (generated > maxUnbiased);\r\n\r\n  return min + (generated % possibleResultValues);\r\n};\r\n\r\nconsole.log(randomInteger(-8, 8));          // -2\r\nconsole.log(randomInteger(0, 0));           // 0\r\nconsole.log(randomInteger(0, 0xFFFFFFFF));  // 944450079\r\nconsole.log(randomInteger(-1, 0xFFFFFFFF));\r\n// Error: Range of 4294967296 covering -1 to 4294967295 is > 4294967295.\r\nconsole.log(new Array(12).fill().map(n => randomInteger(8, 12)));\r\n// [11, 8, 8, 11, 10, 8, 8, 12, 12, 12, 9, 9]const randomInteger = (min, max) => {\r\n  const range = max - min;\r\n  const maxGeneratedValue = 0xFFFFFFFF;\r\n  const possibleResultValues = range + 1;\r\n  const possibleGeneratedValues = maxGeneratedValue + 1;\r\n  const remainder = possibleGeneratedValues % possibleResultValues;\r\n  const maxUnbiased = maxGeneratedValue - remainder;\r\n\r\n  if (!Number.isInteger(min) || !Number.isInteger(max) ||\r\n       max > Number.MAX_SAFE_INTEGER || min < Number.MIN_SAFE_INTEGER) {\r\n    throw new Error('Arguments must be safe integers.');\r\n  } else if (range > maxGeneratedValue) {\r\n    throw new Error(`Range of ${range} (from ${min} to ${max}) > ${maxGeneratedValue}.`);\r\n  } else if (max < min) {\r\n    throw new Error(`max (${max}) must be >= min (${min}).`);\r\n  } else if (min === max) {\r\n    return min;\r\n  } \r\n\r\n  let generated;\r\n  do {\r\n    generated = crypto.getRandomValues(new Uint32Array(1))[0];\r\n  } while (generated > maxUnbiased);\r\n\r\n  return min + (generated % possibleResultValues);\r\n};\r\n\r\nconsole.log(randomInteger(-8, 8));          // -2\r\nconsole.log(randomInteger(0, 0));           // 0\r\nconsole.log(randomInteger(0, 0xFFFFFFFF));  // 944450079\r\nconsole.log(randomInteger(-1, 0xFFFFFFFF));\r\n// Error: Range of 4294967296 covering -1 to 4294967295 is > 4294967295.\r\nconsole.log(new Array(12).fill().map(n => randomInteger(8, 12)));\r\n// [11, 8, 8, 11, 10, 8, 8, 12, 12, 12, 9, 9]",
                "Here is an example of a JavaScript function that can generate a random number of any specified length without using Math.random():without using Math.random():function genRandom(length)\n{\n  const t1 = new Date().getMilliseconds();\n  var min = \"1\", max = \"9\";\n  var result;\n  var numLength = length;\n  if (numLength != 0)\n  {\n     for (var i = 1; i < numLength; i++)\n     {\n        min = min.toString() + \"0\";\n        max = max.toString() + \"9\";\n     }\n  }\n  else\n  {\n     min = 0;\n     max = 0;\n     return;\n  }\n\n  for (var i = min; i <= max; i++)\n  {\n       // Empty Loop\n  }\n\n  const t2 = new Date().getMilliseconds();\n  console.log(t2);\n  result = ((max - min)*t1)/t2;\n  console.log(result);\n  return result;\n}\nfunction genRandom(length)\n{\n  const t1 = new Date().getMilliseconds();\n  var min = \"1\", max = \"9\";\n  var result;\n  var numLength = length;\n  if (numLength != 0)\n  {\n     for (var i = 1; i < numLength; i++)\n     {\n        min = min.toString() + \"0\";\n        max = max.toString() + \"9\";\n     }\n  }\n  else\n  {\n     min = 0;\n     max = 0;\n     return;\n  }\n\n  for (var i = min; i <= max; i++)\n  {\n       // Empty Loop\n  }\n\n  const t2 = new Date().getMilliseconds();\n  console.log(t2);\n  result = ((max - min)*t1)/t2;\n  console.log(result);\n  return result;\n}\n",
                "Use:<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n    </head>\n\n    <body>\n        <script>\n            /*\n                Assuming that window.crypto.getRandomValues\n                is available, the real range would be from\n                0 to 1,998 instead of 0 to 2,000.\n\n                See the JavaScript documentation\n                for an explanation:\n\n                  https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues\n            */\n            var array = new Uint8Array(2);\n            window.crypto.getRandomValues(array);\n            console.log(array[0] + array[1]);\n        </script>\n    </body>\n</html>\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n    </head>\n\n    <body>\n        <script>\n            /*\n                Assuming that window.crypto.getRandomValues\n                is available, the real range would be from\n                0 to 1,998 instead of 0 to 2,000.\n\n                See the JavaScript documentation\n                for an explanation:\n\n                  https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues\n            */\n            var array = new Uint8Array(2);\n            window.crypto.getRandomValues(array);\n            console.log(array[0] + array[1]);\n        </script>\n    </body>\n</html>\nUint8Array creates an array filled with a number up to three digits which would be a maximum of 999. This code is very short.",
                "This is my take on a random number in a range, as in I wanted to get a random number within a range of base to exponent. E.g., base = 10, exponent = 2, gives a random number from 0 to 100, ideally, and so on.If it helps using it, here it is:// Get random number within provided base + exponent\n// By Goran Biljetina --> 2012\n\nfunction isEmpty(value) {\n    return (typeof value === \"undefined\" || value === null);\n}\n\nvar numSeq = new Array();\n\nfunction add(num, seq) {\n    var toAdd = new Object();\n    toAdd.num = num;\n    toAdd.seq = seq;\n    numSeq[numSeq.length] = toAdd;\n}\n\nfunction fillNumSeq (num, seq) {\n    var n;\n    for(i=0; i<=seq; i++) {\n        n = Math.pow(num, i);\n        add(n, i);\n    }\n}\n\nfunction getRandNum(base, exp) {\n    if (isEmpty(base)) {\n        console.log(\"Specify value for base parameter\");\n    }\n    if (isEmpty(exp)) {\n        console.log(\"Specify value for exponent parameter\");\n    }\n\n    fillNumSeq(base, exp);\n\n    var emax;\n    var eseq;\n    var nseed;\n    var nspan;\n    emax = (numSeq.length);\n    eseq = Math.floor(Math.random()*emax) + 1;\n    nseed = numSeq[eseq].num;\n    nspan = Math.floor((Math.random())*(Math.random()*nseed)) + 1;\n    return Math.floor(Math.random()*nspan) + 1;\n}\n\nconsole.log(getRandNum(10, 20), numSeq);\n\n//Testing:\n//getRandNum(-10, 20);\n//console.log(getRandNum(-10, 20), numSeq);\n//console.log(numSeq);\n// Get random number within provided base + exponent\n// By Goran Biljetina --> 2012\n\nfunction isEmpty(value) {\n    return (typeof value === \"undefined\" || value === null);\n}\n\nvar numSeq = new Array();\n\nfunction add(num, seq) {\n    var toAdd = new Object();\n    toAdd.num = num;\n    toAdd.seq = seq;\n    numSeq[numSeq.length] = toAdd;\n}\n\nfunction fillNumSeq (num, seq) {\n    var n;\n    for(i=0; i<=seq; i++) {\n        n = Math.pow(num, i);\n        add(n, i);\n    }\n}\n\nfunction getRandNum(base, exp) {\n    if (isEmpty(base)) {\n        console.log(\"Specify value for base parameter\");\n    }\n    if (isEmpty(exp)) {\n        console.log(\"Specify value for exponent parameter\");\n    }\n\n    fillNumSeq(base, exp);\n\n    var emax;\n    var eseq;\n    var nseed;\n    var nspan;\n    emax = (numSeq.length);\n    eseq = Math.floor(Math.random()*emax) + 1;\n    nseed = numSeq[eseq].num;\n    nspan = Math.floor((Math.random())*(Math.random()*nseed)) + 1;\n    return Math.floor(Math.random()*nspan) + 1;\n}\n\nconsole.log(getRandNum(10, 20), numSeq);\n\n//Testing:\n//getRandNum(-10, 20);\n//console.log(getRandNum(-10, 20), numSeq);\n//console.log(numSeq);\n",
                "This I guess, is the most simplified of all the contributions.maxNum = 8,\nminNum = 4\n\nconsole.log(Math.floor(Math.random() * (maxNum - minNum) + minNum))\n\nconsole.log(Math.floor(Math.random() * (8 - 4) + 4))\nmaxNum = 8,\nminNum = 4\n\nconsole.log(Math.floor(Math.random() * (maxNum - minNum) + minNum))\n\nconsole.log(Math.floor(Math.random() * (8 - 4) + 4))\nThis will log random numbers between 4 and 8 into the console, 4 and 8 inclusive.",
                "Ionu\u021b G. Stan wrote a great answer, but it was a bit too complex for me to grasp. So, I found an even simpler explanation of the same concepts at Math.floor( Math.random () * (max - min + 1)) + min) Explanation by Jason Anello.Ionu\u021b G. Stana great answerMath.floor( Math.random () * (max - min + 1)) + min) ExplanationMath.floor( Math.random () * (max - min + 1)) + min) ExplanationNote: The only important thing you should know before reading Jason's explanation is a definition of \"truncate\". He uses that term when describing Math.floor(). Oxford dictionary defines \"truncate\" as:Note:Math.floor()\nShorten (something) by cutting off the top or end.\nShorten (something) by cutting off the top or end.",
                "A function called randUpTo that accepts a number and returns a random whole number between 0 and that number:randUpTovar randUpTo = function(num) {\n    return Math.floor(Math.random() * (num - 1) + 0);\n};\nvar randUpTo = function(num) {\n    return Math.floor(Math.random() * (num - 1) + 0);\n};\nA function called randBetween that accepts two numbers representing a range and returns a random whole number between those two numbers:randBetweenvar randBetween = function (min, max) {\n    return Math.floor(Math.random() * (max - min - 1)) + min;\n};\nvar randBetween = function (min, max) {\n    return Math.floor(Math.random() * (max - min - 1)) + min;\n};\nA function called randFromTill that accepts two numbers representing a range and returns a random number between min (inclusive) and max (exclusive)randFromTillvar randFromTill = function (min, max) {\n    return Math.random() * (max - min) + min;\n};\nvar randFromTill = function (min, max) {\n    return Math.random() * (max - min) + min;\n};\nA function called randFromTo that accepts two numbers representing a range and returns a random integer between min (inclusive) and max (inclusive):randFromTovar randFromTo = function (min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nvar randFromTo = function (min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n",
                "You can you this code snippet,let randomNumber = function(first, second) {\n    let number = Math.floor(Math.random()*Math.floor(second));\n    while(number < first) {\n\n        number = Math.floor(Math.random()*Math.floor(second));\n    }\n    return number;\n}\nlet randomNumber = function(first, second) {\n    let number = Math.floor(Math.random()*Math.floor(second));\n    while(number < first) {\n\n        number = Math.floor(Math.random()*Math.floor(second));\n    }\n    return number;\n}\n"
            ]
        },
        {
            "tag": "c#",
            "patterns": [
                "Get int value from enum in C#",
                "Get int value from enum in C#"
            ],
            "responses": [
                "Just cast the enum, e.g.int something = (int) Question.Role;\nint something = (int) Question.Role;\nThe above will work for the vast majority of enums you see in the wild, as the default underlying type for an enum is int.intHowever, as cecilphillip points out, enums can have different underlying types.\nIf an enum is declared as a uint, long, or ulong, it should be cast to the type of the enum; e.g. forcecilphillipuintlongulongenum StarsInMilkyWay:long {Sun = 1, V645Centauri = 2 .. Wolf424B = 2147483649};\nenum StarsInMilkyWay:long {Sun = 1, V645Centauri = 2 .. Wolf424B = 2147483649};\nyou should uselong something = (long)StarsInMilkyWay.Wolf424B;\nlong something = (long)StarsInMilkyWay.Wolf424B;\n",
                "Since Enums can be any integral type (byte, int, short, etc.), a more robust way to get the underlying integral value of the enum would be to make use of the GetTypeCode method in conjunction with the Convert class:byteintshortGetTypeCodeConvertenum Sides {\n    Left, Right, Top, Bottom\n}\nSides side = Sides.Bottom;\n\nobject val = Convert.ChangeType(side, side.GetTypeCode());\nConsole.WriteLine(val);\nenum Sides {\n    Left, Right, Top, Bottom\n}\nSides side = Sides.Bottom;\n\nobject val = Convert.ChangeType(side, side.GetTypeCode());\nConsole.WriteLine(val);\nThis should work regardless of the underlying integral type.",
                "Declare it as a static class having public constants:public static class Question\n{\n    public const int Role = 2;\n    public const int ProjectFunding = 3;\n    public const int TotalEmployee = 4;\n    public const int NumberOfServers = 5;\n    public const int TopBusinessConcern = 6;\n}\npublic static class Question\n{\n    public const int Role = 2;\n    public const int ProjectFunding = 3;\n    public const int TotalEmployee = 4;\n    public const int NumberOfServers = 5;\n    public const int TopBusinessConcern = 6;\n}\nAnd then you can reference it as Question.Role, and it always evaluates to an int or whatever you define it as.Question.Roleint",
                "On a related note, if you want to get the int value from System.Enum, then given e here:intSystem.EnumeEnum e = Question.Role;\nEnum e = Question.Role;\nYou can use:int i = Convert.ToInt32(e);\nint i = (int)(object)e;\nint i = (int)Enum.Parse(e.GetType(), e.ToString());\nint i = (int)Enum.ToObject(e.GetType(), e);\nint i = Convert.ToInt32(e);\nint i = (int)(object)e;\nint i = (int)Enum.Parse(e.GetType(), e.ToString());\nint i = (int)Enum.ToObject(e.GetType(), e);\nThe last two are plain ugly. I prefer the first one.",
                "Question question = Question.Role;\nint value = (int) question;\nQuestion question = Question.Role;\nint value = (int) question;\nWill result in value == 2.value == 2",
                "Example:public enum EmpNo\n{\n    Raj = 1,\n    Rahul,\n    Priyanka\n}\npublic enum EmpNo\n{\n    Raj = 1,\n    Rahul,\n    Priyanka\n}\nAnd in the code behind to get the enum value:int setempNo = (int)EmpNo.Raj; // This will give setempNo = 1\nint setempNo = (int)EmpNo.Raj; // This will give setempNo = 1\norint setempNo = (int)EmpNo.Rahul; // This will give setempNo = 2\nint setempNo = (int)EmpNo.Rahul; // This will give setempNo = 2\nEnums will increment by 1, and you can set the start value. If you don't set the start value it will be assigned as 0 initially.",
                "It's easier than you think - an enum is already an int. It just needs to be reminded:int y = (int)Question.Role;\nConsole.WriteLine(y); // Prints 2\nint y = (int)Question.Role;\nConsole.WriteLine(y); // Prints 2\n",
                "I have recently converted away from using enums in my code in favour of instead using classes with protected constructors and predefined static instances (thanks to Roelof - C# Ensure Valid Enum Values - Futureproof Method).C# Ensure Valid Enum Values - Futureproof MethodIn light of that, below's how I'd now approach this issue (including implicit conversion to/from int).intpublic class Question\n{\n    // Attributes\n    protected int index;\n    protected string name;\n    // Go with a dictionary to enforce unique index\n    //protected static readonly ICollection<Question> values = new Collection<Question>();\n    protected static readonly IDictionary<int,Question> values = new Dictionary<int,Question>();\n\n    // Define the \"enum\" values\n    public static readonly Question Role = new Question(2,\"Role\");\n    public static readonly Question ProjectFunding = new Question(3, \"Project Funding\");\n    public static readonly Question TotalEmployee = new Question(4, \"Total Employee\");\n    public static readonly Question NumberOfServers = new Question(5, \"Number of Servers\");\n    public static readonly Question TopBusinessConcern = new Question(6, \"Top Business Concern\");\n\n    // Constructors\n    protected Question(int index, string name)\n    {\n        this.index = index;\n        this.name = name;\n        values.Add(index, this);\n    }\n\n    // Easy int conversion\n    public static implicit operator int(Question question) =>\n        question.index; //nb: if question is null this will return a null pointer exception\n\n    public static implicit operator Question(int index) =>        \n        values.TryGetValue(index, out var question) ? question : null;\n\n    // Easy string conversion (also update ToString for the same effect)\n    public override string ToString() =>\n        this.name;\n\n    public static implicit operator string(Question question) =>\n        question?.ToString();\n\n    public static implicit operator Question(string name) =>\n        name == null ? null : values.Values.FirstOrDefault(item => name.Equals(item.name, StringComparison.CurrentCultureIgnoreCase));\n\n\n    // If you specifically want a Get(int x) function (though not required given the implicit converstion)\n    public Question Get(int foo) =>\n        foo; //(implicit conversion will take care of the conversion for you)\n}\npublic class Question\n{\n    // Attributes\n    protected int index;\n    protected string name;\n    // Go with a dictionary to enforce unique index\n    //protected static readonly ICollection<Question> values = new Collection<Question>();\n    protected static readonly IDictionary<int,Question> values = new Dictionary<int,Question>();\n\n    // Define the \"enum\" values\n    public static readonly Question Role = new Question(2,\"Role\");\n    public static readonly Question ProjectFunding = new Question(3, \"Project Funding\");\n    public static readonly Question TotalEmployee = new Question(4, \"Total Employee\");\n    public static readonly Question NumberOfServers = new Question(5, \"Number of Servers\");\n    public static readonly Question TopBusinessConcern = new Question(6, \"Top Business Concern\");\n\n    // Constructors\n    protected Question(int index, string name)\n    {\n        this.index = index;\n        this.name = name;\n        values.Add(index, this);\n    }\n\n    // Easy int conversion\n    public static implicit operator int(Question question) =>\n        question.index; //nb: if question is null this will return a null pointer exception\n\n    public static implicit operator Question(int index) =>        \n        values.TryGetValue(index, out var question) ? question : null;\n\n    // Easy string conversion (also update ToString for the same effect)\n    public override string ToString() =>\n        this.name;\n\n    public static implicit operator string(Question question) =>\n        question?.ToString();\n\n    public static implicit operator Question(string name) =>\n        name == null ? null : values.Values.FirstOrDefault(item => name.Equals(item.name, StringComparison.CurrentCultureIgnoreCase));\n\n\n    // If you specifically want a Get(int x) function (though not required given the implicit converstion)\n    public Question Get(int foo) =>\n        foo; //(implicit conversion will take care of the conversion for you)\n}\nThe advantage of this approach is you get everything you would have from the enum, but your code's now much more flexible, so should you need to perform different actions based on the value of Question, you can put logic into Question itself (i.e. in the preferred OO fashion) as opposed to putting lots of case statements throughout your code to tackle each scenario.QuestionQuestionNB: Answer updated 2018-04-27 to make use of C# 6 features; i.e. declaration expressions and lambda expression body definitions.  See revision history for original code.  This has the benefit of making the definition a little less verbose; which had been one of the main complaints about this answer's approach.revision history",
                "If you want to get an integer for the enum value that is stored in a variable, for which the type would be Question, to use for example in a method, you can simply do this I wrote in this example: Questionenum Talen\n{\n    Engels = 1, Italiaans = 2, Portugees = 3, Nederlands = 4, Duits = 5, Dens = 6\n}\n\nTalen Geselecteerd;    \n\npublic void Form1()\n{\n    InitializeComponent()\n    Geselecteerd = Talen.Nederlands;\n}\n\n// You can use the Enum type as a parameter, so any enumeration from any enumerator can be used as parameter\nvoid VeranderenTitel(Enum e)\n{\n    this.Text = Convert.ToInt32(e).ToString();\n}\nenum Talen\n{\n    Engels = 1, Italiaans = 2, Portugees = 3, Nederlands = 4, Duits = 5, Dens = 6\n}\n\nTalen Geselecteerd;    \n\npublic void Form1()\n{\n    InitializeComponent()\n    Geselecteerd = Talen.Nederlands;\n}\n\n// You can use the Enum type as a parameter, so any enumeration from any enumerator can be used as parameter\nvoid VeranderenTitel(Enum e)\n{\n    this.Text = Convert.ToInt32(e).ToString();\n}\nThis will change the window title to 4, because the variable Geselecteerd is Talen.Nederlands. If I change it to Talen.Portugees and call the method again, the text will change to 3.GeselecteerdTalen.NederlandsTalen.Portugees",
                "One more way to do it:Console.WriteLine(\"Name: {0}, Value: {0:D}\", Question.Role);\nConsole.WriteLine(\"Name: {0}, Value: {0:D}\", Question.Role);\nIt will result in:Name: Role, Value: 2\nName: Role, Value: 2\n",
                "To ensure an enum value exists and then parse it, you can also do the following.// Fake Day of Week\nstring strDOWFake = \"SuperDay\";\n\n// Real Day of Week\nstring strDOWReal = \"Friday\";\n\n// Will hold which ever is the real DOW.\nDayOfWeek enmDOW;\n\n// See if fake DOW is defined in the DayOfWeek enumeration.\nif (Enum.IsDefined(typeof(DayOfWeek), strDOWFake))\n{\n    // This will never be reached since \"SuperDay\"\n    // doesn't exist in the DayOfWeek enumeration.\n    enmDOW = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), strDOWFake);\n}\n// See if real DOW is defined in the DayOfWeek enumeration.\nelse if (Enum.IsDefined(typeof(DayOfWeek), strDOWReal))\n{\n    // This will parse the string into it's corresponding DOW enum object.\n    enmDOW = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), strDOWReal);\n}\n\n// Can now use the DOW enum object.\nConsole.Write(\"Today is \" + enmDOW.ToString() + \".\");\n// Fake Day of Week\nstring strDOWFake = \"SuperDay\";\n\n// Real Day of Week\nstring strDOWReal = \"Friday\";\n\n// Will hold which ever is the real DOW.\nDayOfWeek enmDOW;\n\n// See if fake DOW is defined in the DayOfWeek enumeration.\nif (Enum.IsDefined(typeof(DayOfWeek), strDOWFake))\n{\n    // This will never be reached since \"SuperDay\"\n    // doesn't exist in the DayOfWeek enumeration.\n    enmDOW = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), strDOWFake);\n}\n// See if real DOW is defined in the DayOfWeek enumeration.\nelse if (Enum.IsDefined(typeof(DayOfWeek), strDOWReal))\n{\n    // This will parse the string into it's corresponding DOW enum object.\n    enmDOW = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), strDOWReal);\n}\n\n// Can now use the DOW enum object.\nConsole.Write(\"Today is \" + enmDOW.ToString() + \".\");\n",
                "Use an extension method instead:public static class ExtensionMethods\n{\n    public static int IntValue(this Enum argEnum)\n    {\n        return Convert.ToInt32(argEnum);\n    }\n}\npublic static class ExtensionMethods\n{\n    public static int IntValue(this Enum argEnum)\n    {\n        return Convert.ToInt32(argEnum);\n    }\n}\nAnd the usage is slightly prettier:var intValue = Question.Role.IntValue();\nvar intValue = Question.Role.IntValue();\n",
                "public enum QuestionType\n{\n    Role = 2,\n    ProjectFunding = 3,\n    TotalEmployee = 4,\n    NumberOfServers = 5,\n    TopBusinessConcern = 6\n}\npublic enum QuestionType\n{\n    Role = 2,\n    ProjectFunding = 3,\n    TotalEmployee = 4,\n    NumberOfServers = 5,\n    TopBusinessConcern = 6\n}\n...is a fine declaration.You do have to cast the result to int like so:int Question = (int)QuestionType.Role\nint Question = (int)QuestionType.Role\nOtherwise, the type is still QuestionType.QuestionTypeThis level of strictness is the C# way. One alternative is to use a class declaration instead:public class QuestionType\n{\n    public static int Role = 2,\n    public static int ProjectFunding = 3,\n    public static int TotalEmployee = 4,\n    public static int NumberOfServers = 5,\n    public static int TopBusinessConcern = 6\n}\npublic class QuestionType\n{\n    public static int Role = 2,\n    public static int ProjectFunding = 3,\n    public static int TotalEmployee = 4,\n    public static int NumberOfServers = 5,\n    public static int TopBusinessConcern = 6\n}\nIt's less elegant to declare, but you don't need to cast it in code:int Question = QuestionType.Role\nint Question = QuestionType.Role\nAlternatively, you may feel more comfortable with Visual Basic, which caters for this type of expectation in many areas.",
                "Maybe I missed it, but has anyone tried a simple generic extension method?This works great for me. You can avoid the type cast in your API this way but ultimately it results in a change type operation. This is a good case for programming Roslyn to have the compiler make a GetValue<T> method for you.Roslyn    public static void Main()\n    {\n        int test = MyCSharpWrapperMethod(TestEnum.Test1);\n\n        Debug.Assert(test == 1);\n    }\n\n    public static int MyCSharpWrapperMethod(TestEnum customFlag)\n    {\n        return MyCPlusPlusMethod(customFlag.GetValue<int>());\n    }\n\n    public static int MyCPlusPlusMethod(int customFlag)\n    {\n        // Pretend you made a PInvoke or COM+ call to C++ method that require an integer\n        return customFlag;\n    }\n\n    public enum TestEnum\n    {\n        Test1 = 1,\n        Test2 = 2,\n        Test3 = 3\n    }\n}\n\npublic static class EnumExtensions\n{\n    public static T GetValue<T>(this Enum enumeration)\n    {\n        T result = default(T);\n\n        try\n        {\n            result = (T)Convert.ChangeType(enumeration, typeof(T));\n        }\n        catch (Exception ex)\n        {\n            Debug.Assert(false);\n            Debug.WriteLine(ex);\n        }\n\n        return result;\n    }\n}\n    public static void Main()\n    {\n        int test = MyCSharpWrapperMethod(TestEnum.Test1);\n\n        Debug.Assert(test == 1);\n    }\n\n    public static int MyCSharpWrapperMethod(TestEnum customFlag)\n    {\n        return MyCPlusPlusMethod(customFlag.GetValue<int>());\n    }\n\n    public static int MyCPlusPlusMethod(int customFlag)\n    {\n        // Pretend you made a PInvoke or COM+ call to C++ method that require an integer\n        return customFlag;\n    }\n\n    public enum TestEnum\n    {\n        Test1 = 1,\n        Test2 = 2,\n        Test3 = 3\n    }\n}\n\npublic static class EnumExtensions\n{\n    public static T GetValue<T>(this Enum enumeration)\n    {\n        T result = default(T);\n\n        try\n        {\n            result = (T)Convert.ChangeType(enumeration, typeof(T));\n        }\n        catch (Exception ex)\n        {\n            Debug.Assert(false);\n            Debug.WriteLine(ex);\n        }\n\n        return result;\n    }\n}\n",
                "int number = Question.Role.GetHashCode();\nint number = Question.Role.GetHashCode();\nnumber should have the value 2.number2",
                "Use:Question question = Question.Role;\nint value = question.GetHashCode();\nQuestion question = Question.Role;\nint value = question.GetHashCode();\nIt will result in value == 2.value == 2This is only true if the enum fits inside an int.int",
                "You can do this by implementing an extension method to your defined enum type:extension methodpublic static class MyExtensions\n{\n    public static int getNumberValue(this Question questionThis)\n    {\n        return (int)questionThis;\n    }\n}\npublic static class MyExtensions\n{\n    public static int getNumberValue(this Question questionThis)\n    {\n        return (int)questionThis;\n    }\n}\nThis simplifies getting the int value of the current enum value:Question question = Question.Role;\nint value = question.getNumberValue();\nQuestion question = Question.Role;\nint value = question.getNumberValue();\norint value = Question.Role.getNumberValue();\nint value = Question.Role.getNumberValue();\n",
                "public enum Suit : int\n{\n    Spades = 0,\n    Hearts = 1,\n    Clubs = 2,\n    Diamonds = 3\n}\n\nConsole.WriteLine((int)(Suit)Enum.Parse(typeof(Suit), \"Clubs\"));\n\n// From int\nConsole.WriteLine((Suit)1);\n\n// From a number you can also\nConsole.WriteLine((Suit)Enum.ToObject(typeof(Suit), 1));\n\nif (typeof(Suit).IsEnumDefined(\"Spades\"))\n{\n    var res = (int)(Suit)Enum.Parse(typeof(Suit), \"Spades\");\n    Console.Out.WriteLine(\"{0}\", res);\n}\npublic enum Suit : int\n{\n    Spades = 0,\n    Hearts = 1,\n    Clubs = 2,\n    Diamonds = 3\n}\n\nConsole.WriteLine((int)(Suit)Enum.Parse(typeof(Suit), \"Clubs\"));\n\n// From int\nConsole.WriteLine((Suit)1);\n\n// From a number you can also\nConsole.WriteLine((Suit)Enum.ToObject(typeof(Suit), 1));\n\nif (typeof(Suit).IsEnumDefined(\"Spades\"))\n{\n    var res = (int)(Suit)Enum.Parse(typeof(Suit), \"Spades\");\n    Console.Out.WriteLine(\"{0}\", res);\n}\n",
                "Since enums can be declared with multiple primitive types, a generic extension method to cast any enum type can be useful.enum Box\n{\n    HEIGHT,\n    WIDTH,\n    DEPTH\n}\n\npublic static void UseEnum()\n{\n    int height = Box.HEIGHT.GetEnumValue<int>();\n    int width = Box.WIDTH.GetEnumValue<int>();\n    int depth = Box.DEPTH.GetEnumValue<int>();\n}\n\npublic static T GetEnumValue<T>(this object e) => (T)e;\nenum Box\n{\n    HEIGHT,\n    WIDTH,\n    DEPTH\n}\n\npublic static void UseEnum()\n{\n    int height = Box.HEIGHT.GetEnumValue<int>();\n    int width = Box.WIDTH.GetEnumValue<int>();\n    int depth = Box.DEPTH.GetEnumValue<int>();\n}\n\npublic static T GetEnumValue<T>(this object e) => (T)e;\n",
                "The easiest solution I can think of is overloading the Get(int) method like this:Get(int)[modifiers] Questions Get(Question q)\n{\n    return Get((int)q);\n}\n[modifiers] Questions Get(Question q)\n{\n    return Get((int)q);\n}\nwhere [modifiers] can generally be same as for the Get(int) method. If you can't edit the Questions class or for some reason don't want to, you can overload the method by writing an extension:[modifiers]Get(int)Questionspublic static class Extensions\n{\n    public static Questions Get(this Questions qs, Question q)\n    {\n        return qs.Get((int)q);\n    }\n}\npublic static class Extensions\n{\n    public static Questions Get(this Questions qs, Question q)\n    {\n        return qs.Get((int)q);\n    }\n}\n",
                "My favourite hack with int or smaller enums:GetHashCode();\nGetHashCode();\nFor an enumpublic enum Test\n{\n    Min = Int32.MinValue,\n    One = 1,\n    Max = Int32.MaxValue,\n}\npublic enum Test\n{\n    Min = Int32.MinValue,\n    One = 1,\n    Max = Int32.MaxValue,\n}\nThis,var values = Enum.GetValues(typeof(Test));\n\nforeach (var val in values)\n{\n    Console.WriteLine(val.GetHashCode());\n    Console.WriteLine(((int)val));\n    Console.WriteLine(val);\n}\nvar values = Enum.GetValues(typeof(Test));\n\nforeach (var val in values)\n{\n    Console.WriteLine(val.GetHashCode());\n    Console.WriteLine(((int)val));\n    Console.WriteLine(val);\n}\noutputsone\n1\n1\nmax\n2147483647\n2147483647\nmin\n-2147483648\n-2147483648\none\n1\n1\nmax\n2147483647\n2147483647\nmin\n-2147483648\n-2147483648\nDisclaimer:Disclaimer:It doesn't work for enums based on long.",
                "Try this one instead of convert enum to int:public static class ReturnType\n{\n    public static readonly int Success = 1;\n    public static readonly int Duplicate = 2;\n    public static readonly int Error = -1;        \n}\npublic static class ReturnType\n{\n    public static readonly int Success = 1;\n    public static readonly int Duplicate = 2;\n    public static readonly int Error = -1;        \n}\n",
                "Following is the extension methodpublic static string ToEnumString<TEnum>(this int enumValue)\n{\n    var enumString = enumValue.ToString();\n    if (Enum.IsDefined(typeof(TEnum), enumValue))\n    {\n        enumString = ((TEnum) Enum.ToObject(typeof (TEnum), enumValue)).ToString();\n    }\n    return enumString;\n}\npublic static string ToEnumString<TEnum>(this int enumValue)\n{\n    var enumString = enumValue.ToString();\n    if (Enum.IsDefined(typeof(TEnum), enumValue))\n    {\n        enumString = ((TEnum) Enum.ToObject(typeof (TEnum), enumValue)).ToString();\n    }\n    return enumString;\n}\n",
                "You should have used Type Casting as we can use in any other language.Type CastingType CastingType CastingIf your enum is like this-enumpublic enum Question\n{\n    Role = 2,\n    ProjectFunding = 3,\n    TotalEmployee = 4,\n    NumberOfServers = 5,\n    TopBusinessConcern = 6\n}\npublic enum Question\n{\n    Role = 2,\n    ProjectFunding = 3,\n    TotalEmployee = 4,\n    NumberOfServers = 5,\n    TopBusinessConcern = 6\n}\nAnd you need to cast to an int, then do this-intQuestion q = Question.Role;\n.............\n.............\nint something = (int) q;\nQuestion q = Question.Role;\n.............\n.............\nint something = (int) q;\nRe-In C#, there are two types of casting:\nImplicit Casting (automatically) - converting a smaller type to a larger type size like-\nImplicit Casting (automatically) - converting a smaller type to a larger type size like-Implicit Casting (automatically)automatically\nchar -> int -> long -> float -> double\nchar -> int -> long -> float -> doublecharintlongfloatdouble\nExplicit Casting (manually) - converting a larger type to a smaller size type like-\nExplicit Casting (manually) - converting a larger type to a smaller size type like-Explicit Casting (manually)manually\ndouble -> float -> long -> int -> char\ndouble -> float -> long -> int -> chardoublefloatlongintcharMore can be found in here.hereherehere",
                "The example I would like to suggest \"to get an 'int' value from an enum\", ispublic enum Sample\n{\n    Book = 1, \n    Pen = 2, \n    Pencil = 3\n}\n\nint answer = (int)Sample.Book;\npublic enum Sample\n{\n    Book = 1, \n    Pen = 2, \n    Pencil = 3\n}\n\nint answer = (int)Sample.Book;\nNow the answer will be 1.",
                "In Visual Basic, it should be:Public Enum Question\n    Role = 2\n    ProjectFunding = 3\n    TotalEmployee = 4\n    NumberOfServers = 5\n    TopBusinessConcern = 6\nEnd Enum\n\nPrivate value As Integer = CInt(Question.Role)\nPublic Enum Question\n    Role = 2\n    ProjectFunding = 3\n    TotalEmployee = 4\n    NumberOfServers = 5\n    TopBusinessConcern = 6\nEnd Enum\n\nPrivate value As Integer = CInt(Question.Role)\n",
                "will give you the a list with all the integer values of the enum :List enumValues = Enum.GetValues(typeof(EnumClass)).Cast().ToList();",
                "public enum ViewType\n{\n    List = 1,\n    Table = 2,\n};\n            \n// You can use the Enum type as a parameter, so any enumeration from any enumerator \n// cshtml\n// using proyects.Helpers\n// @if (Model.ViewType== (int)<variable>.List )\npublic enum ViewType\n{\n    List = 1,\n    Table = 2,\n};\n            \n// You can use the Enum type as a parameter, so any enumeration from any enumerator \n// cshtml\n// using proyects.Helpers\n// @if (Model.ViewType== (int)<variable>.List )\n",
                "I came up with this extension method that includes current language features. By using dynamic, I don't need to make this a generic method and specify the type which keeps the invocation simpler and consistent:public static class EnumEx\n{\n    public static dynamic Value(this Enum e)\n    {\n        switch (e.GetTypeCode())\n        {\n            case TypeCode.Byte:\n            {\n                return (byte) (IConvertible) e;\n            }\n\n            case TypeCode.Int16:\n            {\n                return (short) (IConvertible) e;\n            }\n\n            case TypeCode.Int32:\n            {\n                return (int) (IConvertible) e;\n            }\n\n            case TypeCode.Int64:\n            {\n                return (long) (IConvertible) e;\n            }\n\n            case TypeCode.UInt16:\n            {\n                return (ushort) (IConvertible) e;\n            }\n\n            case TypeCode.UInt32:\n            {\n                return (uint) (IConvertible) e;\n            }\n\n            case TypeCode.UInt64:\n            {\n                return (ulong) (IConvertible) e;\n            }\n\n            case TypeCode.SByte:\n            {\n                return (sbyte) (IConvertible) e;\n            }\n        }\n\n        return 0;\n    }\npublic static class EnumEx\n{\n    public static dynamic Value(this Enum e)\n    {\n        switch (e.GetTypeCode())\n        {\n            case TypeCode.Byte:\n            {\n                return (byte) (IConvertible) e;\n            }\n\n            case TypeCode.Int16:\n            {\n                return (short) (IConvertible) e;\n            }\n\n            case TypeCode.Int32:\n            {\n                return (int) (IConvertible) e;\n            }\n\n            case TypeCode.Int64:\n            {\n                return (long) (IConvertible) e;\n            }\n\n            case TypeCode.UInt16:\n            {\n                return (ushort) (IConvertible) e;\n            }\n\n            case TypeCode.UInt32:\n            {\n                return (uint) (IConvertible) e;\n            }\n\n            case TypeCode.UInt64:\n            {\n                return (ulong) (IConvertible) e;\n            }\n\n            case TypeCode.SByte:\n            {\n                return (sbyte) (IConvertible) e;\n            }\n        }\n\n        return 0;\n    }\n"
            ]
        },
        {
            "tag": "javascript",
            "patterns": [
                "How to convert a string to an integer in JavaScript",
                "how can i convert a string to an integer with javascript?",
                "how do i convert a string in to an integer in javascript?",
                "how do i convert a string to an integer in javascript?"
            ],
            "responses": [
                "The simplest way would be to use the native Number function:Numbervar x = Number(\"1000\")\nvar x = Number(\"1000\")\nIf that doesn't work for you, then there are the parseInt, unary plus, parseFloat with floor, and Math.round methods.parseIntunary plusparseFloat with floorMath.roundparseInt()var x = parseInt(\"1000\", 10); // You want to use radix 10\n    // So you get a decimal number even with a leading 0 and an old browser ([IE8, Firefox 20, Chrome 22 and older][1])\nvar x = parseInt(\"1000\", 10); // You want to use radix 10\n    // So you get a decimal number even with a leading 0 and an old browser ([IE8, Firefox 20, Chrome 22 and older][1])\nUnary plusIf your string is already in the form of an integer:var x = +\"1000\";\nvar x = +\"1000\";\nfloor()If your string is or might be a float and you want an integer:var x = Math.floor(\"1000.01\"); // floor() automatically converts string to number\nvar x = Math.floor(\"1000.01\"); // floor() automatically converts string to number\nOr, if you're going to be using Math.floor several times:var floor = Math.floor;\nvar x = floor(\"1000.01\");\nvar floor = Math.floor;\nvar x = floor(\"1000.01\");\nparseFloat()If you're the type who forgets to put the radix in when you call parseInt, you can use parseFloat and round it however you like. Here I use floor.var floor = Math.floor;\nvar x = floor(parseFloat(\"1000.01\"));\nvar floor = Math.floor;\nvar x = floor(parseFloat(\"1000.01\"));\nround()Interestingly, Math.round (like Math.floor) will do a string to number conversion, so if you want the number rounded (or if you have an integer in the string), this is a great way, maybe my favorite:var round = Math.round;\nvar x = round(\"1000\"); // Equivalent to round(\"1000\", 0)\nvar round = Math.round;\nvar x = round(\"1000\"); // Equivalent to round(\"1000\", 0)\n",
                "Try parseInt function:var number = parseInt(\"10\");\nvar number = parseInt(\"10\");\nBut there is a problem. If you try to convert \"010\" using parseInt function, it detects as octal number, and will return number 8. So, you need to specify a radix (from 2 to 36). In this case base 10.parseInt(string, radix)\nparseInt(string, radix)\nExample:var result = parseInt(\"010\", 10) == 10; // Returns true\n\nvar result = parseInt(\"010\") == 10; // Returns false\nvar result = parseInt(\"010\", 10) == 10; // Returns true\n\nvar result = parseInt(\"010\") == 10; // Returns false\nNote that parseInt ignores bad data after parsing anything valid.\nThis guid will parse as 51:parseIntvar result = parseInt('51e3daf6-b521-446a-9f5b-a1bb4d8bac36', 10) == 51; // Returns true\nvar result = parseInt('51e3daf6-b521-446a-9f5b-a1bb4d8bac36', 10) == 51; // Returns true\n",
                "There are two main ways to convert a string to a number in JavaScript.  One way is to parse it and the other way is to change its type to a Number.  All of the tricks in the other answers (e.g., unary plus) involve implicitly coercing the type of the string to a number.  You can also do the same thing explicitly with the Number function.ParsingParsingvar parsed = parseInt(\"97\", 10);\nvar parsed = parseInt(\"97\", 10);\nparseInt and parseFloat are the two functions used for parsing strings to numbers.  Parsing will stop silently if it hits a character it doesn't recognise, which can be useful for parsing strings like \"92px\", but it's also somewhat dangerous, since it won't give you any kind of error on bad input, instead you'll get back NaN unless the string starts with a number. Whitespace at the beginning of the string is ignored.  Here's an example of it doing something different to what you want, and giving no indication that anything went wrong:var widgetsSold = parseInt(\"97,800\", 10); // widgetsSold is now 97\nvar widgetsSold = parseInt(\"97,800\", 10); // widgetsSold is now 97\nIt's good practice to always specify the radix as the second argument.  In older browsers, if the string started with a 0, it would be interpreted as octal if the radix wasn't specified which took a lot of people by surprise.  The behaviour for hexadecimal is triggered by having the string start with 0x if no radix is specified, e.g., 0xff. The standard actually changed with ECMAScript\u00a05, so modern browsers no longer trigger octal when there's a leading 0 if no radix has been specified.  parseInt understands radixes up to base 36, in which case both upper and lower case letters are treated as equivalent.0xffECMAScript\u00a05Changing the Type of a String to a NumberChanging the Type of a String to a NumberAll of the other tricks mentioned above that don't use parseInt, involve implicitly coercing the string into a number.  I prefer to do this explicitly,var cast = Number(\"97\");\nvar cast = Number(\"97\");\nThis has different behavior to the parse methods (although it still ignores whitespace).  It's more strict: if it doesn't understand the whole of the string than it returns NaN, so you can't use it for strings like 97px.  Since you want a primitive number rather than a Number wrapper object, make sure you don't put new in front of the Number function.NaN97pxnewObviously, converting to a Number gives you a value that might be a float rather than an integer, so if you want an integer, you need to modify it.  There are a few ways of doing this:var rounded = Math.floor(Number(\"97.654\"));  // other options are Math.ceil, Math.round\nvar fixed = Number(\"97.654\").toFixed(0); // rounded rather than truncated\nvar bitwised = Number(\"97.654\")|0;  // do not use for large numbers\nvar rounded = Math.floor(Number(\"97.654\"));  // other options are Math.ceil, Math.round\nvar fixed = Number(\"97.654\").toFixed(0); // rounded rather than truncated\nvar bitwised = Number(\"97.654\")|0;  // do not use for large numbers\nAny bitwise operator (here I've done a bitwise or, but you could also do double negation as in an earlier answer or a bit shift) will convert the value to a 32 bit integer, and most of them will convert to a signed integer.  Note that this will not do want you want for large integers.  If the integer cannot be represented in 32 bits, it will wrap.will not do want you want for large integers~~\"3000000000.654\" === -1294967296\n// This is the same as\nNumber(\"3000000000.654\")|0\n\"3000000000.654\" >>> 0 === 3000000000 // unsigned right shift gives you an extra bit\n\"300000000000.654\" >>> 0 === 3647256576 // but still fails with larger numbers\n~~\"3000000000.654\" === -1294967296\n// This is the same as\nNumber(\"3000000000.654\")|0\n\"3000000000.654\" >>> 0 === 3000000000 // unsigned right shift gives you an extra bit\n\"300000000000.654\" >>> 0 === 3647256576 // but still fails with larger numbers\nTo work correctly with larger numbers, you should use the rounding methodsMath.floor(\"3000000000.654\") === 3000000000\n// This is the same as\nMath.floor(Number(\"3000000000.654\"))\nMath.floor(\"3000000000.654\") === 3000000000\n// This is the same as\nMath.floor(Number(\"3000000000.654\"))\nBear in mind that coercion understands exponential notation and Infinity, so 2e2 is 200 rather than NaN, while the parse methods don't.2e2200CustomCustomIt's unlikely that either of these methods do exactly what you want.  For example, usually I would want an error thrown if parsing fails, and I don't need support for Infinity, exponentials or leading whitespace.  Depending on your use case, sometimes it makes sense to write a custom conversion function.Always check that the output of Number or one of the parse methods is the sort of number you expect.  You will almost certainly want to use isNaN to make sure the number is not NaN (usually the only way you find out that the parse failed).isNaN",
                "ParseInt() and + are differentparseInt(\"10.3456\") // returns 10\n\n+\"10.3456\" // returns 10.3456\nparseInt(\"10.3456\") // returns 10\n\n+\"10.3456\" // returns 10.3456\n",
                "Fastestvar x = \"1000\"*1;\nvar x = \"1000\"*1;\nTestHere is little comparison of speed (macOS only)... :)For Chrome, 'plus' and 'mul' are fastest (>700,000,00 op/sec), 'Math.floor' is slowest. For Firefox, 'plus' is slowest (!) 'mul' is fastest (>900,000,000 op/sec). In Safari 'parseInt' is fastest, 'number' is slowest (but results are quite similar, >13,000,000  <31,000,000). So Safari for cast string to int is more than 10x slower than other browsers. So the winner is 'mul' :)mulYou can run it on your browser by this link\nhttps://jsperf.com/js-cast-str-to-number/1https://jsperf.com/js-cast-str-to-number/1I also tested var x = ~~\"1000\";. On Chrome and Safari, it is a little bit slower than var x = \"1000\"*1 (<1%), and on Firefox it is a little bit faster (<1%).var x = ~~\"1000\";var x = \"1000\"*1",
                "I use this way of converting string to number:var str = \"25\";       // String\nvar number = str*1;   // Number\nvar str = \"25\";       // String\nvar number = str*1;   // Number\nSo, when multiplying by 1, the value does not change, but JavaScript automatically returns a number.But as it is shown below, this should be used if you are sure that the str is a number (or can be represented as a number), otherwise it will return NaN - not a number.strNaNYou can create simple function to use, e.g.,function toNumber(str) {\n    return str*1;\n}\nfunction toNumber(str) {\n    return str*1;\n}\n",
                "Try parseInt.var number = parseInt(\"10\", 10); //number will have value of 10.\nvar number = parseInt(\"10\", 10); //number will have value of 10.\n",
                "I love this trick:~~\"2.123\"; //2\n~~\"5\"; //5\n~~\"2.123\"; //2\n~~\"5\"; //5\nThe double bitwise negative drops off anything after the decimal point AND converts it to a number format. I've been told it's slightly faster than calling functions and whatnot, but I'm not entirely convinced.Another method I just saw here (a question about the JavaScript >>> operator, which is a zero-fill right shift) which shows that shifting a number by 0 with this operator converts the number to a uint32 which is nice if you also want it unsigned.  Again, this converts to an unsigned integer, which can lead to strange behaviors if you use a signed number.hereuint32unsignedunsigned integer\"-2.123\" >>> 0; // 4294967294\n\"2.123\" >>> 0; // 2\n\"-5\" >>> 0; // 4294967291\n\"5\" >>> 0; // 5\n\"-2.123\" >>> 0; // 4294967294\n\"2.123\" >>> 0; // 2\n\"-5\" >>> 0; // 4294967291\n\"5\" >>> 0; // 5\n",
                "In JavaScript, you can do the following:ParseIntparseInt(\"10.5\") // Returns 10\nparseInt(\"10.5\") // Returns 10\nMultiplying with 1var s = \"10\";\ns = s*1;  // Returns 10\nvar s = \"10\";\ns = s*1;  // Returns 10\nUsing the unary operator (+)var s = \"10\";\ns = +s;  // Returns 10\nvar s = \"10\";\ns = +s;  // Returns 10\nUsing a bitwise operator(Note: It starts to break after 2140000000. Example: ~~\"2150000000\" = -2144967296)2140000000~~\"2150000000\" = -2144967296var s = \"10.5\";\ns = ~~s; // Returns 10\nvar s = \"10.5\";\ns = ~~s; // Returns 10\nUsing Math.floor() or Math.ceil()var s = \"10\";\ns = Math.floor(s) || Math.ceil(s); // Returns 10\nvar s = \"10\";\ns = Math.floor(s) || Math.ceil(s); // Returns 10\n",
                "Beware if you use parseInt to convert a float in scientific notation!\nFor example:parseInt(\"5.6e-14\") \nparseInt(\"5.6e-14\") \nwill result in5 \n5 \ninstead of0\n0\n",
                "Please see the below example. It will help answer your question.Example                  Result\n\nparseInt(\"4\")            4\nparseInt(\"5aaa\")         5\nparseInt(\"4.33333\")      4\nparseInt(\"aaa\");         NaN (means \"Not a Number\")\nExample                  Result\n\nparseInt(\"4\")            4\nparseInt(\"5aaa\")         5\nparseInt(\"4.33333\")      4\nparseInt(\"aaa\");         NaN (means \"Not a Number\")\nBy using parseint function, it will only give op of integer present and not the string.",
                "Also as a side note: MooTools has the function toInt() which is used on any native string (or float (or integer)).MooTools\"2\".toInt()   // 2\n\"2px\".toInt() // 2\n2.toInt()     // 2\n\"2\".toInt()   // 2\n\"2px\".toInt() // 2\n2.toInt()     // 2\n",
                "We can use +(stringOfNumber) instead of using parseInt(stringOfNumber).+(stringOfNumber)parseInt(stringOfNumber)Example: +(\"21\") returns int of 21, like the parseInt(\"21\").+(\"21\")parseInt(\"21\")We can use this unary \"+\" operator for parsing float too...",
                "To convert a String into Integer, I recommend using parseFloat and not parseInt. Here's why:notnotUsing parseFloat:Using parseFloat:parseFloat('2.34cms')  //Output: 2.34\nparseFloat('12.5')     //Output: 12.5\nparseFloat('012.3')    //Output: 12.3\nparseFloat('2.34cms')  //Output: 2.34\nparseFloat('12.5')     //Output: 12.5\nparseFloat('012.3')    //Output: 12.3\nUsing parseInt:Using parseInt:parseInt('2.34cms')  //Output: 2\nparseInt('12.5')     //Output: 12\nparseInt('012.3')    //Output: 12\nparseInt('2.34cms')  //Output: 2\nparseInt('12.5')     //Output: 12\nparseInt('012.3')    //Output: 12\nSo if you have noticed parseInt discards the values after the decimals, whereas parseFloat lets you work with floating point numbers and hence more suitable if you want to retain the values after decimals. Use parseInt if and only if you are sure that you want the integer value.",
                "There are many ways in JavaScript to convert a string to a number value... All are simple and handy. Choose the way which one works for you:var num = Number(\"999.5\"); //999.5\nvar num = parseInt(\"999.5\", 10); //999\nvar num = parseFloat(\"999.5\"); //999.5\nvar num = +\"999.5\"; //999.5\nvar num = Number(\"999.5\"); //999.5\nvar num = parseInt(\"999.5\", 10); //999\nvar num = parseFloat(\"999.5\"); //999.5\nvar num = +\"999.5\"; //999.5\nAlso, any Math operation converts them to number, for example...Mathvar num = \"999.5\" / 1; //999.5\nvar num = \"999.5\" * 1; //999.5\nvar num = \"999.5\" - 1 + 1; //999.5\nvar num = \"999.5\" - 0; //999.5\nvar num = Math.floor(\"999.5\"); //999\nvar num = ~~\"999.5\"; //999\nvar num = \"999.5\" / 1; //999.5\nvar num = \"999.5\" * 1; //999.5\nvar num = \"999.5\" - 1 + 1; //999.5\nvar num = \"999.5\" - 0; //999.5\nvar num = Math.floor(\"999.5\"); //999\nvar num = ~~\"999.5\"; //999\nMy prefer way is using + sign, which is the elegant way to convert a string to number in JavaScript.+",
                "Try str - 0 to convert string to number.str - 0stringnumber> str = '0'\n> str - 0\n  0\n> str = '123'\n> str - 0\n  123\n> str = '-12'\n> str - 0\n  -12\n> str = 'asdf'\n> str - 0\n  NaN\n> str = '12.34'\n> str - 0\n  12.34\n> str = '0'\n> str - 0\n  0\n> str = '123'\n> str - 0\n  123\n> str = '-12'\n> str - 0\n  -12\n> str = 'asdf'\n> str - 0\n  NaN\n> str = '12.34'\n> str - 0\n  12.34\nHere are two links to compare the performance of several ways to convert string to inthttps://jsperf.com/number-vs-parseint-vs-plushttps://jsperf.com/number-vs-parseint-vs-plushttp://phrogz.net/js/string_to_number.htmlhttp://phrogz.net/js/string_to_number.html",
                "Here is the easiest solutionHere is the easiest solutionlet myNumber = \"123\" | 0;\nlet myNumber = \"123\" | 0;\nMore easy solutionMore easy solutionlet myNumber = +\"123\";\nlet myNumber = +\"123\";\n",
                "In my opinion, no answer covers all edge cases as parsing a float should result in an error.function parseInteger(value) {\n    if(value === '') return NaN;\n    const number = Number(value);\n    return Number.isInteger(number) ? number : NaN;\n}\nfunction parseInteger(value) {\n    if(value === '') return NaN;\n    const number = Number(value);\n    return Number.isInteger(number) ? number : NaN;\n}\nparseInteger(\"4\")            // 4\nparseInteger(\"5aaa\")         // NaN\nparseInteger(\"4.33333\")      // NaN\nparseInteger(\"aaa\");         // NaN\nparseInteger(\"4\")            // 4\nparseInteger(\"5aaa\")         // NaN\nparseInteger(\"4.33333\")      // NaN\nparseInteger(\"aaa\");         // NaN\n",
                "The easiest way would be to use + like this+const strTen = \"10\"\nconst numTen = +strTen      // string to number conversion\nconsole.log(typeof strTen)  // string\nconsole.log(typeof numTen)  // number\nconst strTen = \"10\"\nconst numTen = +strTen      // string to number conversion\nconsole.log(typeof strTen)  // string\nconsole.log(typeof numTen)  // number\n",
                "I actually needed to \"save\" a string as an integer, for a binding between C and JavaScript, so I convert the string into an integer value:/*\n    Examples:\n        int2str( str2int(\"test\") ) == \"test\" // true\n        int2str( str2int(\"t\u20acst\") ) // \"t\u00acst\", because \"\u20ac\".charCodeAt(0) is 8364, will be AND'ed with 0xff\n    Limitations:\n        maximum 4 characters, so it fits into an integer\n*/\nfunction str2int(the_str) {\n    var ret = 0;\n    var len = the_str.length;\n    if (len >= 1) ret += (the_str.charCodeAt(0) & 0xff) <<  0;\n    if (len >= 2) ret += (the_str.charCodeAt(1) & 0xff) <<  8;\n    if (len >= 3) ret += (the_str.charCodeAt(2) & 0xff) << 16;\n    if (len >= 4) ret += (the_str.charCodeAt(3) & 0xff) << 24;\n    return ret;\n}\n\nfunction int2str(the_int) {\n    var tmp = [\n        (the_int & 0x000000ff) >>  0,\n        (the_int & 0x0000ff00) >>  8,\n        (the_int & 0x00ff0000) >> 16,\n        (the_int & 0xff000000) >> 24\n    ];\n    var ret = \"\";\n    for (var i=0; i<4; i++) {\n        if (tmp[i] == 0)\n            break;\n        ret += String.fromCharCode(tmp[i]);\n    }\n    return ret;\n}\n/*\n    Examples:\n        int2str( str2int(\"test\") ) == \"test\" // true\n        int2str( str2int(\"t\u20acst\") ) // \"t\u00acst\", because \"\u20ac\".charCodeAt(0) is 8364, will be AND'ed with 0xff\n    Limitations:\n        maximum 4 characters, so it fits into an integer\n*/\nfunction str2int(the_str) {\n    var ret = 0;\n    var len = the_str.length;\n    if (len >= 1) ret += (the_str.charCodeAt(0) & 0xff) <<  0;\n    if (len >= 2) ret += (the_str.charCodeAt(1) & 0xff) <<  8;\n    if (len >= 3) ret += (the_str.charCodeAt(2) & 0xff) << 16;\n    if (len >= 4) ret += (the_str.charCodeAt(3) & 0xff) << 24;\n    return ret;\n}\n\nfunction int2str(the_int) {\n    var tmp = [\n        (the_int & 0x000000ff) >>  0,\n        (the_int & 0x0000ff00) >>  8,\n        (the_int & 0x00ff0000) >> 16,\n        (the_int & 0xff000000) >> 24\n    ];\n    var ret = \"\";\n    for (var i=0; i<4; i++) {\n        if (tmp[i] == 0)\n            break;\n        ret += String.fromCharCode(tmp[i]);\n    }\n    return ret;\n}\n",
                "String to Number in JavaScript:Unary + (most recommended)\n+numStr is easy to use and has better performance compared with others\nSupports both integers and decimals\n+numStr is easy to use and has better performance compared with others+numStrSupports both integers and decimalsconsole.log(+'123.45') // => 123.45\nconsole.log(+'123.45') // => 123.45\nSome other options:Parsing Strings:\nparseInt(numStr) for integers\nparseFloat(numStr) for both integers and decimals\nparseInt(numStr) for integersparseInt(numStr)parseFloat(numStr) for both integers and decimalsparseFloat(numStr)console.log(parseInt('123.456')) // => 123\nconsole.log(parseFloat('123'))   // => 123\nconsole.log(parseInt('123.456')) // => 123\nconsole.log(parseFloat('123'))   // => 123\nJavaScript Functions\nMath functions like round(numStr), floor(numStr), ceil(numStr) for integers\n\nNumber(numStr) for both integers and decimals\n\nMath functions like round(numStr), floor(numStr), ceil(numStr) for integers\nMath functions like round(numStr), floor(numStr), ceil(numStr) for integersround(numStr), floor(numStr), ceil(numStr)Number(numStr) for both integers and decimals\nNumber(numStr) for both integers and decimalsNumber(numStr)console.log(Math.floor('123'))     // => 123\nconsole.log(Math.round('123.456')) // => 123\nconsole.log(Math.ceil('123.454'))  // => 124\nconsole.log(Number('123.123'))     // => 123.123\nconsole.log(Math.floor('123'))     // => 123\nconsole.log(Math.round('123.456')) // => 123\nconsole.log(Math.ceil('123.454'))  // => 124\nconsole.log(Number('123.123'))     // => 123.123\nUnary Operators\nAll basic unary operators, +numStr, numStr-0, 1*numStr, numStr*1, and numStr/1\n\nAll support both integers and decimals\n\nBe cautious about numStr+0. It returns a string.\n\nAll basic unary operators, +numStr, numStr-0, 1*numStr, numStr*1, and numStr/1\nAll basic unary operators, +numStr, numStr-0, 1*numStr, numStr*1, and numStr/1+numStrnumStr-01*numStrnumStr*1numStr/1All support both integers and decimals\nAll support both integers and decimalsBe cautious about numStr+0. It returns a string.\nBe cautious about numStr+0. It returns a string.numStr+0console.log(+'123')  // => 123\nconsole.log('002'-0) // => 2\nconsole.log(1*'5')   // => 5\nconsole.log('7.7'*1) // => 7.7\nconsole.log(3.3/1)   // =>3.3\nconsole.log('123.123'+0, typeof ('123.123' + 0)) // => 123.1230 string\nconsole.log(+'123')  // => 123\nconsole.log('002'-0) // => 2\nconsole.log(1*'5')   // => 5\nconsole.log('7.7'*1) // => 7.7\nconsole.log(3.3/1)   // =>3.3\nconsole.log('123.123'+0, typeof ('123.123' + 0)) // => 123.1230 string\nBitwise Operators\nTwo tilde ~~numStr or left shift 0, numStr<<0\nSupports only integers, but not decimals\nTwo tilde ~~numStr or left shift 0, numStr<<0~~numStrnumStr<<0Supports only integers, but not decimalsconsole.log(~~'123')      // => 123\nconsole.log('0123'<<0)    // => 123\nconsole.log(~~'123.123')  // => 123\nconsole.log('123.123'<<0) // => 123\nconsole.log(~~'123')      // => 123\nconsole.log('0123'<<0)    // => 123\nconsole.log(~~'123.123')  // => 123\nconsole.log('123.123'<<0) // => 123\n\n\n// Parsing\nconsole.log(parseInt('123.456')) // => 123\nconsole.log(parseFloat('123'))   // => 123\n\n// Function\nconsole.log(Math.floor('123'))     // => 123\nconsole.log(Math.round('123.456')) // => 123\nconsole.log(Math.ceil('123.454'))  // => 124\nconsole.log(Number('123.123'))     // => 123.123\n\n// Unary\nconsole.log(+'123')  // => 123\nconsole.log('002'-0) // => 2\nconsole.log(1*'5')   // => 5\nconsole.log('7.7'*1) // => 7.7\nconsole.log(3.3/1)   // => 3.3\nconsole.log('123.123'+0, typeof ('123.123'+0)) // => 123.1230 string\n\n// Bitwise\nconsole.log(~~'123')      // => 123\nconsole.log('0123'<<0)    // => 123\nconsole.log(~~'123.123')  // => 123\nconsole.log('123.123'<<0) // => 123\n\n\n\n\n// Parsing\nconsole.log(parseInt('123.456')) // => 123\nconsole.log(parseFloat('123'))   // => 123\n\n// Function\nconsole.log(Math.floor('123'))     // => 123\nconsole.log(Math.round('123.456')) // => 123\nconsole.log(Math.ceil('123.454'))  // => 124\nconsole.log(Number('123.123'))     // => 123.123\n\n// Unary\nconsole.log(+'123')  // => 123\nconsole.log('002'-0) // => 2\nconsole.log(1*'5')   // => 5\nconsole.log('7.7'*1) // => 7.7\nconsole.log(3.3/1)   // => 3.3\nconsole.log('123.123'+0, typeof ('123.123'+0)) // => 123.1230 string\n\n// Bitwise\nconsole.log(~~'123')      // => 123\nconsole.log('0123'<<0)    // => 123\nconsole.log(~~'123.123')  // => 123\nconsole.log('123.123'<<0) // => 123\n\n\n// Parsing\nconsole.log(parseInt('123.456')) // => 123\nconsole.log(parseFloat('123'))   // => 123\n\n// Function\nconsole.log(Math.floor('123'))     // => 123\nconsole.log(Math.round('123.456')) // => 123\nconsole.log(Math.ceil('123.454'))  // => 124\nconsole.log(Number('123.123'))     // => 123.123\n\n// Unary\nconsole.log(+'123')  // => 123\nconsole.log('002'-0) // => 2\nconsole.log(1*'5')   // => 5\nconsole.log('7.7'*1) // => 7.7\nconsole.log(3.3/1)   // => 3.3\nconsole.log('123.123'+0, typeof ('123.123'+0)) // => 123.1230 string\n\n// Bitwise\nconsole.log(~~'123')      // => 123\nconsole.log('0123'<<0)    // => 123\nconsole.log(~~'123.123')  // => 123\nconsole.log('123.123'<<0) // => 123\n// Parsing\nconsole.log(parseInt('123.456')) // => 123\nconsole.log(parseFloat('123'))   // => 123\n\n// Function\nconsole.log(Math.floor('123'))     // => 123\nconsole.log(Math.round('123.456')) // => 123\nconsole.log(Math.ceil('123.454'))  // => 124\nconsole.log(Number('123.123'))     // => 123.123\n\n// Unary\nconsole.log(+'123')  // => 123\nconsole.log('002'-0) // => 2\nconsole.log(1*'5')   // => 5\nconsole.log('7.7'*1) // => 7.7\nconsole.log(3.3/1)   // => 3.3\nconsole.log('123.123'+0, typeof ('123.123'+0)) // => 123.1230 string\n\n// Bitwise\nconsole.log(~~'123')      // => 123\nconsole.log('0123'<<0)    // => 123\nconsole.log(~~'123.123')  // => 123\nconsole.log('123.123'<<0) // => 123// Parsing\nconsole.log(parseInt('123.456')) // => 123\nconsole.log(parseFloat('123'))   // => 123\n\n// Function\nconsole.log(Math.floor('123'))     // => 123\nconsole.log(Math.round('123.456')) // => 123\nconsole.log(Math.ceil('123.454'))  // => 124\nconsole.log(Number('123.123'))     // => 123.123\n\n// Unary\nconsole.log(+'123')  // => 123\nconsole.log('002'-0) // => 2\nconsole.log(1*'5')   // => 5\nconsole.log('7.7'*1) // => 7.7\nconsole.log(3.3/1)   // => 3.3\nconsole.log('123.123'+0, typeof ('123.123'+0)) // => 123.1230 string\n\n// Bitwise\nconsole.log(~~'123')      // => 123\nconsole.log('0123'<<0)    // => 123\nconsole.log(~~'123.123')  // => 123\nconsole.log('123.123'<<0) // => 123",
                "function parseIntSmarter(str) {\n    // ParseInt is bad because it returns 22 for \"22thisendsintext\"\n    // Number() is returns NaN if it ends in non-numbers, but it returns 0 for empty or whitespace strings.\n    return isNaN(Number(str)) ? NaN : parseInt(str, 10);\n}\nfunction parseIntSmarter(str) {\n    // ParseInt is bad because it returns 22 for \"22thisendsintext\"\n    // Number() is returns NaN if it ends in non-numbers, but it returns 0 for empty or whitespace strings.\n    return isNaN(Number(str)) ? NaN : parseInt(str, 10);\n}\n",
                "You can use plus.\nFor example:var personAge = '24';\nvar personAge1 = (+personAge)\nvar personAge = '24';\nvar personAge1 = (+personAge)\nthen you can see the new variable's type bytypeof personAge1 ; which is number.typeof personAge1number",
                "Summing the multiplication of digits with their respective power of ten:i.e: 123 = 100+20+3 = 1100 + 2+10 + 31 = 1*(10^2) + 2*(10^1) + 3*(10^0)100 + 2+10 + 3function atoi(array) {\n\n    // Use exp as (length - i), other option would be\n    // to reverse the array.\n    // Multiply a[i] * 10^(exp) and sum\n\n    let sum = 0;\n\n    for (let i = 0; i < array.length; i++) {\n        let exp = array.length - (i+1);\n        let value = array[i] * Math.pow(10, exp);\n        sum += value;\n    }\n\n    return sum;\n}\nfunction atoi(array) {\n\n    // Use exp as (length - i), other option would be\n    // to reverse the array.\n    // Multiply a[i] * 10^(exp) and sum\n\n    let sum = 0;\n\n    for (let i = 0; i < array.length; i++) {\n        let exp = array.length - (i+1);\n        let value = array[i] * Math.pow(10, exp);\n        sum += value;\n    }\n\n    return sum;\n}\n",
                "The safest way to ensure you get a valid integer:let integer = (parseInt(value, 10) || 0);\nlet integer = (parseInt(value, 10) || 0);\nExamples:// Example 1 - Invalid value:\nlet value = null;\nlet integer = (parseInt(value, 10) || 0);\n// => integer = 0\n// Example 1 - Invalid value:\nlet value = null;\nlet integer = (parseInt(value, 10) || 0);\n// => integer = 0\n// Example 2 - Valid value:\nlet value = \"1230.42\";\nlet integer = (parseInt(value, 10) || 0);\n// => integer = 1230\n// Example 2 - Valid value:\nlet value = \"1230.42\";\nlet integer = (parseInt(value, 10) || 0);\n// => integer = 1230\n// Example 3 - Invalid value:\nlet value = () => { return 412 };\nlet integer = (parseInt(value, 10) || 0);\n// => integer = 0\n// Example 3 - Invalid value:\nlet value = () => { return 412 };\nlet integer = (parseInt(value, 10) || 0);\n// => integer = 0\n",
                "Another option is to double XOR the value with itself:var i = 12.34;\nconsole.log('i = ' + i);\nconsole.log('i \u2295 i \u2295 i = ' + (i ^ i ^ i));\nvar i = 12.34;\nconsole.log('i = ' + i);\nconsole.log('i \u2295 i \u2295 i = ' + (i ^ i ^ i));\nThis will output:i = 12.34\ni \u2295 i \u2295 i = 12\ni = 12.34\ni \u2295 i \u2295 i = 12\n",
                "I only added one plus(+) before string and that was solution!+\"052254\" // 52254\n+\"052254\" // 52254\n",
                "Number()Number(\" 200.12 \")  // Returns 200.12\n\nNumber(\"200.12\")  // Returns 200.12\n\nNumber(\"200\") // Returns 200\nNumber(\" 200.12 \")  // Returns 200.12\n\nNumber(\"200.12\")  // Returns 200.12\n\nNumber(\"200\") // Returns 200\nparseInt()parseInt(\" 200.12 \")  // Return 200\n\nparseInt(\"200.12\")  // Return 200\n\nparseInt(\"200\") // Return 200\n\nparseInt(\"Text information\") // Returns NaN\nparseInt(\" 200.12 \")  // Return 200\n\nparseInt(\"200.12\")  // Return 200\n\nparseInt(\"200\") // Return 200\n\nparseInt(\"Text information\") // Returns NaN\nparseFloat()It will return the first numberparseFloat(\"200 400\")  // Returns 200\n\nparseFloat(\"200\") // Returns 200\n\nparseFloat(\"Text information\") // Returns NaN\n\nparseFloat(\"200.10\")  // Return 200.10\nparseFloat(\"200 400\")  // Returns 200\n\nparseFloat(\"200\") // Returns 200\n\nparseFloat(\"Text information\") // Returns NaN\n\nparseFloat(\"200.10\")  // Return 200.10\nMath.floor()Round a number to the nearest integerMath.floor(\" 200.12 \")  // Return 200\n\nMath.floor(\"200.12\")  // Return 200\n\nMath.floor(\"200\") // Return 200\nMath.floor(\" 200.12 \")  // Return 200\n\nMath.floor(\"200.12\")  // Return 200\n\nMath.floor(\"200\") // Return 200\n",
                "\n\nfunction doSth(){\r\n  var a = document.getElementById('input').value;\r\n  document.getElementById('number').innerHTML = toNumber(a) + 1;\r\n}\r\nfunction toNumber(str){\r\n  return +str;\r\n}\n<input id=\"input\" type=\"text\">\r\n<input onclick=\"doSth()\" type=\"submit\">\r\n<span id=\"number\"></span>\n\n\n\n\nfunction doSth(){\r\n  var a = document.getElementById('input').value;\r\n  document.getElementById('number').innerHTML = toNumber(a) + 1;\r\n}\r\nfunction toNumber(str){\r\n  return +str;\r\n}\n<input id=\"input\" type=\"text\">\r\n<input onclick=\"doSth()\" type=\"submit\">\r\n<span id=\"number\"></span>\n\n\nfunction doSth(){\r\n  var a = document.getElementById('input').value;\r\n  document.getElementById('number').innerHTML = toNumber(a) + 1;\r\n}\r\nfunction toNumber(str){\r\n  return +str;\r\n}\n<input id=\"input\" type=\"text\">\r\n<input onclick=\"doSth()\" type=\"submit\">\r\n<span id=\"number\"></span>\nfunction doSth(){\r\n  var a = document.getElementById('input').value;\r\n  document.getElementById('number').innerHTML = toNumber(a) + 1;\r\n}\r\nfunction toNumber(str){\r\n  return +str;\r\n}function doSth(){\r\n  var a = document.getElementById('input').value;\r\n  document.getElementById('number').innerHTML = toNumber(a) + 1;\r\n}\r\nfunction toNumber(str){\r\n  return +str;\r\n}<input id=\"input\" type=\"text\">\r\n<input onclick=\"doSth()\" type=\"submit\">\r\n<span id=\"number\"></span><input id=\"input\" type=\"text\">\r\n<input onclick=\"doSth()\" type=\"submit\">\r\n<span id=\"number\"></span>",
                "This (probably) isn't the best solution for parsing an integer, but if you need to \"extract\" one, for example:parsing\"1a2b3c\" === 123\n\"198some text2hello world!30\" === 198230\n// ...\n\"1a2b3c\" === 123\n\"198some text2hello world!30\" === 198230\n// ...\nthis would work (only for integers):\n\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (!isNaN(str[i - 1])) {\n      result += parseInt(str[i - 1]) * factor\n      factor *= 10\n    }\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))\n\n\n\n\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (!isNaN(str[i - 1])) {\n      result += parseInt(str[i - 1]) * factor\n      factor *= 10\n    }\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))\n\n\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (!isNaN(str[i - 1])) {\n      result += parseInt(str[i - 1]) * factor\n      factor *= 10\n    }\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (!isNaN(str[i - 1])) {\n      result += parseInt(str[i - 1]) * factor\n      factor *= 10\n    }\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))var str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (!isNaN(str[i - 1])) {\n      result += parseInt(str[i - 1]) * factor\n      factor *= 10\n    }\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))Of course, this would also work for parsing an integer, but would be slower than other methods.You could also parse integers with this method and return NaN if the string isn't a number, but I don't see why you'd want to since this relies on parseInt internally and parseInt is probably faster.NaNparseIntparseInt\n\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (isNaN(str[i - 1])) return NaN\n    result += parseInt(str[i - 1]) * factor\n    factor *= 10\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))\n\n\n\n\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (isNaN(str[i - 1])) return NaN\n    result += parseInt(str[i - 1]) * factor\n    factor *= 10\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))\n\n\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (isNaN(str[i - 1])) return NaN\n    result += parseInt(str[i - 1]) * factor\n    factor *= 10\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))\nvar str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (isNaN(str[i - 1])) return NaN\n    result += parseInt(str[i - 1]) * factor\n    factor *= 10\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))var str = '3a9b0c3d2e9f8g'\n\nfunction extractInteger(str) {\n  var result = 0;\n  var factor = 1\n\n  for (var i = str.length; i > 0; i--) {\n    if (isNaN(str[i - 1])) return NaN\n    result += parseInt(str[i - 1]) * factor\n    factor *= 10\n  }\n\n  return result\n}\n\nconsole.log(extractInteger(str))"
            ]
        },
        {
            "tag": "c++",
            "patterns": [
                "Easiest way to convert int to string in C++",
                "Easiest way to convert int to string in C++"
            ],
            "responses": [
                "C++11 introduces std::stoi (and variants for each numeric type) and std::to_string, the counterparts of the C atoi and itoa but expressed in term of std::string.std::stoistd::stoistd::to_stringstd::to_stringatoiitoastd::string#include <string> \n\nstd::string s = std::to_string(42);\n#include <string> \n\nstd::string s = std::to_string(42);\nis therefore the shortest way I can think of. You can even omit naming the type, using the auto keyword:autoauto s = std::to_string(42);\nauto s = std::to_string(42);\nNote: see [string.conversions] (21.5 in n3242)Note: see [string.conversions] (21.5 in n3242)[string.conversions]21.5n3242",
                "C++20: std::format would be the idiomatic way now.C++20:std::formatC++17:C++17:Picking up a discussion with @v.oddou a couple of years later, C++17 has delivered a way to do the originally macro-based type-agnostic solution (preserved below) without going through macro ugliness.without// variadic template\ntemplate < typename... Args >\nstd::string sstr( Args &&... args )\n{\n    std::ostringstream sstr;\n    // fold expression\n    ( sstr << std::dec << ... << args );\n    return sstr.str();\n}\n// variadic template\ntemplate < typename... Args >\nstd::string sstr( Args &&... args )\n{\n    std::ostringstream sstr;\n    // fold expression\n    ( sstr << std::dec << ... << args );\n    return sstr.str();\n}\nUsage:int i = 42;\nstd::string s = sstr( \"i is: \", i );\nputs( sstr( i ).c_str() );\n\nFoo x( 42 );\nthrow std::runtime_error( sstr( \"Foo is '\", x, \"', i is \", i ) );\nint i = 42;\nstd::string s = sstr( \"i is: \", i );\nputs( sstr( i ).c_str() );\n\nFoo x( 42 );\nthrow std::runtime_error( sstr( \"Foo is '\", x, \"', i is \", i ) );\nC++98:C++98:Since \"converting ... to string\" is a recurring problem, I always define the SSTR() macro in a central header of my C++ sources:SSTR()#include <sstream>\n\n#define SSTR( x ) static_cast< std::ostringstream & >( \\\n        ( std::ostringstream() << std::dec << x ) ).str()\n#include <sstream>\n\n#define SSTR( x ) static_cast< std::ostringstream & >( \\\n        ( std::ostringstream() << std::dec << x ) ).str()\nUsage is as easy as could be:int i = 42;\nstd::string s = SSTR( \"i is: \" << i );\nputs( SSTR( i ).c_str() );\n\nFoo x( 42 );\nthrow std::runtime_error( SSTR( \"Foo is '\" << x << \"', i is \" << i ) );\nint i = 42;\nstd::string s = SSTR( \"i is: \" << i );\nputs( SSTR( i ).c_str() );\n\nFoo x( 42 );\nthrow std::runtime_error( SSTR( \"Foo is '\" << x << \"', i is \" << i ) );\nThe above is C++98 compatible (if you cannot use C++11 std::to_string), and does not need any third-party includes (if you cannot use Boost lexical_cast<>); both these other solutions have a better performance though.std::to_stringlexical_cast<>",
                "Current C++Starting with C++11, there's a std::to_string function overloaded for integer types, so you can use code like:std::to_stringint a = 20;\nstd::string s = std::to_string(a);\n// or: auto s = std::to_string(a);\nint a = 20;\nstd::string s = std::to_string(a);\n// or: auto s = std::to_string(a);\nThe standard defines these as being equivalent to doing the conversion with sprintf (using the conversion specifier that matches the supplied type of object, such as %d for int), into a buffer of sufficient size, then creating an std::string of the contents of that buffer.sprintf%dintstd::stringOld C++For older (pre-C++11) compilers, probably the most common easy way wraps essentially your second choice into a template that's usually named lexical_cast, such as the one in Boost, so your code looks like this:lexical_castBoostint a = 10;\nstring s = lexical_cast<string>(a);\nint a = 10;\nstring s = lexical_cast<string>(a);\nOne nicety of this is that it supports other casts as well (e.g., in the opposite direction works just as well).Also note that although Boost lexical_cast started out as just writing to a stringstream, then extracting back out of the stream, it now has a couple of additions. First of all, specializations for quite a few types have been added, so for many common types, it's substantially faster than using a stringstream. Second, it now checks the result, so (for example) if you convert from a string to an int, it can throw an exception if the string contains something that couldn't be converted to an int (e.g., 1234 would succeed, but 123abc would throw).lexical_caststringstreamstringstreamintint1234123abc",
                "I usually use the following method:#include <sstream>\n\ntemplate <typename T>\n  std::string NumberToString ( T Number )\n  {\n     std::ostringstream ss;\n     ss << Number;\n     return ss.str();\n  }\n#include <sstream>\n\ntemplate <typename T>\n  std::string NumberToString ( T Number )\n  {\n     std::ostringstream ss;\n     ss << Number;\n     return ss.str();\n  }\nIt is described in details here.here",
                "You can use std::to_string available in C++11 as suggested by Matthieu M.:std::to_stringsuggested by Matthieu M.std::string s = std::to_string(42);\nstd::string s = std::to_string(42);\nOr, if performance is critical (for example, if you do lots of conversions), you can use fmt::format_int from the {fmt} library to convert an integer to std::string:fmt::format_int{fmt}std::stringstd::string s = fmt::format_int(42).str();\nstd::string s = fmt::format_int(42).str();\nOr a C string:fmt::format_int f(42);\nconst char* s = f.c_str();\nfmt::format_int f(42);\nconst char* s = f.c_str();\nThe latter doesn't do any dynamic memory allocations and is more than 70% faster than libstdc++ implementation of std::to_string on Boost Karma benchmarks. See Converting a hundred million integers to strings per second for more details.std::to_stringConverting a hundred million integers to strings per secondConverting a hundred million integers to strings per secondDisclaimer: I'm the author of the {fmt} library.",
                "If you have Boost installed (which you should):Boost#include <boost/lexical_cast.hpp>\n\nint num = 4;\nstd::string str = boost::lexical_cast<std::string>(num);\n#include <boost/lexical_cast.hpp>\n\nint num = 4;\nstd::string str = boost::lexical_cast<std::string>(num);\n",
                "It would be easier using stringstreams:#include <sstream>\n\nint x = 42;          // The integer\nstring str;          // The string\nostringstream temp;  // 'temp' as in temporary\ntemp << x;\nstr = temp.str();    // str is 'temp' as string\n#include <sstream>\n\nint x = 42;          // The integer\nstring str;          // The string\nostringstream temp;  // 'temp' as in temporary\ntemp << x;\nstr = temp.str();    // str is 'temp' as string\nOr make a function:#include <sstream>\n\nstring IntToString(int a)\n{\n    ostringstream temp;\n    temp << a;\n    return temp.str();\n}\n#include <sstream>\n\nstring IntToString(int a)\n{\n    ostringstream temp;\n    temp << a;\n    return temp.str();\n}\n",
                "Not that I know of, in pure C++. But a little modification of what you mentionedstring s = string(itoa(a));\nstring s = string(itoa(a));\nshould work, and it's pretty short.",
                "sprintf() is pretty good for format conversion. You can then assign the resulting C string to the C++ string as you did in 1.sprintf()",
                "Using stringstream for number conversion is dangerous!Using stringstream for number conversion is dangerous!See std::ostream::operator<< where it tells that operator<< inserts formatted output.std::ostream::operator<<std::ostream::operator<<operator<<Depending on your current locale an integer greater than three digits, could convert to a string of four digits, adding an extra thousands separator.E.g., int = 1000 could be converted to a string 1.001. This could make comparison operations not work at all.int = 10001.001So I would strongly recommend using the std::to_string way. It is easier and does what you expect.std::to_stringstd::to_stringFrom std::to_string:std::to_stringstd::to_string\nC++17 provides std::to_chars as a higher-performance locale-independent alternative.\nC++17 provides std::to_chars as a higher-performance locale-independent alternative.C++17std::to_chars",
                "First include:#include <string>\n#include <sstream>\n#include <string>\n#include <sstream>\nSecond add the method:template <typename T>\nstring NumberToString(T pNumber)\n{\n ostringstream oOStrStream;\n oOStrStream << pNumber;\n return oOStrStream.str();\n}\ntemplate <typename T>\nstring NumberToString(T pNumber)\n{\n ostringstream oOStrStream;\n oOStrStream << pNumber;\n return oOStrStream.str();\n}\nUse the method like this:NumberToString(69);\nNumberToString(69);\norint x = 69;\nstring vStr = NumberToString(x) + \" Hello word!.\"\nint x = 69;\nstring vStr = NumberToString(x) + \" Hello word!.\"\n",
                "In C++11 we can use the \"to_string()\" function to convert an int into a string:\"to_string()\"#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int x = 1612;\n    string s = to_string(x);\n    cout << s<< endl;\n\n    return 0;\n}\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int x = 1612;\n    string s = to_string(x);\n    cout << s<< endl;\n\n    return 0;\n}\n",
                "C++17 provides std::to_chars as a higher-performance locale-independent alternative.std::to_charsstd::to_chars",
                "If you need fast conversion of an integer with a fixed number of digits to char* left-padded with '0', this is the example for little-endian architectures (all x86, x86_64 and others):fastfixed number of digitsleft-padded with '0'If you are converting a two-digit number:int32_t s = 0x3030 | (n/10) | (n%10) << 8;\nint32_t s = 0x3030 | (n/10) | (n%10) << 8;\nIf you are converting a three-digit number:int32_t s = 0x303030 | (n/100) | (n/10%10) << 8 | (n%10) << 16;\nint32_t s = 0x303030 | (n/100) | (n/10%10) << 8 | (n%10) << 16;\nIf you are converting a four-digit number:int64_t s = 0x30303030 | (n/1000) | (n/100%10)<<8 | (n/10%10)<<16 | (n%10)<<24;\nint64_t s = 0x30303030 | (n/1000) | (n/100%10)<<8 | (n/10%10)<<16 | (n%10)<<24;\nAnd so on up to seven-digit numbers. In this example n is a given integer. After conversion it's string representation can be accessed as (char*)&s:n(char*)&sstd::cout << (char*)&s << std::endl;\nstd::cout << (char*)&s << std::endl;\nNote: If you need it on big-endian byte order, though I did not tested it, but here is an example: for three-digit number it is int32_t s = 0x00303030 | (n/100)<< 24 | (n/10%10)<<16 | (n%10)<<8; for four-digit numbers (64 bit arch): int64_t s = 0x0000000030303030 | (n/1000)<<56 | (n/100%10)<<48 | (n/10%10)<<40 | (n%10)<<32; I think it should work.Notebig-endianint32_t s = 0x00303030 | (n/100)<< 24 | (n/10%10)<<16 | (n%10)<<8;int64_t s = 0x0000000030303030 | (n/1000)<<56 | (n/100%10)<<48 | (n/10%10)<<40 | (n%10)<<32;",
                "It's rather easy to add some syntactical sugar that allows one to compose strings on the fly in a stream-like way#include <string>\n#include <sstream>\n\nstruct strmake {\n    std::stringstream s;\n    template <typename T> strmake& operator << (const T& x) {\n        s << x; return *this;\n    }   \n    operator std::string() {return s.str();}\n};\n#include <string>\n#include <sstream>\n\nstruct strmake {\n    std::stringstream s;\n    template <typename T> strmake& operator << (const T& x) {\n        s << x; return *this;\n    }   \n    operator std::string() {return s.str();}\n};\nNow you may append whatever you want (provided that an operator << (std::ostream& ..) is defined for it) to strmake() and use it in place of an std::string.<< (std::ostream& ..)strmake()std::stringExample:#include <iostream>\n\nint main() {\n    std::string x =\n      strmake() << \"Current time is \" << 5+5 << \":\" << 5*5 << \" GST\";\n    std::cout << x << std::endl;\n}\n#include <iostream>\n\nint main() {\n    std::string x =\n      strmake() << \"Current time is \" << 5+5 << \":\" << 5*5 << \" GST\";\n    std::cout << x << std::endl;\n}\n",
                "Use:#define convertToString(x) #x\n\nint main()\n{\n    convertToString(42); // Returns const char* equivalent of 42\n}\n#define convertToString(x) #x\n\nint main()\n{\n    convertToString(42); // Returns const char* equivalent of 42\n}\n",
                "int i = 255;\nstd::string s = std::to_string(i);\nint i = 255;\nstd::string s = std::to_string(i);\nIn C++, to_string() will create a string object of the integer value by representing the value as a sequence of characters.to_string()",
                "I use:int myint = 0;\nlong double myLD = 0.0;\n\nstring myint_str = static_cast<ostringstream*>(&(ostringstream() << myint))->str();\nstring myLD_str = static_cast<ostringstream*>(&(ostringstream() << myLD))->str();\nint myint = 0;\nlong double myLD = 0.0;\n\nstring myint_str = static_cast<ostringstream*>(&(ostringstream() << myint))->str();\nstring myLD_str = static_cast<ostringstream*>(&(ostringstream() << myLD))->str();\nIt works on my Windows and Linux g++ compilers.",
                "\nHere's another easy way to do\nHere's another easy way to dochar str[100];\nsprintf(str, \"%d\", 101);\nstring s = str;\nchar str[100];\nsprintf(str, \"%d\", 101);\nstring s = str;\nsprintf is a well-known one to insert any data into a string of the required format.sprintfYou can convert a char * array to a string as shown in the third line.char *",
                "If you're using MFC, you can use CString:MFCCStringint a = 10;\nCString strA;\nstrA.Format(\"%d\", a);\nint a = 10;\nCString strA;\nstrA.Format(\"%d\", a);\n",
                "C++11 introduced std::to_string() for numeric types:std::to_string()std::to_string()int n = 123; // Input, signed/unsigned short/int/long/long long/float/double\nstd::string str = std::to_string(n); // Output, std::string\nint n = 123; // Input, signed/unsigned short/int/long/long long/float/double\nstd::string str = std::to_string(n); // Output, std::string\n",
                "Use:#include<iostream>\n#include<string>\n\nstd::string intToString(int num);\n\nint main()\n{\n    int integer = 4782151;\n\n    std::string integerAsStr = intToString(integer);\n\n    std::cout << \"integer = \" << integer << std::endl;\n    std::cout << \"integerAsStr = \" << integerAsStr << std::endl;\n\n    return 0;\n}\n\nstd::string intToString(int num)\n{\n    std::string numAsStr;\n    bool isNegative = num < 0;\n    if(isNegative) num*=-1;\n\n    do\n    {\n       char toInsert = (num % 10) + 48;\n       numAsStr.insert(0, 1, toInsert);\n\n       num /= 10;\n    }while (num);\n  \n    return isNegative? numAsStr.insert(0, 1, '-') : numAsStr;\n}\n#include<iostream>\n#include<string>\n\nstd::string intToString(int num);\n\nint main()\n{\n    int integer = 4782151;\n\n    std::string integerAsStr = intToString(integer);\n\n    std::cout << \"integer = \" << integer << std::endl;\n    std::cout << \"integerAsStr = \" << integerAsStr << std::endl;\n\n    return 0;\n}\n\nstd::string intToString(int num)\n{\n    std::string numAsStr;\n    bool isNegative = num < 0;\n    if(isNegative) num*=-1;\n\n    do\n    {\n       char toInsert = (num % 10) + 48;\n       numAsStr.insert(0, 1, toInsert);\n\n       num /= 10;\n    }while (num);\n  \n    return isNegative? numAsStr.insert(0, 1, '-') : numAsStr;\n}\n",
                "All you have to do is use String when defining your variable (String intStr). Whenever you need that variable, call whateverFunction(intStr.toInt())StringString intStrwhateverFunction(intStr.toInt())",
                "Using the plain standard stdio header, you can cast the integer over sprintf into a buffer, like so:stdio headersprintf#include <stdio.h>\n\nint main()\n{\n    int x = 23;\n    char y[2]; // The output buffer\n    sprintf(y, \"%d\", x);\n    printf(\"%s\", y)\n}\n#include <stdio.h>\n\nint main()\n{\n    int x = 23;\n    char y[2]; // The output buffer\n    sprintf(y, \"%d\", x);\n    printf(\"%s\", y)\n}\nRemember to take care of your buffer size according to your needs (the string output size).buffer size",
                "string number_to_string(int x) {\n\n    if (!x)\n        return \"0\";\n\n    string s, s2;\n    while(x) {\n        s.push_back(x%10 + '0');\n        x /= 10;\n    }\n    reverse(s.begin(), s.end());\n    return s;\n}\nstring number_to_string(int x) {\n\n    if (!x)\n        return \"0\";\n\n    string s, s2;\n    while(x) {\n        s.push_back(x%10 + '0');\n        x /= 10;\n    }\n    reverse(s.begin(), s.end());\n    return s;\n}\n",
                "This worked for me -My code:#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n = 32;\n    string s = to_string(n);\n    cout << \"string: \" + s  << endl;\n    return 0;\n}\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n = 32;\n    string s = to_string(n);\n    cout << \"string: \" + s  << endl;\n    return 0;\n}\n",
                "I think using stringstream is pretty easy:stringstream string toString(int n)\n {\n     stringstream ss(n);\n     ss << n;\n     return ss.str();\n }\n\n int main()\n {\n    int n;\n    cin >> n;\n    cout << toString(n) << endl;\n    return 0;\n }\n string toString(int n)\n {\n     stringstream ss(n);\n     ss << n;\n     return ss.str();\n }\n\n int main()\n {\n    int n;\n    cin >> n;\n    cout << toString(n) << endl;\n    return 0;\n }\n",
                "char * bufSecs = new char[32];\nchar * bufMs = new char[32];\nsprintf(bufSecs, \"%d\", timeStart.elapsed()/1000);\nsprintf(bufMs, \"%d\", timeStart.elapsed()%1000);\nchar * bufSecs = new char[32];\nchar * bufMs = new char[32];\nsprintf(bufSecs, \"%d\", timeStart.elapsed()/1000);\nsprintf(bufMs, \"%d\", timeStart.elapsed()%1000);\n",
                "namespace std\n{\n    inline string to_string(int _Val)\n    {   // Convert long long to string\n        char _Buf[2 * _MAX_INT_DIG];\n        snprintf(_Buf, \"%d\", _Val);\n        return (string(_Buf));\n    }\n}\nnamespace std\n{\n    inline string to_string(int _Val)\n    {   // Convert long long to string\n        char _Buf[2 * _MAX_INT_DIG];\n        snprintf(_Buf, \"%d\", _Val);\n        return (string(_Buf));\n    }\n}\nYou can now use to_string(5).to_string(5)",
                "You use a counter type of algorithm to convert to a string. I got this technique from programming Commodore 64 computers. It is also good for game programming.Commodore 64\nYou take the integer and take each digit that is weighted by powers of 10. So assume the integer is 950.\n\nIf the integer equals or is greater than 100,000 then subtract 100,000 and increase the counter in the string at [\"000000\"]; \nkeep doing it until no more numbers in position 100,000.\nDrop another power of ten.\nIf the integer equals or is greater than 10,000 then subtract 10,000 and increase the counter in the string at [\"000000\"] + 1 position; \nkeep doing it until no more numbers in position 10,000.\n\nDrop another power of ten\nRepeat the pattern\nYou take the integer and take each digit that is weighted by powers of 10. So assume the integer is 950.\n\nIf the integer equals or is greater than 100,000 then subtract 100,000 and increase the counter in the string at [\"000000\"]; \nkeep doing it until no more numbers in position 100,000.\nDrop another power of ten.\nIf the integer equals or is greater than 10,000 then subtract 10,000 and increase the counter in the string at [\"000000\"] + 1 position; \nkeep doing it until no more numbers in position 10,000.\nYou take the integer and take each digit that is weighted by powers of 10. So assume the integer is 950.\nIf the integer equals or is greater than 100,000 then subtract 100,000 and increase the counter in the string at [\"000000\"]; \nkeep doing it until no more numbers in position 100,000.\nDrop another power of ten.\nIf the integer equals or is greater than 10,000 then subtract 10,000 and increase the counter in the string at [\"000000\"] + 1 position; \nkeep doing it until no more numbers in position 10,000.\nIf the integer equals or is greater than 100,000 then subtract 100,000 and increase the counter in the string at [\"000000\"]; \nkeep doing it until no more numbers in position 100,000.\nDrop another power of ten.If the integer equals or is greater than 100,000 then subtract 100,000 and increase the counter in the string at [\"000000\"]; \nkeep doing it until no more numbers in position 100,000.\nDrop another power of ten.If the integer equals or is greater than 10,000 then subtract 10,000 and increase the counter in the string at [\"000000\"] + 1 position; \nkeep doing it until no more numbers in position 10,000.If the integer equals or is greater than 10,000 then subtract 10,000 and increase the counter in the string at [\"000000\"] + 1 position; \nkeep doing it until no more numbers in position 10,000.Drop another power of tenDrop another power of tenRepeat the patternI know 950 is too small to use as an example, but I hope you get the idea."
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Generate random integers between 0 and 9",
                "generate random integers between 0 and 9"
            ],
            "responses": [
                "Try random.randrange:random.randrangerandom.randrangefrom random import randrange\nprint(randrange(10))\nfrom random import randrange\nprint(randrange(10))\n",
                "Try random.randint:random.randintrandom.randintimport random\nprint(random.randint(0, 9))\nimport random\nprint(random.randint(0, 9))\nDocs state:\nrandom.randint(a, b)\n\nReturn a random integer N such that a <= N <= b.\nrandom.randint(a, b)\nrandom.randint(a, b)\nReturn a random integer N such that a <= N <= b.",
                "Try this:from random import randrange, uniform\n\n# randrange gives you an integral value\nirand = randrange(0, 10)\n\n# uniform gives you a floating-point value\nfrand = uniform(0, 10)\nfrom random import randrange, uniform\n\n# randrange gives you an integral value\nirand = randrange(0, 10)\n\n# uniform gives you a floating-point value\nfrand = uniform(0, 10)\n",
                "from random import randint\n\nx = [randint(0, 9) for p in range(0, 10)]\nfrom random import randint\n\nx = [randint(0, 9) for p in range(0, 10)]\nThis generates 10 pseudorandom integers in range 0 to 9 inclusive.",
                "The secrets module is new in Python 3.6. This is better than the random module for cryptography or security uses.secretssecretsrandomrandomTo randomly print an integer in the inclusive range 0-9:from secrets import randbelow\nprint(randbelow(10))\nfrom secrets import randbelow\nprint(randbelow(10))\nFor details, see PEP 506.PEP 506Note that it really depends on the use case. With the random module you can set a random seed, useful for pseudorandom but reproducible results, and this is not possible with the secrets module.randomsecretsrandom module is also faster (tested on Python 3.9):random>>> timeit.timeit(\"random.randrange(10)\", setup=\"import random\")\n0.4920286529999771\n>>> timeit.timeit(\"secrets.randbelow(10)\", setup=\"import secrets\")\n2.0670733770000425\n>>> timeit.timeit(\"random.randrange(10)\", setup=\"import random\")\n0.4920286529999771\n>>> timeit.timeit(\"secrets.randbelow(10)\", setup=\"import secrets\")\n2.0670733770000425\n",
                "I would try one of the following:1.>  numpy.random.randint1.>  numpy.random.randintnumpy.random.randintimport numpy as np\nX1 = np.random.randint(low=0, high=10, size=(15,))\n\nprint (X1)\n>>> array([3, 0, 9, 0, 5, 7, 6, 9, 6, 7, 9, 6, 6, 9, 8])\nimport numpy as np\nX1 = np.random.randint(low=0, high=10, size=(15,))\n\nprint (X1)\n>>> array([3, 0, 9, 0, 5, 7, 6, 9, 6, 7, 9, 6, 6, 9, 8])\n2.>  numpy.random.uniform2.>  numpy.random.uniformnumpy.random.uniformimport numpy as np\nX2 = np.random.uniform(low=0, high=10, size=(15,)).astype(int)\n\nprint (X2)\n>>> array([8, 3, 6, 9, 1, 0, 3, 6, 3, 3, 1, 2, 4, 0, 4])\nimport numpy as np\nX2 = np.random.uniform(low=0, high=10, size=(15,)).astype(int)\n\nprint (X2)\n>>> array([8, 3, 6, 9, 1, 0, 3, 6, 3, 3, 1, 2, 4, 0, 4])\n3.>  numpy.random.choice3.>  numpy.random.choicenumpy.random.choiceimport numpy as np\nX3 = np.random.choice(a=10, size=15 )\n\nprint (X3)\n>>> array([1, 4, 0, 2, 5, 2, 7, 5, 0, 0, 8, 4, 4, 0, 9])\nimport numpy as np\nX3 = np.random.choice(a=10, size=15 )\n\nprint (X3)\n>>> array([1, 4, 0, 2, 5, 2, 7, 5, 0, 0, 8, 4, 4, 0, 9])\n4.>  random.randrange4.>  random.randrangerandom.randrangefrom random import randrange\nX4 = [randrange(10) for i in range(15)]\n\nprint (X4)\n>>> [2, 1, 4, 1, 2, 8, 8, 6, 4, 1, 0, 5, 8, 3, 5]\nfrom random import randrange\nX4 = [randrange(10) for i in range(15)]\n\nprint (X4)\n>>> [2, 1, 4, 1, 2, 8, 8, 6, 4, 1, 0, 5, 8, 3, 5]\n5.>  random.randint5.>  random.randintrandom.randintfrom random import randint\nX5 = [randint(0, 9) for i in range(0, 15)]\n\nprint (X5)\n>>> [6, 2, 6, 9, 5, 3, 2, 3, 3, 4, 4, 7, 4, 9, 6]\nfrom random import randint\nX5 = [randint(0, 9) for i in range(0, 15)]\n\nprint (X5)\n>>> [6, 2, 6, 9, 5, 3, 2, 3, 3, 4, 4, 7, 4, 9, 6]\nSpeed:Speed:\u25ba np.random.uniform and np.random.randint are much faster (~10 times faster) than np.random.choice, random.randrange, random.randint .np.random.uniform and np.random.randint are much fasternp.random.randintnp.random.choice, random.randrange, random.randint%timeit np.random.randint(low=0, high=10, size=(15,))\n>> 1.64 \u00b5s \u00b1 7.83 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n\n%timeit np.random.uniform(low=0, high=10, size=(15,)).astype(int)\n>> 2.15 \u00b5s \u00b1 38.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\n%timeit np.random.choice(a=10, size=15 )\n>> 21 \u00b5s \u00b1 629 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n\n%timeit [randrange(10) for i in range(15)]\n>> 12.9 \u00b5s \u00b1 60.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\n%timeit [randint(0, 9) for i in range(0, 15)]\n>> 20 \u00b5s \u00b1 386 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n%timeit np.random.randint(low=0, high=10, size=(15,))\n>> 1.64 \u00b5s \u00b1 7.83 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n\n%timeit np.random.uniform(low=0, high=10, size=(15,)).astype(int)\n>> 2.15 \u00b5s \u00b1 38.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\n%timeit np.random.choice(a=10, size=15 )\n>> 21 \u00b5s \u00b1 629 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n\n%timeit [randrange(10) for i in range(15)]\n>> 12.9 \u00b5s \u00b1 60.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\n%timeit [randint(0, 9) for i in range(0, 15)]\n>> 20 \u00b5s \u00b1 386 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nNotes:Notes:\n1.> np.random.randint generates random integers over the half-open interval [low, high).\n2.> np.random.uniform generates uniformly distributed numbers over the half-open interval [low, high).\n3.> np.random.choice generates a random sample over the half-open interval [low, high) as if the argument a was np.arange(n).\n4.> random.randrange(stop) generates a random number from range(start, stop, step).\n5.> random.randint(a, b) returns a random integer N such that a <= N <= b.\n6.> astype(int) casts the numpy array to int data type.\n7.> I have chosen size = (15,). This will give you a numpy array of length = 15.\n1.> np.random.randint generates random integers over the half-open interval [low, high).np.random.randint2.> np.random.uniform generates uniformly distributed numbers over the half-open interval [low, high).np.random.uniform3.> np.random.choice generates a random sample over the half-open interval [low, high) as if the argument a was np.arange(n).np.random.choicea4.> random.randrange(stop) generates a random number from range(start, stop, step).random.randrange(stop)5.> random.randint(a, b) returns a random integer N such that a <= N <= b.random.randint(a, b)6.> astype(int) casts the numpy array to int data type.astype(int)7.> I have chosen size = (15,). This will give you a numpy array of length = 15.",
                "Choose the size of the array (in this example, I have chosen the size to be 20). And then, use the following: import numpy as np   \nnp.random.randint(10, size=(1, 20))\nimport numpy as np   \nnp.random.randint(10, size=(1, 20))\nYou can expect to see an output of the following form (different random integers will be returned each time you run it; hence you can expect the integers in the output array to differ from the example given below).different random integers will be returned each time you run it; hence you can expect the integers in the output array to differ from the example given belowarray([[1, 6, 1, 2, 8, 6, 3, 3, 2, 5, 6, 5, 0, 9, 5, 6, 4, 5, 9, 3]])\narray([[1, 6, 1, 2, 8, 6, 3, 3, 2, 5, 6, 5, 0, 9, 5, 6, 4, 5, 9, 3]])\n",
                "While many posts demonstrate how to get one random integer, the original question asks how to generate random integers (plural):ones\nHow can I generate random integers between 0 and 9 (inclusive) in Python?\nHow can I generate random integers between 0 and 9 (inclusive) in Python?For clarity, here we demonstrate how to get multiple random integers.GivenGiven>>> import random\n\n\nlo = 0\nhi = 10\nsize = 5\n>>> import random\n\n\nlo = 0\nhi = 10\nsize = 5\nCodeCodeMultiple, Random IntegersMultiple, Random Integers# A\n>>> [lo + int(random.random() * (hi - lo)) for _ in range(size)]\n[5, 6, 1, 3, 0]\n# A\n>>> [lo + int(random.random() * (hi - lo)) for _ in range(size)]\n[5, 6, 1, 3, 0]\n# B\n>>> [random.randint(lo, hi) for _ in range(size)]\n[9, 7, 0, 7, 3]\n# B\n>>> [random.randint(lo, hi) for _ in range(size)]\n[9, 7, 0, 7, 3]\n# C\n>>> [random.randrange(lo, hi) for _ in range(size)]\n[8, 3, 6, 8, 7]\n# C\n>>> [random.randrange(lo, hi) for _ in range(size)]\n[8, 3, 6, 8, 7]\n# D\n>>> lst = list(range(lo, hi))\n>>> random.shuffle(lst)\n>>> [lst[i] for i in range(size)]\n[6, 8, 2, 5, 1]\n# D\n>>> lst = list(range(lo, hi))\n>>> random.shuffle(lst)\n>>> [lst[i] for i in range(size)]\n[6, 8, 2, 5, 1]\n# E\n>>> [random.choice(range(lo, hi)) for _ in range(size)]\n[2, 1, 6, 9, 5]\n# E\n>>> [random.choice(range(lo, hi)) for _ in range(size)]\n[2, 1, 6, 9, 5]\nSample of Random IntegersSample of Random Integers# F\n>>> random.choices(range(lo, hi), k=size)\n[3, 2, 0, 8, 2]\n# F\n>>> random.choices(range(lo, hi), k=size)\n[3, 2, 0, 8, 2]\n# G\n>>> random.sample(range(lo, hi), k=size)\n[4, 5, 1, 2, 3]\n# G\n>>> random.sample(range(lo, hi), k=size)\n[4, 5, 1, 2, 3]\nDetailsDetailsSome posts demonstrate how to natively generate multiple random integers.1  Here are some options that address the implied question:multiple1\nA: random.random returns a random float in the range [0.0, 1.0)\nB: random.randint returns a random integer N such that a <= N <= b\nC: random.randrange alias to randint(a, b+1)\nD: random.shuffle shuffles a sequence in place\nE: random.choice returns a random element from the non-empty sequence\nF: random.choices returns k selections from a population (with replacement, Python 3.6+)\nG: random.sample returns k unique selections from a population (without replacement):2\nA: random.random returns a random float in the range [0.0, 1.0)Arandom.randomrandom.random[0.0, 1.0)B: random.randint returns a random integer N such that a <= N <= bBrandom.randintrandom.randintNa <= N <= bC: random.randrange alias to randint(a, b+1)Crandom.randrangerandom.randrangerandint(a, b+1)D: random.shuffle shuffles a sequence in placeDrandom.shufflerandom.shuffleE: random.choice returns a random element from the non-empty sequenceErandom.choicerandom.choiceF: random.choices returns k selections from a population (with replacement, Python 3.6+)Frandom.choicesrandom.choiceskG: random.sample returns k unique selections from a population (without replacement):2Grandom.samplerandom.samplek2See also R. Hettinger's talk on Chunking and Aliasing using examples from the random module.talkrandomHere is a comparison of some random functions in the Standard Library and Numpy:| | random                | numpy.random                     |\n|-|-----------------------|----------------------------------|\n|A| random()              | random()                         |\n|B| randint(low, high)    | randint(low, high)               |\n|C| randrange(low, high)  | randint(low, high)               |\n|D| shuffle(seq)          | shuffle(seq)                     |\n|E| choice(seq)           | choice(seq)                      |\n|F| choices(seq, k)       | choice(seq, size)                |\n|G| sample(seq, k)        | choice(seq, size, replace=False) |\n| | random                | numpy.random                     |\n|-|-----------------------|----------------------------------|\n|A| random()              | random()                         |\n|B| randint(low, high)    | randint(low, high)               |\n|C| randrange(low, high)  | randint(low, high)               |\n|D| shuffle(seq)          | shuffle(seq)                     |\n|E| choice(seq)           | choice(seq)                      |\n|F| choices(seq, k)       | choice(seq, size)                |\n|G| sample(seq, k)        | choice(seq, size, replace=False) |\nYou can also quickly convert one of many distributions in Numpy to a sample of random integers.3distributions3ExamplesExamples>>> np.random.normal(loc=5, scale=10, size=size).astype(int)\narray([17, 10,  3,  1, 16])\n\n>>> np.random.poisson(lam=1, size=size).astype(int)\narray([1, 3, 0, 2, 0])\n\n>>> np.random.lognormal(mean=0.0, sigma=1.0, size=size).astype(int)\narray([1, 3, 1, 5, 1])\n>>> np.random.normal(loc=5, scale=10, size=size).astype(int)\narray([17, 10,  3,  1, 16])\n\n>>> np.random.poisson(lam=1, size=size).astype(int)\narray([1, 3, 0, 2, 0])\n\n>>> np.random.lognormal(mean=0.0, sigma=1.0, size=size).astype(int)\narray([1, 3, 1, 5, 1])\n1Namely @John Lawrence Aspden, @S T Mohammed, @SiddTheKid, @user14372, @zangw, et al.\n2@prashanth mentions this module showing one integer.\n3Demonstrated by @Siddharth Satpathy1Namely @John Lawrence Aspden, @S T Mohammed, @SiddTheKid, @user14372, @zangw, et al.12@prashanth mentions this module showing one integer.23Demonstrated by @Siddharth Satpathy3",
                "You need the random python module which is part of your standard library.\nUse the code...randomfrom random import randint\n\nnum1= randint(0,9)\nfrom random import randint\n\nnum1= randint(0,9)\nThis will set the variable num1 to a random number between 0 and 9 inclusive.num109",
                "Try this through random.shufflerandom.shuffle>>> import random\n>>> nums = range(10)\n>>> random.shuffle(nums)\n>>> nums\n[6, 3, 5, 4, 0, 1, 2, 9, 8, 7]\n>>> import random\n>>> nums = range(10)\n>>> random.shuffle(nums)\n>>> nums\n[6, 3, 5, 4, 0, 1, 2, 9, 8, 7]\n",
                "In case of continuous numbers randint or randrange are probably the best choices but if you have several distinct values in a sequence (i.e. a list) you could also use choice:randintrandintrandrangerandrangelistchoicechoice>>> import random\n>>> values = list(range(10))\n>>> random.choice(values)\n5\n>>> import random\n>>> values = list(range(10))\n>>> random.choice(values)\n5\nchoice also works for one item from a not-continuous sample:choice>>> values = [1, 2, 3, 5, 7, 10]\n>>> random.choice(values)\n7\n>>> values = [1, 2, 3, 5, 7, 10]\n>>> random.choice(values)\n7\nIf you need it \"cryptographically strong\" there's also a secrets.choice in python 3.6 and newer:secrets.choicesecrets.choice>>> import secrets\n>>> values = list(range(10))\n>>> secrets.choice(values)\n2\n>>> import secrets\n>>> values = list(range(10))\n>>> secrets.choice(values)\n2\n",
                "if you want to use numpy then use the following:import numpy as np\nprint(np.random.randint(0,10))\nimport numpy as np\nprint(np.random.randint(0,10))\n",
                ">>> import random\n>>> random.randrange(10)\n3\n>>> random.randrange(10)\n1\n>>> import random\n>>> random.randrange(10)\n3\n>>> random.randrange(10)\n1\nTo get a list of ten samples:>>> [random.randrange(10) for x in range(10)]\n[9, 0, 4, 0, 5, 7, 4, 3, 6, 8]\n>>> [random.randrange(10) for x in range(10)]\n[9, 0, 4, 0, 5, 7, 4, 3, 6, 8]\n",
                "You can try importing the random module from Python and then making it choose a choice between the nine numbers. It's really basic.import random\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    \nimport random\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    \nYou can try putting the value the computer chose in a variable if you're going to use it later, but if not, the print function should work as such:choice = random.choice(numbers)\nprint(choice)\nchoice = random.choice(numbers)\nprint(choice)\n",
                "Generating random integers between 0 and 9.import numpy\nX = numpy.random.randint(0, 10, size=10)\nprint(X)\nimport numpy\nX = numpy.random.randint(0, 10, size=10)\nprint(X)\nOutput:[4 8 0 4 9 6 9 9 0 7]\n[4 8 0 4 9 6 9 9 0 7]\n",
                "Best way is to use import Random function  import random\nprint(random.sample(range(10), 10))\nimport random\nprint(random.sample(range(10), 10))\nor without any library import:n={} \nfor i in range(10):\n    n[i]=i\n\nfor p in range(10):\n    print(n.popitem()[1])\nn={} \nfor i in range(10):\n    n[i]=i\n\nfor p in range(10):\n    print(n.popitem()[1])\nhere the popitems removes and returns an arbitrary value from the dictionary n.popitemsn",
                "random.sample is another that can be usedrandom.sampleimport random\nn = 1 # specify the no. of numbers\nnum = random.sample(range(10),  n)\nnum[0] # is the required number\nimport random\nn = 1 # specify the no. of numbers\nnum = random.sample(range(10),  n)\nnum[0] # is the required number\n",
                "This is more of a mathematical approach but it works 100% of the time:Let's say you want to use random.random() function to generate a number between a and b. To achieve this, just do the following:random.random()abnum = (b-a)*random.random() + a;num = (b-a)*random.random() + a;Of course, you can generate more numbers.",
                "From the documentation page for the random module:random\nWarning: The pseudo-random generators of this module should not be\nused for security purposes. Use os.urandom() or SystemRandom if you\nrequire a cryptographically secure pseudo-random number generator.\nWarning: The pseudo-random generators of this module should not be\nused for security purposes. Use os.urandom() or SystemRandom if you\nrequire a cryptographically secure pseudo-random number generator.random.SystemRandom, which was introduced in Python 2.4, is considered cryptographically secure.  It is still available in Python 3.7.1 which is current at time of writing.random.SystemRandomcryptographically secure>>> import string\n>>> string.digits\n'0123456789'\n>>> import random\n>>> random.SystemRandom().choice(string.digits)\n'8'\n>>> random.SystemRandom().choice(string.digits)\n'1'\n>>> random.SystemRandom().choice(string.digits)\n'8'\n>>> random.SystemRandom().choice(string.digits)\n'5'\n>>> import string\n>>> string.digits\n'0123456789'\n>>> import random\n>>> random.SystemRandom().choice(string.digits)\n'8'\n>>> random.SystemRandom().choice(string.digits)\n'1'\n>>> random.SystemRandom().choice(string.digits)\n'8'\n>>> random.SystemRandom().choice(string.digits)\n'5'\nInstead of string.digits, range could be used per some of the other answers along perhaps with a comprehension.  Mix and match according to your needs.string.digitsrange",
                "I thought I'd add to these answers with quantumrand, which uses ANU's quantum number generator. Unfortunately this requires an internet connection, but if you're concerned with \"how random\" the numbers are then this could be useful.quantumrandhttps://pypi.org/project/quantumrand/https://pypi.org/project/quantumrand/Exampleimport quantumrand\n\nnumber = quantumrand.randint(0, 9)\n\nprint(number)\nimport quantumrand\n\nnumber = quantumrand.randint(0, 9)\n\nprint(number)\nOutput: 44The docs have a lot of different examples including dice rolls and a list picker.",
                "I had better luck with this for Python 3.6  str_Key = \"\"                                                                                                \nstr_RandomKey = \"\"                                                                                          \nfor int_I in range(128):                                                                                    \n      str_Key = random.choice('0123456789')\n      str_RandomKey = str_RandomKey + str_Key \nstr_Key = \"\"                                                                                                \nstr_RandomKey = \"\"                                                                                          \nfor int_I in range(128):                                                                                    \n      str_Key = random.choice('0123456789')\n      str_RandomKey = str_RandomKey + str_Key \nJust add characters like 'ABCD' and 'abcd' or '^!~=-><' to alter the character pool to pull from, change the range to alter the number of characters generated.",
                "OpenTURNS allows to not only simulate the random integers but also to define the associated distribution with the UserDefined defined class. UserDefinedThe following simulates 12 outcomes of the distribution.import openturns as ot\npoints = [[i] for i in range(10)]\ndistribution = ot.UserDefined(points) # By default, with equal weights.\nfor i in range(12):\n    x = distribution.getRealization()\n    print(i,x)\nimport openturns as ot\npoints = [[i] for i in range(10)]\ndistribution = ot.UserDefined(points) # By default, with equal weights.\nfor i in range(12):\n    x = distribution.getRealization()\n    print(i,x)\nThis prints:0 [8]\n1 [7]\n2 [4]\n3 [7]\n4 [3]\n5 [3]\n6 [2]\n7 [9]\n8 [0]\n9 [5]\n10 [9]\n11 [6]\n0 [8]\n1 [7]\n2 [4]\n3 [7]\n4 [3]\n5 [3]\n6 [2]\n7 [9]\n8 [0]\n9 [5]\n10 [9]\n11 [6]\nThe brackets are there becausex is a Point in 1-dimension.\nIt would be easier to generate the 12 outcomes in a single call to getSample:xPointgetSamplesample = distribution.getSample(12)\nsample = distribution.getSample(12)\nwould produce:>>> print(sample)\n     [ v0 ]\n 0 : [ 3  ]\n 1 : [ 9  ]\n 2 : [ 6  ]\n 3 : [ 3  ]\n 4 : [ 2  ]\n 5 : [ 6  ]\n 6 : [ 9  ]\n 7 : [ 5  ]\n 8 : [ 9  ]\n 9 : [ 5  ]\n10 : [ 3  ]\n11 : [ 2  ]\n>>> print(sample)\n     [ v0 ]\n 0 : [ 3  ]\n 1 : [ 9  ]\n 2 : [ 6  ]\n 3 : [ 3  ]\n 4 : [ 2  ]\n 5 : [ 6  ]\n 6 : [ 9  ]\n 7 : [ 5  ]\n 8 : [ 9  ]\n 9 : [ 5  ]\n10 : [ 3  ]\n11 : [ 2  ]\nMore details on this topic are here: http://openturns.github.io/openturns/master/user_manual/_generated/openturns.UserDefined.htmlhttp://openturns.github.io/openturns/master/user_manual/_generated/openturns.UserDefined.html"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Convert integer to string in Python",
                "convert integers into strings in python",
                "convert integer into string in python",
                "convert integer to string in python"
            ],
            "responses": [
                ">>> str(42)\n'42'\n\n>>> int('42')\n42\n>>> str(42)\n'42'\n\n>>> int('42')\n42\nLinks to the documentation:\nint()\nstr()\nint()int()int()str()str()str()str(x) converts any object x to a string by calling x.__str__(), or repr(x) if x doesn't have a __str__() method.str(x)xx.__str__()__str__()repr(x)repr(x)x__str__()",
                "Try this:str(i)\nstr(i)\n",
                "There is no typecast and no type coercion in Python. You have to convert your variable in an explicit way.To convert an object into a string you use the str() function. It works with any object that has a method called __str__() defined. In factstr()__str__()str(a)\nstr(a)\nis equivalent toa.__str__()\na.__str__()\nThe same if you want to convert something to int, float, etc.intfloat",
                "To manage non-integer inputs:number = raw_input()\ntry:\n    value = int(number)\nexcept ValueError:\n    value = 0\nnumber = raw_input()\ntry:\n    value = int(number)\nexcept ValueError:\n    value = 0\n",
                ">>> i = 5\n>>> print \"Hello, world the number is \" + i\nTypeError: must be str, not int\n>>> s = str(i)\n>>> print \"Hello, world the number is \" + s\nHello, world the number is 5\n>>> i = 5\n>>> print \"Hello, world the number is \" + i\nTypeError: must be str, not int\n>>> s = str(i)\n>>> print \"Hello, world the number is \" + s\nHello, world the number is 5\n",
                "For Python 3.6, you can use the f-strings new feature to convert to string and it's faster compared to str() function. It is used like this:f-stringsage = 45\nstrAge = f'{age}'\nage = 45\nstrAge = f'{age}'\nPython provides the str() function for that reason.digit = 10\nprint(type(digit)) # Will show <class 'int'>\nconvertedDigit = str(digit)\nprint(type(convertedDigit)) # Will show <class 'str'>\ndigit = 10\nprint(type(digit)) # Will show <class 'int'>\nconvertedDigit = str(digit)\nprint(type(convertedDigit)) # Will show <class 'str'>\nFor a more detailed answer, you can check this article: Converting Python Int to String and Python String to IntConverting Python Int to String and Python String to IntConverting Python Int to String and Python String to Int",
                "In Python => 3.6 you can use f formatting:f>>> int_value = 10\n>>> f'{int_value}'\n'10'\n>>>\n>>> int_value = 10\n>>> f'{int_value}'\n'10'\n>>>\n",
                "The most decent way in my opinion is ``.i = 32   -->    `i` == '32'\ni = 32   -->    `i` == '32'\n",
                "You can use %s or .format:%s.format>>> \"%s\" % 10\n'10'\n>>>\n>>> \"%s\" % 10\n'10'\n>>>\nOr:>>> '{}'.format(10)\n'10'\n>>>\n>>> '{}'.format(10)\n'10'\n>>>\n",
                "For someone who wants to convert int to string in specific digits, the below method is recommended.month = \"{0:04d}\".format(localtime[1])\nmonth = \"{0:04d}\".format(localtime[1])\nFor more details, you can refer to Stack Overflow question Display number with leading zeros.Display number with leading zerosDisplay number with leading zeros",
                "With the introduction of f-strings in Python 3.6, this will also work:f-stringsf'{10}' == '10'\nf'{10}' == '10'\nIt is actually faster than calling str(), at the cost of readability.str()In fact, it's faster than %x string formatting and .format()!%x.format()",
                "There are several ways to convert an integer to string in python.\nYou can use [ str(integer here) ] function, the f-string  [ f'{integer here}'], the .format()function [ '{}'.format(integer here) and even the '%s'% keyword [ '%s'% integer here]. All this method can convert an integer to string.See below example#Examples of converting an intger to string\n\n#Using the str() function\nnumber = 1\nconvert_to_string = str(number)\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n#Using the f-string\nnumber = 1\nconvert_to_string = f'{number}'\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n#Using the  {}'.format() function\nnumber = 1\nconvert_to_string = '{}'.format(number)\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n#Using the  '% s '% keyword\nnumber = 1\nconvert_to_string = '% s '% number\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n\n#Examples of converting an intger to string\n\n#Using the str() function\nnumber = 1\nconvert_to_string = str(number)\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n#Using the f-string\nnumber = 1\nconvert_to_string = f'{number}'\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n#Using the  {}'.format() function\nnumber = 1\nconvert_to_string = '{}'.format(number)\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n#Using the  '% s '% keyword\nnumber = 1\nconvert_to_string = '% s '% number\nprint(type(convert_to_string)) # output (<class 'str'>)\n\n\n",
                "Here is a simpler solution:one = \"1\"\nprint(int(one))\none = \"1\"\nprint(int(one))\nOutput console>>> 1\n>>> 1\nIn the above program, int() is used to convert the string representation of an integer.int()Note: A variable in the format of string can be converted into an integer only if the variable is completely composed of numbers.In the same way, str() is used to convert an integer to string.str()number = 123567\na = []\na.append(str(number))\nprint(a) \nnumber = 123567\na = []\na.append(str(number))\nprint(a) \nI used a list to print the output to highlight that variable (a) is a string.Output console>>> [\"123567\"]\n>>> [\"123567\"]\nBut to understand the difference how a list stores a string and integer, view the below code first and then the output.Codea = \"This is a string and next is an integer\"\nlistone=[a, 23]\nprint(listone)\na = \"This is a string and next is an integer\"\nlistone=[a, 23]\nprint(listone)\nOutput console>>> [\"This is a string and next is an integer\", 23]\n>>> [\"This is a string and next is an integer\", 23]\n"
            ]
        },
        {
            "tag": "integer",
            "patterns": [
                "What is the maximum value for an int32?",
                "tell me the maximum value of int32?",
                "tell me the maximum value for int32?",
                "what's the maximum value of int32?",
                "what is the maximum value for int32?"
            ],
            "responses": [
                "It's 2,147,483,647. Easiest way to memorize it is via a tattoo.",
                "The most correct answer I can think of is Int32.MaxValue.Int32.MaxValue",
                "If you think the value is too hard to remember in base 10, try base 2:\n1111111111111111111111111111111",
                "if you can remember the entire Pi number, then the number you are looking for is at the position 1,867,996,680 till 1,867,996,689 of the decimal digits of Pi \nThe numeric string 2147483647 appears at the 1,867,996,680 decimal digit of Pi. 3.14......86181221809936452346214748364710527835665425671614...\nThe numeric string 2147483647 appears at the 1,867,996,680 decimal digit of Pi. 3.14......86181221809936452346214748364710527835665425671614...2147483647source: http://www.subidiom.com/pi/http://www.subidiom.com/pi/",
                "It's 10 digits, so pretend it's a phone number (assuming you're in the US). 214-748-3647. I don't recommend calling it. ",
                "Rather than think of it as one big number, try breaking it down and looking for associated ideas eg:\n2 maximum snooker breaks (a maximum break is 147)\n4 years (48 months)\n3 years (36 months)\n4 years (48 months)\n2 maximum snooker breaks (a maximum break is 147)4 years (48 months)3 years (36 months)4 years (48 months)The above applies to the biggest negative number; positive is that minus one.Maybe the above breakdown will be no more memorable for you (it's hardly exciting is it!), but hopefully you can come up with some ideas that are!",
                "Largest negative (32bit) value : -2147483648\n(1 << 31)Largest positive (32bit) value : 2147483647\n~(1 << 31)Mnemonic: \"drunk AKA horny\"drunk ========= Drinking age is 21\nAK ============ AK 47\nA ============= 4 (A and 4 look the same)\nhorny ========= internet rule 34 (if it exists, there's 18+ material of it) \n\n21 47 4(years) 3(years) 4(years)\n21 47 48       36       48\ndrunk ========= Drinking age is 21\nAK ============ AK 47\nA ============= 4 (A and 4 look the same)\nhorny ========= internet rule 34 (if it exists, there's 18+ material of it) \n\n21 47 4(years) 3(years) 4(years)\n21 47 48       36       48\n",
                "Anyway, take this regex (it determines if the string contains a non-negative Integer in  decimal form that is also not greater than Int32.MaxValue) [0-9]{1,9}|[0-1][0-9]{1,8}|20[0-9]{1,8}|21[0-3][0-9]{1,7}|214[0-6][0-9]{1,7}|2147[0-3][0-9]{1,6}|21474[0-7][0-9]{1,5}|214748[0-2][0-9]{1,4}|2147483[0-5][0-9]{1,3}|21474836[0-3][0-9]{1,2}|214748364[0-7][0-9]{1,9}|[0-1][0-9]{1,8}|20[0-9]{1,8}|21[0-3][0-9]{1,7}|214[0-6][0-9]{1,7}|2147[0-3][0-9]{1,6}|21474[0-7][0-9]{1,5}|214748[0-2][0-9]{1,4}|2147483[0-5][0-9]{1,3}|21474836[0-3][0-9]{1,2}|214748364[0-7]Maybe it would help you to remember.",
                "That's how I remembered 2147483647:2147483647\n214 - because 2.14 is approximately pi-1\n48 = 6*8\n64 = 8*8\n214 - because 2.14 is approximately pi-148 = 6*864 = 8*8Write these horizontally:214_48_64_\nand insert:\n   ^  ^  ^\n   7  3  7 - which is Boeing's airliner jet (thanks, sgorozco)\n214_48_64_\nand insert:\n   ^  ^  ^\n   7  3  7 - which is Boeing's airliner jet (thanks, sgorozco)\nNow you've got 2147483647.Hope this helps at least a bit.",
                "2^(x+y) = 2^x * 2^y\n\n2^10 ~ 1,000\n2^20 ~ 1,000,000\n2^30 ~ 1,000,000,000\n2^40 ~ 1,000,000,000,000\n(etc.)\n\n2^1 = 2\n2^2 = 4\n2^3 = 8\n2^4 = 16\n2^5 = 32\n2^6 = 64\n2^7 = 128\n2^8 = 256\n2^9 = 512\n2^(x+y) = 2^x * 2^y\n\n2^10 ~ 1,000\n2^20 ~ 1,000,000\n2^30 ~ 1,000,000,000\n2^40 ~ 1,000,000,000,000\n(etc.)\n\n2^1 = 2\n2^2 = 4\n2^3 = 8\n2^4 = 16\n2^5 = 32\n2^6 = 64\n2^7 = 128\n2^8 = 256\n2^9 = 512\nSo, 2^31 (signed int max) is 2^30 (about 1 billion) times 2^1 (2), or about 2 billion. And 2^32 is 2^30 * 2^2 or about 4 billion. This method of approximation is accurate enough even out to around 2^64 (where the error grows to about 15%).If you need an exact answer then you should pull up a calculator.Handy word-aligned capacity approximations:\n2^16 ~= 64 thousand // uint16\n2^32 ~= 4 billion // uint32, IPv4, unixtime\n2^64 ~= 16 quintillion (aka 16 billion billions or 16 million trillions) // uint64, \"bigint\"\n2^128 ~= 256 quintillion quintillion (aka 256 trillion trillion trillions) // IPv6, GUID\n2^16 ~= 64 thousand // uint162^32 ~= 4 billion // uint32, IPv4, unixtime2^64 ~= 16 quintillion (aka 16 billion billions or 16 million trillions) // uint64, \"bigint\"2^128 ~= 256 quintillion quintillion (aka 256 trillion trillion trillions) // IPv6, GUID",
                "Just take any decent calculator and type in \"7FFFFFFF\" in hex mode, then switch to decimal.2147483647.",
                "It's about 2.1 * 10^9. No need to know the exact 2^{31} - 1 = 2,147,483,647.2.1 * 10^92^{31} - 1 = 2,147,483,647CYou can find it in C like that:#include <stdio.h>\n#include <limits.h>\n\nmain() {\n    printf(\"max int:\\t\\t%i\\n\", INT_MAX);\n    printf(\"max unsigned int:\\t%u\\n\", UINT_MAX);\n}\n#include <stdio.h>\n#include <limits.h>\n\nmain() {\n    printf(\"max int:\\t\\t%i\\n\", INT_MAX);\n    printf(\"max unsigned int:\\t%u\\n\", UINT_MAX);\n}\ngives (well, without the ,),max int:          2,147,483,647\nmax unsigned int: 4,294,967,295\nmax int:          2,147,483,647\nmax unsigned int: 4,294,967,295\nC++ 11std::cout << std::numeric_limits<int>::max() << \"\\n\";\nstd::cout << std::numeric_limits<unsigned int>::max() << \"\\n\";\nstd::cout << std::numeric_limits<int>::max() << \"\\n\";\nstd::cout << std::numeric_limits<unsigned int>::max() << \"\\n\";\nJavaYou can get this with Java, too:System.out.println(Integer.MAX_VALUE);\nSystem.out.println(Integer.MAX_VALUE);\nBut keep in mind that Java integers are always signed.Python 2Python has arbitrary precision integers. But in Python 2, they are mapped to C integers. So you can do this:import sys\nsys.maxint\n>>> 2147483647\nsys.maxint + 1\n>>> 2147483648L\nimport sys\nsys.maxint\n>>> 2147483647\nsys.maxint + 1\n>>> 2147483648L\nSo Python switches to long when the integer gets bigger than 2^31 -1long2^31 -1",
                "Here's a mnemonic for remembering 2**31, subtract one to get the maximum integer value.a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9Boys And Dogs Go Duck Hunting, Come Friday Ducks Hide\n2    1   4    7  4    8        3    6      4     8\nBoys And Dogs Go Duck Hunting, Come Friday Ducks Hide\n2    1   4    7  4    8        3    6      4     8\nI've used the powers of two up to 18 often enough to remember them, but even I haven't bothered memorizing 2**31. It's too easy to calculate as needed or use a constant, or estimate as 2G.",
                "32 bits, one for the sign, 31 bits of information:2^31 - 1 = 2147483647\n2^31 - 1 = 2147483647\nWhy -1?\nBecause the first is zero, so the greatest is the count minus one.count minus oneEDIT for cantfindaname88EDIT for cantfindaname88cantfindaname88The count is 2^31 but the greatest can't be 2147483648 (2^31) because we count from 0, not 1.Rank   1 2 3 4 5 6 ... 2147483648\nNumber 0 1 2 3 4 5 ... 2147483647\nRank   1 2 3 4 5 6 ... 2147483648\nNumber 0 1 2 3 4 5 ... 2147483647\nAnother explanation with only 3 bits : 1 for the sign, 2 for the information2^2 - 1 = 3\n2^2 - 1 = 3\nBelow all the possible values with 3 bits: (2^3 = 8 values)1: 100 ==> -4\n2: 101 ==> -3\n3: 110 ==> -2\n4: 111 ==> -1\n5: 000 ==>  0\n6: 001 ==>  1\n7: 010 ==>  2\n8: 011 ==>  3\n1: 100 ==> -4\n2: 101 ==> -3\n3: 110 ==> -2\n4: 111 ==> -1\n5: 000 ==>  0\n6: 001 ==>  1\n7: 010 ==>  2\n8: 011 ==>  3\n",
                "Well, it has 32 bits and hence can store 2^32 different values. Half of those are negative.The solution is 2,147,483,647And the lowest is \u22122,147,483,648.(Notice that there is one more negative value.)",
                "Well, aside from jokes, if you're really looking for a useful memory rule, there is one that I always use for remembering big numbers.Well, aside from jokes, if you're really looking for a useful memory rule, there is one that I always use for remembering big numbers.You need to break down your number into parts from 3-4 digits and remember them visually using projection on your cell phone keyboard. It's easier to show on a picture:As you can see, from now on you just have to remember 3 shapes, 2 of them looks like a Tetris L and one looks like a tick. Which is definitely much easier than memorizing a 10-digit number.you just have to remember 3 shapes, 2 of them looks like a Tetris L and one looks like a tickWhen you need to recall the number just recall the shapes, imagine/look on a phone keyboard and project the shapes on it. Perhaps initially you'll have to look at the keyboard but after just a bit of practice, you'll remember that numbers are going from top-left to bottom-right so you will be able to simply imagine it in your head.Just make sure you remember the direction of shapes and the number of digits in each shape (for instance, in 2147483647 example we have a 4-digit Tetris L and a 3-digit L).You can use this technique to easily remember any important numbers (for instance, I remembered my 16-digit credit card number etc.).",
                "The easiest way to do this for integers is to use hexadecimal, provided that there isn't something like Int.maxInt(). The reason is this:Max unsigned values8-bit 0xFF\n16-bit 0xFFFF\n32-bit 0xFFFFFFFF\n64-bit 0xFFFFFFFFFFFFFFFF\n128-bit 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n8-bit 0xFF\n16-bit 0xFFFF\n32-bit 0xFFFFFFFF\n64-bit 0xFFFFFFFFFFFFFFFF\n128-bit 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\nSigned values, using 7F as the max signed value8-bit 0x7F\n16-bit 0x7FFF\n32-bit 0x7FFFFFFF\n64-bit 0x7FFFFFFFFFFFFFFF\n8-bit 0x7F\n16-bit 0x7FFF\n32-bit 0x7FFFFFFF\n64-bit 0x7FFFFFFFFFFFFFFF\nSigned values, using 80 as the max signed value8-bit 0x80\n16-bit 0x8000\n32-bit 0x80000000\n64-bit 0x8000000000000000\n8-bit 0x80\n16-bit 0x8000\n32-bit 0x80000000\n64-bit 0x8000000000000000\nHow does this work? This is very similar to the binary tactic, and each hex digit is exactly 4 bits. Also, a lot of compilers support hex a lot better than they support binary. F hex to binary: 1111\n8 hex to binary: 1000\n7 hex to binary: 0111\n0 hex to binary: 0000\nF hex to binary: 1111\n8 hex to binary: 1000\n7 hex to binary: 0111\n0 hex to binary: 0000\nSo 7F is equal to 01111111 / 7FFF is equal to 0111111111111111. Also, if you are using this for \"insanely-high constant\", 7F... is safe hex, but it's easy enough to try out 7F and 80 and just print them to your screen to see which one it is.0x7FFF + 0x0001 = 0x8000, so your loss is only one number, so using 0x7F... usually isn't a bad tradeoff for more reliable code, especially once you start using 32-bits or more",
                "First write out 47 twice, (you like Agent 47, right?), keeping spaces as shown (each dash is a slot for a single digit. First 2 slots, then 4)Agent 47--47----47\n--47----47\nThink you have 12 in hand (because 12 = a dozen). Multiply it by 4, first digit of Agent 47's number, i.e. 47, and place the result to the right of first pair you already have1244712 * 4 = 48\n--4748--47 <-- after placing 48 to the right of first 47\n12 * 4 = 48\n--4748--47 <-- after placing 48 to the right of first 47\nThen multiply 12 by 3 (in order to make second digit of Agent 47's number, which is 7, you need 7 - 4 = 3) and put the result to the right of the first 2 pairs, the last pair-slot12377 - 4 = 312 * 3 = 36\n--47483647 <-- after placing 36 to the right of first two pairs\n12 * 3 = 36\n--47483647 <-- after placing 36 to the right of first two pairs\nFinally drag digits one by one from your hand starting from right-most digit (2 in this case) and place them in the first empty slot you get2-47483647 <-- after placing 2\n2147483647 <-- after placing 1\n2-47483647 <-- after placing 2\n2147483647 <-- after placing 1\nThere you have it! For negative limit, you can think of that as 1 more in absolute value than the positive limit.absolute valuePractise a few times, and you will get the hang of it!",
                "2GB(is there a minimum length for answers?)",
                "Assuming .NET -Console.WriteLine(Int32.MaxValue);\nConsole.WriteLine(Int32.MaxValue);\n",
                "If you happen to know your ASCII table off by heart and not MaxInt :\n!GH6G = 21 47 48 36 47ASCII tableMaxInt!GH6G = 21 47 48 36 47",
                "The best rule to memorize it is:\n21 (magic number!)\n47 (just remember it)\n48 (sequential!)\n36 (21 + 15, both magics!)\n47 againThe best rule to memorize it is:2147483647Also it is easier to remember 5 pairs than 10 digits.",
                "The easiest way to remember is to look at  std::numeric_limits< int >::max()std::numeric_limits< int >::max()For example (from MSDN),from MSDN// numeric_limits_max.cpp\n\n#include <iostream>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n   cout << \"The maximum value for type float is:  \"\n        << numeric_limits<float>::max( )\n        << endl;\n   cout << \"The maximum value for type double is:  \"\n        << numeric_limits<double>::max( )\n        << endl;\n   cout << \"The maximum value for type int is:  \"\n        << numeric_limits<int>::max( )\n        << endl;\n   cout << \"The maximum value for type short int is:  \"\n        << numeric_limits<short int>::max( )\n        << endl;\n}\n// numeric_limits_max.cpp\n\n#include <iostream>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n   cout << \"The maximum value for type float is:  \"\n        << numeric_limits<float>::max( )\n        << endl;\n   cout << \"The maximum value for type double is:  \"\n        << numeric_limits<double>::max( )\n        << endl;\n   cout << \"The maximum value for type int is:  \"\n        << numeric_limits<int>::max( )\n        << endl;\n   cout << \"The maximum value for type short int is:  \"\n        << numeric_limits<short int>::max( )\n        << endl;\n}\n",
                "Interestingly, Int32.MaxValue has more characters than 2,147,486,647.But then again, we do have code completion,So I guess all we really have to memorize is Int3<period>M<enter>, which is only 6 characters to type in visual studio.Int3<period>M<enter>UPDATE\nFor some reason I was downvoted. The only reason I can think of is that they didn't understand my first statement.UPDATE\"Int32.MaxValue\" takes at most 14 characters to type.\n2,147,486,647 takes either 10 or 13 characters to type depending on if you put the commas in or not.",
                "Just remember that 2^(10*x) is approximately 10^(3*x) - you're probably already used to this with kilobytes/kibibytes etc.  That is:2^10 = 1024                ~= one thousand\n2^20 = 1024^2 = 1048576    ~= one million\n2^30 = 1024^3 = 1073741824 ~= one billion\n2^10 = 1024                ~= one thousand\n2^20 = 1024^2 = 1048576    ~= one million\n2^30 = 1024^3 = 1073741824 ~= one billion\nSince an int uses 31 bits (+ ~1 bit for the sign), just double 2^30 to get approximately 2 billion.  For an unsigned int using 32 bits, double again for 4 billion.  The error factor gets higher the larger you go of course, but you don't need the exact value memorised (If you need it, you should be using a pre-defined constant for it anyway).  The approximate value is good enough for noticing when something might be a dangerously close to overflowing.",
                "this is how i do it to remember 2,147,483,647To a far savannah quarter optimus trio hexed forty septenary2 - To\n1 - A\n4 - Far\n7 - Savannah\n4 - Quarter\n8 - Optimus\n3 - Trio\n6 - Hexed\n4 - Forty\n7 - Septenary\n2 - To\n1 - A\n4 - Far\n7 - Savannah\n4 - Quarter\n8 - Optimus\n3 - Trio\n6 - Hexed\n4 - Forty\n7 - Septenary\n",
                "What do you mean? It should be easy enough to remember that it is 2^32.\nIf you want a rule to memorize the value of that number, a handy rule of thumb is for converting between binary and decimal in general:2^10 ~ 1000which means 2^20 ~ 1,000,000and 2^30 ~ 1,000,000,000Double that (2^31) is rounghly 2 billion, and doubling that again (2^32) is 4 billion.It's an easy way to get a rough estimate of any binary number. 10 zeroes in binary becomes 3 zeroes in decimal.",
                "In Objective-C (iOS & OSX), just remember these macros:In Objective-C (iOS & OSX), just remember these macros:#define INT8_MAX         127\n#define INT16_MAX        32767\n#define INT32_MAX        2147483647\n#define INT64_MAX        9223372036854775807LL\n\n#define UINT8_MAX         255\n#define UINT16_MAX        65535\n#define UINT32_MAX        4294967295U\n#define UINT64_MAX        18446744073709551615ULL\n#define INT8_MAX         127\n#define INT16_MAX        32767\n#define INT32_MAX        2147483647\n#define INT64_MAX        9223372036854775807LL\n\n#define UINT8_MAX         255\n#define UINT16_MAX        65535\n#define UINT32_MAX        4294967295U\n#define UINT64_MAX        18446744073709551615ULL\n",
                "Int32 means you have 32 bits available to store your number. The highest bit is the sign-bit, this indicates if the number is positive or negative. So you have 2^31 bits for positive and negative numbers. With zero being a positive number you get the logical range of (mentioned before)+2147483647 to -2147483648If you think that is to small, use Int64:+9223372036854775807 to -9223372036854775808And why the hell you want to remember this number? To use in your code? You should always use Int32.MaxValue or Int32.MinValue in your code since these are static values (within the .net core) and thus faster in use than creating a new int with code.My statement: if know this number by memory.. you're just showing off!",
                "Remember this:\n21 IQ ITEM 47It can be de-encoded with any phone pad, or you can just write one down yourself on a paper.In order to remember \"21 IQ ITEM 47\", I would go with \"Hitman:Codename 47 had 21 missions, which were each IQ ITEM's by themselves\".Or \"I clean teeth at 21:47 every day, because I have high IQ and don't like items in my mouth\"."
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Display number with leading zeros",
                "display numbers with zeros in the lead",
                "display a number with first zeros"
            ],
            "responses": [
                "In Python 2 (and Python 3) you can do:number = 1\nprint(\"%02d\" % (number,))\nnumber = 1\nprint(\"%02d\" % (number,))\nBasically % is like printf or sprintf (see docs).%printfsprintfdocsFor Python 3.+, the same behavior can also be achieved with format:formatformatnumber = 1\nprint(\"{:02d}\".format(number))\nnumber = 1\nprint(\"{:02d}\".format(number))\nFor Python 3.6+ the same behavior can be achieved with f-strings:f-stringsnumber = 1\nprint(f\"{number:02d}\")\nnumber = 1\nprint(f\"{number:02d}\")\n",
                "You can use str.zfill:str.zfillstr.zfillprint(str(1).zfill(2))\nprint(str(10).zfill(2))\nprint(str(100).zfill(2))\nprint(str(1).zfill(2))\nprint(str(10).zfill(2))\nprint(str(100).zfill(2))\nprints:01\n10\n100\n01\n10\n100\n",
                "In Python 2.6+ and 3.0+, you would use the format() string method:format()format()for i in (1, 10, 100):\n    print('{num:02d}'.format(num=i))\nfor i in (1, 10, 100):\n    print('{num:02d}'.format(num=i))\nor using the built-in (for a single number):print(format(i, '02d'))\nprint(format(i, '02d'))\nSee the PEP-3101 documentation for the new formatting functions.PEP-3101",
                "print('{:02}'.format(1))\nprint('{:02}'.format(10))\nprint('{:02}'.format(100))\nprint('{:02}'.format(1))\nprint('{:02}'.format(10))\nprint('{:02}'.format(100))\nprints:01\n10\n100\n01\n10\n100\n",
                "In Python >= 3.6, you can do this succinctly with the new f-strings that were introduced by using:Python >= 3.6f'{val:02}'\nf'{val:02}'\nwhich prints the variable with name val with a fill value of 0 and a width of 2.valfillfill0widthwidth2For your specific example you can do this nicely in a loop:a, b, c = 1, 10, 100\nfor val in [a, b, c]:\n    print(f'{val:02}')\na, b, c = 1, 10, 100\nfor val in [a, b, c]:\n    print(f'{val:02}')\nwhich prints:01 \n10\n100\n01 \n10\n100\nFor more information on f-strings, take a look at PEP 498 where they were introduced.PEP 498",
                "Or this:print '{0:02d}'.format(1)print '{0:02d}'.format(1)",
                "x = [1, 10, 100]\nfor i in x:\n    print '%02d' % i\nx = [1, 10, 100]\nfor i in x:\n    print '%02d' % i\nresults in:01\n10\n100\n01\n10\n100\nRead more information about string formatting using % in the documentation.more information about string formatting using %",
                "The Pythonic way to do this:str(number).rjust(string_width, fill_char)\nstr(number).rjust(string_width, fill_char)\nThis way, the original string is returned unchanged if its length is greater than string_width. Example:a = [1, 10, 100]\nfor num in a:\n    print str(num).rjust(2, '0')\na = [1, 10, 100]\nfor num in a:\n    print str(num).rjust(2, '0')\nResults:01\n10\n100\n01\n10\n100\n",
                "Or another solution.  \"{:0>2}\".format(number)\n\"{:0>2}\".format(number)\n",
                "You can do this with f strings.f stringsimport numpy as np\n\nprint(f'{np.random.choice([1, 124, 13566]):0>8}')\nimport numpy as np\n\nprint(f'{np.random.choice([1, 124, 13566]):0>8}')\nThis will print constant length of 8, and pad the rest with leading 0.000000001\n00000124\n00013566\n00000001\n00000124\n00013566\n",
                "This is how I do it:str(1).zfill(len(str(total)))\nstr(1).zfill(len(str(total)))\nBasically zfill takes the number of leading zeros you want to add, so it's easy to take the biggest number, turn it into a string and get the length, like this:\nPython 3.6.5 (default, May 11 2018, 04:00:52) \n[GCC 8.1.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> total = 100\n>>> print(str(1).zfill(len(str(total))))\n001\n>>> total = 1000\n>>> print(str(1).zfill(len(str(total))))\n0001\n>>> total = 10000\n>>> print(str(1).zfill(len(str(total))))\n00001\n>>> \n",
                "Use a format string - http://docs.python.org/lib/typesseq-strings.htmlhttp://docs.python.org/lib/typesseq-strings.htmlFor example:python -c 'print \"%(num)02d\" % {\"num\":5}'\npython -c 'print \"%(num)02d\" % {\"num\":5}'\n",
                "width = 5\nnum = 3\nformatted = (width - len(str(num))) * \"0\" + str(num)\nprint formatted\nwidth = 5\nnum = 3\nformatted = (width - len(str(num))) * \"0\" + str(num)\nprint formatted\n",
                "Use:'00'[len(str(i)):] + str(i)\n'00'[len(str(i)):] + str(i)\nOr with the math module:mathimport math\n'00'[math.ceil(math.log(i, 10)):] + str(i)\nimport math\n'00'[math.ceil(math.log(i, 10)):] + str(i)\n",
                "All of these create the string \"01\":>python -m timeit \"'{:02d}'.format(1)\"\n1000000 loops, best of 5: 357 nsec per loop\n\n>python -m timeit \"'{0:0{1}d}'.format(1,2)\"\n500000 loops, best of 5: 607 nsec per loop\n\n>python -m timeit \"f'{1:02d}'\"\n1000000 loops, best of 5: 281 nsec per loop\n\n>python -m timeit \"f'{1:0{2}d}'\"\n500000 loops, best of 5: 423 nsec per loop\n\n>python -m timeit \"str(1).zfill(2)\"\n1000000 loops, best of 5: 271 nsec per loop\n\n>python\nPython 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 23:11:46) [MSC v.1916 64 bit (AMD64)] on win32\n>python -m timeit \"'{:02d}'.format(1)\"\n1000000 loops, best of 5: 357 nsec per loop\n\n>python -m timeit \"'{0:0{1}d}'.format(1,2)\"\n500000 loops, best of 5: 607 nsec per loop\n\n>python -m timeit \"f'{1:02d}'\"\n1000000 loops, best of 5: 281 nsec per loop\n\n>python -m timeit \"f'{1:0{2}d}'\"\n500000 loops, best of 5: 423 nsec per loop\n\n>python -m timeit \"str(1).zfill(2)\"\n1000000 loops, best of 5: 271 nsec per loop\n\n>python\nPython 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 23:11:46) [MSC v.1916 64 bit (AMD64)] on win32\n",
                "This would be the Python way, although I would include the parameter for clarity - \"{0:0>2}\".format(number), if someone will wants nLeadingZeros they should note they can also do:\"{0:0>{1}}\".format(number, nLeadingZeros + 1)",
                "You could also do:'{:0>2}'.format(1)\n'{:0>2}'.format(1)\nwhich will return a string.",
                "Its built into python with string formattingf'{number:02d}'\nf'{number:02d}'\n",
                "If dealing with numbers that are either one or two digits:'0'+str(number)[-2:] or '0{0}'.format(number)[-2:]'0'+str(number)[-2:]'0{0}'.format(number)[-2:]"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Maximum and Minimum values for ints",
                "Maximum and Minimum values for ints"
            ],
            "responses": [
                "Python 3In Python 3, this question doesn't apply. The plain int type is unbound.intHowever, you might actually be looking for information about the current interpreter's word size, which will be the same as the machine's word size in most cases. That information is still available in Python 3 as sys.maxsize, which is the maximum value representable by a signed word. Equivalently, it's the size of the largest possible list or in-memory sequence.word sizeword sizesys.maxsizesequenceGenerally, the maximum value representable by an unsigned word will be sys.maxsize * 2 + 1, and the number of bits in a word will be math.log2(sys.maxsize * 2 + 2). See this answer for more information.sys.maxsize * 2 + 1math.log2(sys.maxsize * 2 + 2)this answerPython 2In Python 2, the maximum value for plain int values is available as sys.maxint:intsys.maxint>>> sys.maxint\n9223372036854775807\n>>> sys.maxint\n9223372036854775807\nYou can calculate the minimum value with -sys.maxint - 1 as shown here.-sys.maxint - 1herePython seamlessly switches from plain to long integers once you exceed this value. So most of the time, you won't need to know it.",
                "If you just need a number that's bigger than all others, you can usefloat('inf')\nfloat('inf')\nin similar fashion, a number smaller than all others:float('-inf')\nfloat('-inf')\nThis works in both python 2 and 3.",
                "The sys.maxint constant has been removed from Python 3.0 onward, instead use sys.maxsize.sys.maxintsys.maxintsys.maxsizesys.maxsize\nIntegers\n\nPEP 237: Essentially, long renamed to int. That is, there is only one built-in integral type, named int; but it behaves mostly like the\n  old long type.\nPEP 238: An expression like 1/2 returns a float. Use 1//2 to get the truncating behavior. (The latter syntax has existed for years, at\n  least since Python 2.2.)\nThe sys.maxint constant was removed, since there is no longer a limit to the value of integers. However, sys.maxsize can be used as an\n  integer larger than any practical list or string index. It conforms to\n  the implementation\u2019s \u201cnatural\u201d integer size and is typically the same\n  as sys.maxint in previous releases on the same platform (assuming the\n  same build options).\nThe repr() of a long integer doesn\u2019t include the trailing L anymore, so code that unconditionally strips that character will chop off the\n  last digit instead. (Use str() instead.)\nOctal literals are no longer of the form 0720; use 0o720 instead.\n\nIntegers\nPEP 237: Essentially, long renamed to int. That is, there is only one built-in integral type, named int; but it behaves mostly like the\n  old long type.\nPEP 238: An expression like 1/2 returns a float. Use 1//2 to get the truncating behavior. (The latter syntax has existed for years, at\n  least since Python 2.2.)\nThe sys.maxint constant was removed, since there is no longer a limit to the value of integers. However, sys.maxsize can be used as an\n  integer larger than any practical list or string index. It conforms to\n  the implementation\u2019s \u201cnatural\u201d integer size and is typically the same\n  as sys.maxint in previous releases on the same platform (assuming the\n  same build options).\nThe repr() of a long integer doesn\u2019t include the trailing L anymore, so code that unconditionally strips that character will chop off the\n  last digit instead. (Use str() instead.)\nOctal literals are no longer of the form 0720; use 0o720 instead.\nPEP 237: Essentially, long renamed to int. That is, there is only one built-in integral type, named int; but it behaves mostly like the\n  old long type.PEP 238: An expression like 1/2 returns a float. Use 1//2 to get the truncating behavior. (The latter syntax has existed for years, at\n  least since Python 2.2.)The sys.maxint constant was removed, since there is no longer a limit to the value of integers. However, sys.maxsize can be used as an\n  integer larger than any practical list or string index. It conforms to\n  the implementation\u2019s \u201cnatural\u201d integer size and is typically the same\n  as sys.maxint in previous releases on the same platform (assuming the\n  same build options).The repr() of a long integer doesn\u2019t include the trailing L anymore, so code that unconditionally strips that character will chop off the\n  last digit instead. (Use str() instead.)Octal literals are no longer of the form 0720; use 0o720 instead.Refer : https://docs.python.org/3/whatsnew/3.0.html#integershttps://docs.python.org/3/whatsnew/3.0.html#integers",
                "For Python 3, it isimport sys\nmax_size = sys.maxsize\nmin_size = -sys.maxsize - 1\nimport sys\nmax_size = sys.maxsize\nmin_size = -sys.maxsize - 1\n",
                "In Python integers will automatically switch from a fixed-size int representation into a variable width long representation once you pass the value sys.maxint, which is either 231 - 1 or 263 - 1 depending on your platform. Notice the L that gets appended here:intlonglongsys.maxintsys.maxint3163L>>> 9223372036854775807\n9223372036854775807\n>>> 9223372036854775808\n9223372036854775808L\n>>> 9223372036854775807\n9223372036854775807\n>>> 9223372036854775808\n9223372036854775808L\nFrom the Python manual:Python manual\nNumbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including binary, hex, and octal numbers) yield plain integers unless the value they denote is too large to be represented as a plain integer, in which case they yield a long integer. Integer literals with an 'L' or 'l' suffix yield long integers ('L' is preferred because 1l looks too much like eleven!).\nNumbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including binary, hex, and octal numbers) yield plain integers unless the value they denote is too large to be represented as a plain integer, in which case they yield a long integer. Integer literals with an 'L' or 'l' suffix yield long integers ('L' is preferred because 1l looks too much like eleven!).'L''l''L'1lPython tries very hard to pretend its integers are mathematical integers and are unbounded. It can, for instance, calculate a googol with ease:googol>>> 10**100\n10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000L\n>>> 10**100\n10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000L\n",
                "You may use 'inf' like this:import math\nbool_true = 0 < math.inf\nbool_false = 0 < -math.inf\nimport math\nbool_true = 0 < math.inf\nbool_false = 0 < -math.inf\nRefer: math \u2014 Mathematical functionsmath \u2014 Mathematical functions",
                "If you want the max for array or list indices (equivalent to size_t in C/C++), you can use numpy:size_tnp.iinfo(np.intp).max\nnp.iinfo(np.intp).max\nThis is same as sys.maxsize however advantage is that you don't need import sys just for this.sys.maxsizeIf you want max for native int on the machine:np.iinfo(np.intc).max\nnp.iinfo(np.intc).max\nYou can look at other available types in doc.docFor floats you can also use sys.float_info.max.sys.float_info.max",
                "sys.maxsize is not the actually the maximum integer value which is supported. You can double maxsize and multiply it by itself and it stays a valid and correct value.sys.maxsizeHowever, if you try sys.maxsize ** sys.maxsize, it will hang your machine for a significant amount of time. As many have pointed out, the byte and bit size does not seem to be relevant because it practically doesn't exist. I guess python just happily expands it's integers when it needs more memory space. So in general there is no limit.sys.maxsize ** sys.maxsizeNow, if you're talking about packing or storing integers in a safe way where they can later be retrieved with integrity then of course that is relevant.  I'm really not sure about packing but I know python's pickle module handles those things well. String representations obviously have no practical limit.pickleSo really, the bottom line is: what is your applications limit?  What does it require for numeric data?  Use that limit instead of python's fairly nonexistent integer limit.",
                "I rely heavily on commands like this.python -c 'import sys; print(sys.maxsize)'\npython -c 'import sys; print(sys.maxsize)'\nMax int returned: 92233720368547758079223372036854775807For more references for 'sys' you should accesshttps://docs.python.org/3/library/sys.htmlhttps://docs.python.org/3/library/sys.htmlhttps://docs.python.org/3/library/sys.html#sys.maxsizehttps://docs.python.org/3/library/sys.html#sys.maxsize"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Checking whether a variable is an integer or not [duplicate]",
                "checking whether a variable is an integer or not",
                "checking whether a variable is an integer or not duplicated"
            ],
            "responses": [
                "If you need to do this, doisinstance(<var>, int)\nisinstance(<var>, int)\nunless you are in Python 2.x in which case you wantisinstance(<var>, (int, long))\nisinstance(<var>, (int, long))\nDo not use type. It is almost never the right answer in Python, since it blocks all the flexibility of polymorphism. For instance, if you subclass int, your new class should register as an int, which type will not do:typeintinttypeclass Spam(int): pass\nx = Spam(0)\ntype(x) == int # False\nisinstance(x, int) # True\nclass Spam(int): pass\nx = Spam(0)\ntype(x) == int # False\nisinstance(x, int) # True\nThis adheres to Python's strong polymorphism: you should allow any object that behaves like an int, instead of mandating that it be one.intBUTThe classical Python mentality, though, is that it's easier to ask forgiveness than permission. In other words, don't check whether x is an integer; assume that it is and catch the exception results if it isn't:easier to ask forgiveness than permissionxtry:\n    x += 1\nexcept TypeError:\n    ...\ntry:\n    x += 1\nexcept TypeError:\n    ...\nThis mentality is slowly being overtaken by the use of abstract base classes, which let you register exactly what properties your object should have (adding? multiplying? doubling?) by making it inherit from a specially-constructed class. That would be the best solution, since it will permit exactly those objects with the necessary and sufficient attributes, but you will have to read the docs on how to use it.abstract base classesexactly",
                "All proposed answers so far seem to miss the fact that a double (floats in python are actually doubles) can also be an integer (if it has nothing after the decimal point).  I use the built-in is_integer() method on doubles to check this.is_integer()Example (to do something every xth time in a for loop):for index in range(y): \n    # do something\n    if (index/x.).is_integer():\n        # do something special\nfor index in range(y): \n    # do something\n    if (index/x.).is_integer():\n        # do something special\nEdit:You can always convert to a float before calling this method. The three possibilities:>>> float(5).is_integer()\nTrue\n>>> float(5.1).is_integer()\nFalse\n>>> float(5.0).is_integer()\nTrue\n>>> float(5).is_integer()\nTrue\n>>> float(5.1).is_integer()\nFalse\n>>> float(5.0).is_integer()\nTrue\nOtherwise, you could check if it is an int first like Agostino said:def is_int(val):\n    if type(val) == int:\n        return True\n    else:\n        if val.is_integer():\n            return True\n        else:\n            return False\ndef is_int(val):\n    if type(val) == int:\n        return True\n    else:\n        if val.is_integer():\n            return True\n        else:\n            return False\n",
                "Here's a summary of the different methods mentioned here:\nint(x) == x\ntry x = operator.index(x)\nisinstance(x, int)\nisinstance(x, numbers.Integral)\nint(x) == xint(x) == xtry x = operator.index(x)try x = operator.index(x)isinstance(x, int)isinstance(x, int)isinstance(x, numbers.Integral)isinstance(x, numbers.Integral)and here's how they apply to a variety of numerical types that have integer value:You can see they aren't 100% consistent.  Fraction and Rational are conceptually the same, but one supplies a .index() method and the other doesn't.  Complex types don't like to convert to int even if the real part is integral and imaginary part is 0..index()(np.int8|16|32|64(5) means that np.int8(5), np.int32(5), etc. all behave identically)np.int8|16|32|64(5)np.int8(5)np.int32(5)",
                "If you really need to check then it's better to use abstract base classes rather than concrete classes. For an integer that would mean:reallyabstract base classes>>> import numbers\n>>> isinstance(3, numbers.Integral)\nTrue\n>>> import numbers\n>>> isinstance(3, numbers.Integral)\nTrue\nThis doesn't restrict the check to just int, or just int and long, but also allows other user-defined types that behave as integers to work.intintlong",
                ">>> isinstance(3, int)\nTrue\n>>> isinstance(3, int)\nTrue\nSee here for more.hereNote that this does not help if you're looking for int-like attributes. In this case you may also want to check for long:intlong>>> isinstance(3L, (long, int))\nTrue\n>>> isinstance(3L, (long, int))\nTrue\nI've seen checks of this kind against an array/index type in the Python source, but I don't think that's visible outside of C.Token SO reply: Are you sure you should be checking its type? Either don't pass a type you can't handle, or don't try to outsmart your potential code reusers, they may have a good reason not to pass an int to your function.Token SO reply:",
                "Why not try something like:if x%1 == 0: \nif x%1 == 0: \n",
                "Rather than over complicate things, why not just a simpleif type(var) is int:\nif type(var) is int:\n",
                "A simple method I use in all my software is this. It checks whether the variable is made up of numbers.test = input(\"Enter some text here: \")\nif test.isdigit() == True:\n   print(\"This is a number.\")\nelse:\n   print(\"This is not a number.\")\ntest = input(\"Enter some text here: \")\nif test.isdigit() == True:\n   print(\"This is a number.\")\nelse:\n   print(\"This is not a number.\")\n",
                "You can also use str.isdigit. Try looking up help(str.isdigit)str.isdigithelp(str.isdigit)def is_digit(str):\n      return str.isdigit()\ndef is_digit(str):\n      return str.isdigit()\n",
                "Found a related question here on SO itself.related questionPython developers prefer to not check types but do a type specific operation and catch a TypeError exception. But if you don't know the type then you have the following.TypeError>>> i = 12345\n>>> type(i)\n<type 'int'>\n>>> type(i) is int\nTrue\n>>> i = 12345\n>>> type(i)\n<type 'int'>\n>>> type(i) is int\nTrue\n",
                "it's really astounding to see such a heated discussion coming up when such a basic, valid and, i believe, mundane question is being asked. some people have pointed out that type-checking against int (and long) might loose cases where a big decimal number is encountered. quite right.intlongsome people have pointed out that you should 'just do x + 1 and see whether that fails. well, for one thing, this works on floats too, and, on the other hand, it's easy to construct a class that is definitely not very numeric, yet defines the + operator in some way.x + 1+i am at odds with many posts vigorously declaring that you should not check for types. well, GvR once said something to the effect that in pure theory, that may be right, but in practice, isinstance often serves a useful purpose (that's a while ago, don't have the link; you can read what GvR says about related issues in posts like this one).isinstanceposts like this onewhat is funny is how many people seem to assume that the OP's intent was to check whether the type of a given x is a numerical integer type\u2014what i understood is what i normally mean when using the OP's words: whether x represents an integer number. and this can be very important: like ask someone how many items they'd want to pick, you may want to check you get a non-negative integer number back. use cases like this abound. typexxit's also, in my opinion, important to see that (1) type checking is but ONE\u2014and often quite coarse\u2014measure of program correctness, because (2) it is often bounded values that make sense, and out-of-bounds values that make nonsense. sometimes just some intermittent values make sense\u2014like considering all numbers, only those real (non-complex), integer numbers might be possible in a given case. funny non-one seems to mention checking for x == math.floor( x ). if that should give an error with some big decimal class, well, then maybe it's time to re-think OOP paradigms. there is also PEP 357 that considers how to use not-so-obviously-int-but-certainly-integer-like values to be used as list indices. not sure whether i like the solution.x == math.floor( x )PEP 357int",
                "If you want to check that a string consists of only digits, but converting to an int won't help, you can always just use regex.import re\nx = \"01234\"\nmatch = re.search(\"^\\d+$\", x)\ntry: x = match.group(0)\nexcept AttributeError: print(\"not a valid number\")\n\nResult: x == \"01234\"\nimport re\nx = \"01234\"\nmatch = re.search(\"^\\d+$\", x)\ntry: x = match.group(0)\nexcept AttributeError: print(\"not a valid number\")\n\nResult: x == \"01234\"\nIn this case, if x were \"hello\", converting it to a numeric type would throw a ValueError, but data would also be lost in the process. Using a regex and catching an AttributeError would allow you to confirm numeric characters in a string with, for instance, leading 0's.If you didn't want it to throw an AttributeError, but instead just wanted to look for more specific problems, you could vary the regex and just check the match:import re\nx = \"h01234\"\nmatch = re.search(\"\\D\", x)\nif not match:\n    print(\"x is a number\")\nelse:\n    print(\"encountered a problem at character:\", match.group(0))\n\nResult: \"encountered a problem at character: h\"\nimport re\nx = \"h01234\"\nmatch = re.search(\"\\D\", x)\nif not match:\n    print(\"x is a number\")\nelse:\n    print(\"encountered a problem at character:\", match.group(0))\n\nResult: \"encountered a problem at character: h\"\nThat actually shows you where the problem occurred without the use of exceptions. Again, this is not for testing the type, but rather the characters themselves. This gives you much more flexibility than simply checking for types, especially when converting between types can lose important string data, like leading 0's.",
                "why not just check if the value you want to check is equal to itself cast as an integer as shown below?def isInt(val):\n    return val == int(val)\ndef isInt(val):\n    return val == int(val)\n",
                "It is very simple to check in python. You can do like this:Suppose you want to check a variable is integer or not!## For checking a variable is integer or not in python\n\nif type(variable) is int:\n     print(\"This line will be executed\")\nelse:\n     print(\"Not an integer\")\n## For checking a variable is integer or not in python\n\nif type(variable) is int:\n     print(\"This line will be executed\")\nelse:\n     print(\"Not an integer\")\n",
                "If you are reading from a file and you have an array or dictionary with values of multiple datatypes, the following will be useful.\nJust check whether the variable can be type casted to int(or any other datatype you want to enforce) or not. try :\n    int(a);\n    #Variable a is int\nexcept ValueError : \n    # Variable a is not an int\ntry :\n    int(a);\n    #Variable a is int\nexcept ValueError : \n    # Variable a is not an int\n",
                "In the presence of numpy check like ..numpyisinstance(var, numbers.Integral)\nisinstance(var, numbers.Integral)\n.. (slow) or ..isinstance(var, (int, long, np.integer))\nisinstance(var, (int, long, np.integer))\n.. in order to match all type variants like np.int8, np.uint16, ...np.int8np.uint16(Drop long in PY3)longRecognizing ANY integer-like object from anywhere is a tricky guessing game. Checking ANYvar & 0 == 0 \nvar & 0 == 0 \nfor truth and non-exception may be a good bet. Similarly, checking for signed integer type exclusively:signed integer type exclusivelyvar ^ -1 ==  -var - 1\nvar ^ -1 ==  -var - 1\n",
                "If the variable is entered like a string (e.g. '2010'): '2010'if variable and variable.isdigit():\n    return variable #or whatever you want to do with it. \nelse: \n    return \"Error\" #or whatever you want to do with it.\nif variable and variable.isdigit():\n    return variable #or whatever you want to do with it. \nelse: \n    return \"Error\" #or whatever you want to do with it.\nBefore using this I worked it out with try/except and checking for (int(variable)), but it was longer code. I wonder if there's any difference in use of resources or speed.try/except(int(variable))",
                "A simple way to do this is to directly check if the remainder on division by 1 is 0 or not.if this_variable % 1 == 0:\n    list.append(this_variable)\nelse:\n    print 'Not an Integer!'\nif this_variable % 1 == 0:\n    list.append(this_variable)\nelse:\n    print 'Not an Integer!'\n",
                "Here is a simple example how you can determine an integerdef is_int(x):\n    print round(x),\n    if x == round(x):\n        print 'True',\n    else:\n        print 'False'\n\nis_int(7.0)   # True\nis_int(7.5)   # False\nis_int(-1)    # True    \ndef is_int(x):\n    print round(x),\n    if x == round(x):\n        print 'True',\n    else:\n        print 'False'\n\nis_int(7.0)   # True\nis_int(7.5)   # False\nis_int(-1)    # True    \n",
                "If you just need the value, operator.index (__index__ special method) is the way to go in my opinion. Since it should work for all types that can be safely cast to an integer. I.e. floats fail, integers, even fancy integer classes that do not implement the Integral abstract class work by duck typing.valueoperator.index__index__operator.index is what is used for list indexing, etc. And in my opinion it should be used for much more/promoted.operator.indexIn fact I would argue it is the only correct way to get integer values if you want to be certain that floating points, due to truncating problems, etc. are rejected and it works with all integral types (i.e. numpy, etc.) even if they may not (yet) support the abstract class. This is what __index__ was introduced for!__index__introduced",
                "If you want to check with no regard for Python version (2.x vs 3.x), use six (PyPI) and it's integer_types attribute:sixsixsixPyPIinteger_typesimport six\n\nif isinstance(obj, six.integer_types):\n    print('obj is an integer!')\nimport six\n\nif isinstance(obj, six.integer_types):\n    print('obj is an integer!')\nWithin six (a very light-weight single-file module), it's simply doing this:siximport sys\nPY3 = sys.version_info[0] == 3\n\nif PY3:\n    integer_types = int,\nelse:\n    integer_types = (int, long)\nimport sys\nPY3 = sys.version_info[0] == 3\n\nif PY3:\n    integer_types = int,\nelse:\n    integer_types = (int, long)\n",
                "use the int function to helpintchecker = float(input('Please enter a integer: '))\nintcheck = 0\nwhile intcheck != 1:\n    if intchecker - int(intchecker) > 0:\n        intchecker = float(input(\"You didn't enter a integer. \"\n                                 \"Please enter a integer: \"))\n    else:\n        intcheck = 1\nprint('you have entered a integer')\nintchecker = float(input('Please enter a integer: '))\nintcheck = 0\nwhile intcheck != 1:\n    if intchecker - int(intchecker) > 0:\n        intchecker = float(input(\"You didn't enter a integer. \"\n                                 \"Please enter a integer: \"))\n    else:\n        intcheck = 1\nprint('you have entered a integer')\n",
                "I was writing a program to check if a number was square and I encountered this issue, the \ncode I used was:import math\nprint (\"this program will tell you if a number is square\")\nprint (\"enter an integer\")\nnum = float(input())\nif num > 0:\n    print (\"ok!\")\n    num = (math.sqrt(num))\n    inter = int(num)\n    if num == inter:\n            print (\"It's a square number, and its root is\")\n            print (num)\n    else:\n            print (\"It's not a square number, but its root is\")\n            print (num)\nelse:\n    print (\"That's not a positive number!\")\nimport math\nprint (\"this program will tell you if a number is square\")\nprint (\"enter an integer\")\nnum = float(input())\nif num > 0:\n    print (\"ok!\")\n    num = (math.sqrt(num))\n    inter = int(num)\n    if num == inter:\n            print (\"It's a square number, and its root is\")\n            print (num)\n    else:\n            print (\"It's not a square number, but its root is\")\n            print (num)\nelse:\n    print (\"That's not a positive number!\")\nTo tell if the number was an integer I converted the float number you get from square rooting the user input to a rounded integer (stored as the value ), if those two numbers were equal then the first number must have been an integer, allowing the program to respond. This may not be the shortest way of doing this but it worked for me. ",
                "You can do this.    if type(x) is int:\nif type(x) is int:\n",
                "#!/usr/bin/env python\n\nimport re\n\ndef is_int(x):\n\n    if(isinstance(x,(int,long))):\n\n        return True\n    matchObj = re.match(r'^-?\\d+\\.(\\d+)',str(x))\n\n        if matchObj:\n\n        x = matchObj.group(1)\n\n        if int(x)-0==0:\n\n            return True\n\n     return False\n\nprint is_int(6)\n\nprint is_int(1.0)\n\nprint is_int(1.1)\n\nprint is_int(0.1)\n\nprint is_int(-956.0)\n#!/usr/bin/env python\n\nimport re\n\ndef is_int(x):\n\n    if(isinstance(x,(int,long))):\n\n        return True\n    matchObj = re.match(r'^-?\\d+\\.(\\d+)',str(x))\n\n        if matchObj:\n\n        x = matchObj.group(1)\n\n        if int(x)-0==0:\n\n            return True\n\n     return False\n\nprint is_int(6)\n\nprint is_int(1.0)\n\nprint is_int(1.1)\n\nprint is_int(0.1)\n\nprint is_int(-956.0)\n",
                "If you have not int you can do just this:intvar = 15.4\nif(var - int(var) != 0):\n    print \"Value is not integer\"\nvar = 15.4\nif(var - int(var) != 0):\n    print \"Value is not integer\"\n",
                "If you want to write a Python 2-3 compatible codeTo test whether a value is an integer (of any kind), you can to do this :# Python 2 and 3: \nimport sys\nif sys.version_info < (3,):\n    integer_types = (int, long,)\nelse:\n    integer_types = (int,)\n\n>>> isinstance(1, integer_types)\nTrue\n\n# Python 2 only:\nif isinstance(x, (int, long)):\n     ...\n\n# Python 3 only:\nif isinstance(x, int):\n    ...\n# Python 2 and 3: \nimport sys\nif sys.version_info < (3,):\n    integer_types = (int, long,)\nelse:\n    integer_types = (int,)\n\n>>> isinstance(1, integer_types)\nTrue\n\n# Python 2 only:\nif isinstance(x, (int, long)):\n     ...\n\n# Python 3 only:\nif isinstance(x, int):\n    ...\nsource : http://python3porting.com/differences.htmlhttp://python3porting.com/differences.html",
                "A more general approach that will attempt to check for both integers and integers given as strings will bedef isInt(anyNumberOrString):\n    try:\n        int(anyNumberOrString) #to check float and int use \"float(anyNumberOrString)\"\n        return True\n    except ValueError :\n        return False\n\nisInt(\"A\") #False\nisInt(\"5\") #True\nisInt(8) #True\nisInt(\"5.88\") #False *see comment above on how to make this True\ndef isInt(anyNumberOrString):\n    try:\n        int(anyNumberOrString) #to check float and int use \"float(anyNumberOrString)\"\n        return True\n    except ValueError :\n        return False\n\nisInt(\"A\") #False\nisInt(\"5\") #True\nisInt(8) #True\nisInt(\"5.88\") #False *see comment above on how to make this True\n",
                "you can do this by:name = 'Bob'\nif type(name) == str:\n    print 'this works'\nelse:\n    print 'this does not work'\nname = 'Bob'\nif type(name) == str:\n    print 'this works'\nelse:\n    print 'this does not work'\nand it will return 'this works'... but if you change name to int(1) then it will return 'this does not work' because it is now a string...\nyou can also try:name = int(5)\nif type(name) == int:\n    print 'this works'\nelse:\n    print 'this does not work'\nname = int(5)\nif type(name) == int:\n    print 'this works'\nelse:\n    print 'this does not work'\nand the same thing will happen",
                "There is another option to do the type check. For example:  n = 14\n  if type(n)==int:\n  return \"this is an int\"\n  n = 14\n  if type(n)==int:\n  return \"this is an int\"\n"
            ]
        },
        {
            "tag": "math",
            "patterns": [
                "Designing function f(f(n)) == -n",
                "Designing function f(f(n)) == -n"
            ],
            "responses": [
                "You didn't say what kind of language they expected... Here's a static solution (Haskell). It's basically messing with the 2 most significant bits:f :: Int -> Int\nf x | (testBit x 30 /= testBit x 31) = negate $ complementBit x 30\n    | otherwise = complementBit x 30\nf :: Int -> Int\nf x | (testBit x 30 /= testBit x 31) = negate $ complementBit x 30\n    | otherwise = complementBit x 30\nIt's much easier in a dynamic language (Python). Just check if the argument is a number X and return a lambda that returns -X:def f(x):\n   if isinstance(x,int):\n      return (lambda: -x)\n   else:\n      return x()\ndef f(x):\n   if isinstance(x,int):\n      return (lambda: -x)\n   else:\n      return x()\n",
                "How about:f(n) = sign(n) - (-1)\u207f * nIn Python:def f(n): \n    if n == 0: return 0\n    if n >= 0:\n        if n % 2 == 1: \n            return n + 1\n        else: \n            return -1 * (n - 1)\n    else:\n        if n % 2 == 1:\n            return n - 1\n        else:\n            return -1 * (n + 1)\ndef f(n): \n    if n == 0: return 0\n    if n >= 0:\n        if n % 2 == 1: \n            return n + 1\n        else: \n            return -1 * (n - 1)\n    else:\n        if n % 2 == 1:\n            return n - 1\n        else:\n            return -1 * (n + 1)\nPython automatically promotes integers to arbitrary length longs. In other languages the largest positive integer will overflow, so it will work for all integers except that one.To make it work for real numbers you need to replace the n in (-1)\u207f with { ceiling(n) if n>0; floor(n) if n<0 }.n{ ceiling(n) if n>0; floor(n) if n<0 }In C# (works for any double, except in overflow situations):static double F(double n)\n{\n    if (n == 0) return 0;\n    \n    if (n < 0)\n        return ((long)Math.Ceiling(n) % 2 == 0) ? (n + 1) : (-1 * (n - 1));\n    else\n        return ((long)Math.Floor(n) % 2 == 0) ? (n - 1) : (-1 * (n + 1));\n}\nstatic double F(double n)\n{\n    if (n == 0) return 0;\n    \n    if (n < 0)\n        return ((long)Math.Ceiling(n) % 2 == 0) ? (n + 1) : (-1 * (n - 1));\n    else\n        return ((long)Math.Floor(n) % 2 == 0) ? (n - 1) : (-1 * (n + 1));\n}\n",
                "Here's a proof of why such a function can't exist, for all numbers, if it doesn't use extra information(except 32bits of int):We must have f(0) = 0. (Proof: Suppose f(0) = x. Then f(x) = f(f(0)) = -0 = 0. Now, -x = f(f(x)) = f(0) = x, which means that x = 0.)Further, for any x and y, suppose f(x) = y. We want f(y) = -x then. And f(f(y)) = -y => f(-x) = -y. To summarize: if f(x) = y, then f(-x) = -y, and f(y) = -x, and f(-y) = x.xyf(x) = yf(y) = -xf(f(y)) = -y => f(-x) = -yf(x) = yf(-x) = -yf(y) = -xf(-y) = xSo, we need to divide all integers except 0 into sets of 4, but we have an odd number of such integers; not only that, if we remove the integer that doesn't have a positive counterpart, we still have 2(mod4) numbers.If we remove the 2 maximal numbers left (by abs value), we can get the function:int sign(int n)\n{\n    if(n>0)\n        return 1;\n    else \n        return -1;\n}\n\nint f(int n)\n{\n    if(n==0) return 0;\n    switch(abs(n)%2)\n    {\n        case 1:\n             return sign(n)*(abs(n)+1);\n        case 0:\n             return -sign(n)*(abs(n)-1);\n    }\n}   \nint sign(int n)\n{\n    if(n>0)\n        return 1;\n    else \n        return -1;\n}\n\nint f(int n)\n{\n    if(n==0) return 0;\n    switch(abs(n)%2)\n    {\n        case 1:\n             return sign(n)*(abs(n)+1);\n        case 0:\n             return -sign(n)*(abs(n)-1);\n    }\n}   \nOf course another option, is to not comply for 0, and get the 2 numbers we removed as a bonus. (But that's just a silly if.)",
                "Thanks to overloading in C++:double f(int var)\n{\n return double(var);\n} \n\nint f(double var)\n{\n return -int(var);\n}\n\nint main(){\nint n(42);\nstd::cout<<f(f(n));\n}\ndouble f(int var)\n{\n return double(var);\n} \n\nint f(double var)\n{\n return -int(var);\n}\n\nint main(){\nint n(42);\nstd::cout<<f(f(n));\n}\n",
                "Or, you could abuse the preprocessor:#define f(n) (f##n)\n#define ff(n) -n\n\nint main()\n{\n  int n = -42;\n  cout << \"f(f(\" << n << \")) = \" << f(f(n)) << endl;\n}\n#define f(n) (f##n)\n#define ff(n) -n\n\nint main()\n{\n  int n = -42;\n  cout << \"f(f(\" << n << \")) = \" << f(f(n)) << endl;\n}\n",
                "This is true for all negative numbers.\n    f(n) = abs(n)\nBecause there is one more negative number than there are positive numbers for twos complement integers, f(n) = abs(n) is valid for one more case than f(n) = n > 0 ? -n : n solution that is the same same as f(n) = -abs(n). Got you by one ... :Df(n) = abs(n)f(n) = n > 0 ? -n : nf(n) = -abs(n)UPDATEUPDATENo, it is not valid for one case more as I just recognized by litb's comment ... abs(Int.Min) will just overflow ...abs(Int.Min)I thought about using mod 2 information, too, but concluded, it does not work ... to early. If done right, it will work for all numbers except Int.Min because this will overflow.Int.MinUPDATEUPDATEI played with it for a while, looking for a nice bit manipulation trick, but I could not find a nice one-liner, while the mod 2 solution fits in one.\n    f(n) = 2n(abs(n) % 2) - n + sgn(n)\nIn C#, this becomes the following:public static Int32 f(Int32 n)\n{\n    return 2 * n * (Math.Abs(n) % 2) - n + Math.Sign(n);\n}\npublic static Int32 f(Int32 n)\n{\n    return 2 * n * (Math.Abs(n) % 2) - n + Math.Sign(n);\n}\nTo get it working for all values, you have to replace Math.Abs() with (n > 0) ? +n : -n and include the calculation in an unchecked block. Then you get even Int.Min mapped to itself as unchecked negation does.Math.Abs()(n > 0) ? +n : -nuncheckedInt.MinUPDATEUPDATEInspired by another answer I am going to explain how the function works and how to construct such a function.Lets start at the very beginning. The function f is repeatedly applied to a given value n yielding a sequence of values.fn\n    n => f(n) => f(f(n)) => f(f(f(n))) => f(f(f(f(n)))) => ...\nThe question demands f(f(n)) = -n, that is two successive applications of f negate the argument. Two further applications of f - four in total - negate the argument again yielding n again.f(f(n)) = -nffn\n    n => f(n) => -n => f(f(f(n))) => n => f(n) => ...\nNow there is a obvious cycle of length four. Substituting x = f(n) and noting that the obtained equation f(f(f(n))) = f(f(x)) = -x holds, yields the following.x = f(n)f(f(f(n))) = f(f(x)) = -x\n    n => x => -n => -x => n => ...\nSo we get a cycle of length four with two numbers and the two numbers negated. If you imagine the cycle as a rectangle, negated values are located at opposite corners.One of many solution to construct such a cycle is the following starting from n.\n n                 => negate and subtract one\n-n - 1 = -(n + 1)  => add one\n-n                 => negate and add one\n n + 1             => subtract one\n n\nA concrete example is of such an cycle is +1 => -2 => -1 => +2 => +1. We are almost done. Noting that the constructed cycle contains an odd positive number, its even successor, and both numbers negate, we can easily partition the integers into many such cycles (2^32 is a multiple of four) and have found a function that satisfies the conditions.+1 => -2 => -1 => +2 => +12^32But we have a problem with zero. The cycle must contain 0 => x => 0 because zero is negated to itself. And because the cycle states already 0 => x it follows 0 => x => 0 => x. This is only a cycle of length two and x is turned into itself after two applications, not into -x. Luckily there is one case that solves the problem. If X equals zero we obtain a cycle of length one containing only zero and we solved that problem concluding that zero is a fixed point of f.0 => x => 00 => x0 => x => 0 => xx-xXfDone? Almost. We have 2^32 numbers, zero is a fixed point leaving 2^32 - 1 numbers, and we must partition that number into cycles of four numbers. Bad that 2^32 - 1 is not a multiple of four - there will remain three numbers not in any cycle of length four.2^322^32 - 12^32 - 1I will explain the remaining part of the solution using the smaller set of 3 bit signed itegers ranging from -4 to +3. We are done with zero. We have one complete cycle +1 => -2 => -1 => +2 => +1. Now let us construct the cycle starting at +3.-4+3+1 => -2 => -1 => +2 => +1+3\n    +3 => -4 => -3 => +4 => +3\nThe problem that arises is that +4 is not representable as 3 bit integer. We would obtain +4 by negating -3 to +3 - what is still a valid 3 bit integer - but then adding one to +3 (binary 011) yields 100 binary. Interpreted as unsigned integer it is +4 but we have to interpret it as signed integer -4. So actually -4 for this example or Int.MinValue in the general case is a second fixed point of integer arithmetic negation - 0  and Int.MinValue are mapped to themselve. So the cycle is actually as follows.+4+4-3+3+3011100+4-4-4Int.MinValue0Int.MinValue\n    +3 =>    -4 => -3 => -4 => -3\n-3It is a cycle of length two and additionally +3 enters the cycle via -4. In consequence -4 is correctly mapped to itself after two function applications, +3 is correctly mapped to -3 after two function applications, but -3 is erroneously mapped to itself after two function applications.+3-4-4+3-3-3So we constructed a function that works for all integers but one. Can we do better? No, we cannot. Why? We have to construct cycles of length four and are able to cover the whole integer range up to four values. The remaining values are the two fixed points 0 and Int.MinValue that must be mapped to themselves and two arbitrary integers x and -x that must be mapped to each other by two function applications.0Int.MinValuex-xTo map x to -x and vice versa they must form a four cycle and they must be located at opposite corners of that cycle. In consequence 0 and Int.MinValue have to be at opposite corners, too. This will correctly map x and -x but swap the two fixed points 0 and Int.MinValue after two function applications and leave us with two failing inputs. So it is not possible to construct a function that works for all values, but we have one that works for all values except one and this is the best we can achieve.x-x0Int.MinValuex-x0Int.MinValue",
                "Using complex numbers, you can effectively divide the task of negating a number into two steps: \nmultiply n by i, and you get n*i, which is n rotated 90\u00b0 counter-clockwise\nmultiply again by i, and you get -n\nmultiply n by i, and you get n*i, which is n rotated 90\u00b0 counter-clockwisemultiply again by i, and you get -nThe great thing is that you don't need any special handling code. Just multiplying by i does the job.But you're not allowed to use complex numbers. So you have to somehow create your own imaginary axis, using part of your data range. Since you need exactly as much imaginary (intermediate) values as initial values, you are left with only half the data range.I tried to visualize this on the following figure, assuming signed 8-bit data. You would have to scale this for 32-bit integers. The allowed range for initial n is -64 to +63.\nHere's what the function does for positive n:\nIf n is in 0..63 (initial range), the function call adds 64, mapping n to the range 64..127 (intermediate range)\nIf n is in 64..127 (intermediate range), the function subtracts n from 64, mapping n to the range 0..-63\nIf n is in 0..63 (initial range), the function call adds 64, mapping n to the range 64..127 (intermediate range)If n is in 64..127 (intermediate range), the function subtracts n from 64, mapping n to the range 0..-63For negative n, the function uses the intermediate range -65..-128.",
                "Works except int.MaxValue and int.MinValue    public static int f(int x)\n    {\n\n        if (x == 0) return 0;\n\n        if ((x % 2) != 0)\n            return x * -1 + (-1 *x) / (Math.Abs(x));\n        else\n            return x - x / (Math.Abs(x));\n    }\n    public static int f(int x)\n    {\n\n        if (x == 0) return 0;\n\n        if ((x % 2) != 0)\n            return x * -1 + (-1 *x) / (Math.Abs(x));\n        else\n            return x - x / (Math.Abs(x));\n    }\n",
                "The question doesn't say anything about what the input type and return value of the function f have to be (at least not the way you've presented it)... The question doesn't say anything about what the input type and return value of the function f have to bef...just that when n is a 32-bit integer then f(f(n)) = -nf(f(n)) = -nSo, how about something likeInt64 f(Int64 n)\n{\n    return(n > Int32.MaxValue ? \n        -(n - 4L * Int32.MaxValue):\n        n + 4L * Int32.MaxValue);\n}\nInt64 f(Int64 n)\n{\n    return(n > Int32.MaxValue ? \n        -(n - 4L * Int32.MaxValue):\n        n + 4L * Int32.MaxValue);\n}\nIf n is a 32-bit integer then the statement f(f(n)) == -n will be true.f(f(n)) == -nObviously, this approach could be extended to work for an even wider range of numbers...",
                "for javascript (or other dynamically typed languages) you can have the function accept either an int or an object and return the other. i.e.function f(n) {\n    if (n.passed) {\n        return -n.val;\n    } else {\n        return {val:n, passed:1};\n    }\n}\nfunction f(n) {\n    if (n.passed) {\n        return -n.val;\n    } else {\n        return {val:n, passed:1};\n    }\n}\ngivingjs> f(f(10))  \n-10\njs> f(f(-10))\n10\njs> f(f(10))  \n-10\njs> f(f(-10))\n10\nalternatively you could use overloading in a strongly typed language although that may break the rules ieint f(long n) {\n    return n;\n}\n\nlong f(int n) {\n    return -n;\n}\nint f(long n) {\n    return n;\n}\n\nlong f(int n) {\n    return -n;\n}\n",
                "Depending on your platform, some languages allow you to keep state in the function.  VB.Net, for example:Function f(ByVal n As Integer) As Integer\n    Static flag As Integer = -1\n    flag *= -1\n\n    Return n * flag\nEnd Function\nFunction f(ByVal n As Integer) As Integer\n    Static flag As Integer = -1\n    flag *= -1\n\n    Return n * flag\nEnd Function\nIIRC, C++ allowed this as well.  I suspect they're looking for a different solution though.Another idea is that since they didn't define the result of the first call to the function you could use odd/evenness to control whether to invert the sign:int f(int n)\n{\n   int sign = n>=0?1:-1;\n   if (abs(n)%2 == 0)\n      return ((abs(n)+1)*sign * -1;\n   else\n      return (abs(n)-1)*sign;\n}\nint f(int n)\n{\n   int sign = n>=0?1:-1;\n   if (abs(n)%2 == 0)\n      return ((abs(n)+1)*sign * -1;\n   else\n      return (abs(n)-1)*sign;\n}\nAdd one to the magnitude of all even numbers, subtract one from the magnitude of all odd numbers.  The result of two calls has the same magnitude, but the one call where it's even we swap the sign.  There are some cases where this won't work (-1, max or min int), but it works a lot better than anything else suggested so far.",
                "Exploiting JavaScript exceptions.function f(n) {\n    try {\n        return n();\n    }\n    catch(e) { \n        return function() { return -n; };\n    }\n}\nfunction f(n) {\n    try {\n        return n();\n    }\n    catch(e) { \n        return function() { return -n; };\n    }\n}\n\nf(f(0)) => 0\nf(f(1)) => -1\nf(f(0)) => 0f(f(0)) => 0f(f(1)) => -1f(f(1)) => -1",
                "For all 32-bit values (with the caveat that -0 is -2147483648)int rotate(int x)\n{\n    static const int split = INT_MAX / 2 + 1;\n    static const int negativeSplit = INT_MIN / 2 + 1;\n\n    if (x == INT_MAX)\n        return INT_MIN;\n    if (x == INT_MIN)\n        return x + 1;\n\n    if (x >= split)\n        return x + 1 - INT_MIN;\n    if (x >= 0)\n        return INT_MAX - x;\n    if (x >= negativeSplit)\n        return INT_MIN - x + 1;\n    return split -(negativeSplit - x);\n}\nint rotate(int x)\n{\n    static const int split = INT_MAX / 2 + 1;\n    static const int negativeSplit = INT_MIN / 2 + 1;\n\n    if (x == INT_MAX)\n        return INT_MIN;\n    if (x == INT_MIN)\n        return x + 1;\n\n    if (x >= split)\n        return x + 1 - INT_MIN;\n    if (x >= 0)\n        return INT_MAX - x;\n    if (x >= negativeSplit)\n        return INT_MIN - x + 1;\n    return split -(negativeSplit - x);\n}\nYou basically need to pair each -x => x => -x loop with a y => -y => y loop.  So I paired up opposite sides of the split.splite.g. For 4 bit integers:0 => 7 => -8 => -7 => 0\n1 => 6 => -1 => -6 => 1\n2 => 5 => -2 => -5 => 2\n3 => 4 => -3 => -4 => 3\n0 => 7 => -8 => -7 => 0\n1 => 6 => -1 => -6 => 1\n2 => 5 => -2 => -5 => 2\n3 => 4 => -3 => -4 => 3\n",
                "A C++ version, probably bending the rules somewhat but works for all numeric types (floats, ints, doubles) and even class types that overload the unary minus:template <class T>\nstruct f_result\n{\n  T value;\n};\n\ntemplate <class T>\nf_result <T> f (T n)\n{\n  f_result <T> result = {n};\n  return result;\n}\n\ntemplate <class T>\nT f (f_result <T> n)\n{\n  return -n.value;\n}\n\nvoid main (void)\n{\n  int n = 45;\n  cout << \"f(f(\" << n << \")) = \" << f(f(n)) << endl;\n  float p = 3.14f;\n  cout << \"f(f(\" << p << \")) = \" << f(f(p)) << endl;\n}\ntemplate <class T>\nstruct f_result\n{\n  T value;\n};\n\ntemplate <class T>\nf_result <T> f (T n)\n{\n  f_result <T> result = {n};\n  return result;\n}\n\ntemplate <class T>\nT f (f_result <T> n)\n{\n  return -n.value;\n}\n\nvoid main (void)\n{\n  int n = 45;\n  cout << \"f(f(\" << n << \")) = \" << f(f(n)) << endl;\n  float p = 3.14f;\n  cout << \"f(f(\" << p << \")) = \" << f(f(p)) << endl;\n}\n",
                "x86 asm (AT&T style): ; input %edi\n; output %eax\n; clobbered regs: %ecx, %edx\nf:\n    testl   %edi, %edi\n    je  .zero\n\n    movl    %edi, %eax\n    movl    $1, %ecx\n    movl    %edi, %edx\n    andl    $1, %eax\n    addl    %eax, %eax\n    subl    %eax, %ecx\n    xorl    %eax, %eax\n    testl   %edi, %edi\n    setg    %al\n    shrl    $31, %edx\n    subl    %edx, %eax\n    imull   %ecx, %eax\n    subl    %eax, %edi\n    movl    %edi, %eax\n    imull   %ecx, %eax\n.zero:\n    xorl    %eax, %eax\n    ret\n; input %edi\n; output %eax\n; clobbered regs: %ecx, %edx\nf:\n    testl   %edi, %edi\n    je  .zero\n\n    movl    %edi, %eax\n    movl    $1, %ecx\n    movl    %edi, %edx\n    andl    $1, %eax\n    addl    %eax, %eax\n    subl    %eax, %ecx\n    xorl    %eax, %eax\n    testl   %edi, %edi\n    setg    %al\n    shrl    $31, %edx\n    subl    %edx, %eax\n    imull   %ecx, %eax\n    subl    %eax, %edi\n    movl    %edi, %eax\n    imull   %ecx, %eax\n.zero:\n    xorl    %eax, %eax\n    ret\nCode checked, all possible 32bit integers passed, error with -2147483647 (underflow).",
                "Uses globals...but so?bool done = false\nf(int n)\n{\n  int out = n;\n  if(!done)\n  {  \n      out = n * -1;\n      done = true;\n   }\n   return out;\n}\nbool done = false\nf(int n)\n{\n  int out = n;\n  if(!done)\n  {  \n      out = n * -1;\n      done = true;\n   }\n   return out;\n}\n",
                "This Perl solution works for integers, floats, and strings.works for integers, floats, and stringssub f {\n    my $n = shift;\n    return ref($n) ? -$$n : \\$n;\n}\nsub f {\n    my $n = shift;\n    return ref($n) ? -$$n : \\$n;\n}\nTry some test data.print $_, ' ', f(f($_)), \"\\n\" for -2, 0, 1, 1.1, -3.3, 'foo' '-bar';\nprint $_, ' ', f(f($_)), \"\\n\" for -2, 0, 1, 1.1, -3.3, 'foo' '-bar';\nOutput:-2 2\n0 0\n1 -1\n1.1 -1.1\n-3.3 3.3\nfoo -foo\n-bar +bar\n-2 2\n0 0\n1 -1\n1.1 -1.1\n-3.3 3.3\nfoo -foo\n-bar +bar\n",
                "Nobody ever said f(x) had to be the same type.def f(x):\n    if type(x) == list:\n        return -x[0]\n    return [x]\n\n\nf(2) => [2]\nf(f(2)) => -2\ndef f(x):\n    if type(x) == list:\n        return -x[0]\n    return [x]\n\n\nf(2) => [2]\nf(f(2)) => -2\n",
                "I'm not actually trying to give a solution to the problem itself, but do have a couple of comments, as the question states this problem was posed was part of a (job?) interview:\nI would first ask \"Why would such a function be needed? What is the bigger problem this is part of?\" instead of trying to solve the actual posed problem on the spot. This shows how I think and how I tackle problems like this. Who know? That might even be the actual reason the question is asked in an interview in the first place. If the answer is \"Never you mind, assume it's needed, and show me how you would design this function.\" I would then continue to do so.\nThen, I would write the C# test case code I would use (the obvious: loop from int.MinValue to int.MaxValue, and for each n in that range call f(f(n)) and checking the result is -n), telling I would then use Test Driven Development to get to such a function.\nOnly if the interviewer continues asking for me to solve the posed problem would I actually start to try and scribble pseudocode during the interview itself to try and get to some sort of an answer. However, I don't really think I would be jumping to take the job if the interviewer would be any indication of what the company is like...\nI would first ask \"Why would such a function be needed? What is the bigger problem this is part of?\" instead of trying to solve the actual posed problem on the spot. This shows how I think and how I tackle problems like this. Who know? That might even be the actual reason the question is asked in an interview in the first place. If the answer is \"Never you mind, assume it's needed, and show me how you would design this function.\" I would then continue to do so.Then, I would write the C# test case code I would use (the obvious: loop from int.MinValue to int.MaxValue, and for each n in that range call f(f(n)) and checking the result is -n), telling I would then use Test Driven Development to get to such a function.int.MinValueint.MaxValuenf(f(n))-nOnly if the interviewer continues asking for me to solve the posed problem would I actually start to try and scribble pseudocode during the interview itself to try and get to some sort of an answer. However, I don't really think I would be jumping to take the job if the interviewer would be any indication of what the company is like...Oh, this answer assumes the interview was for a C# programming related position. Would of course be a silly answer if the interview was for a math related position. ;-)",
                "I would you change the 2 most significant bits.00.... => 01.... => 10.....\n\n01.... => 10.... => 11.....\n\n10.... => 11.... => 00.....\n\n11.... => 00.... => 01.....\n00.... => 01.... => 10.....\n\n01.... => 10.... => 11.....\n\n10.... => 11.... => 00.....\n\n11.... => 00.... => 01.....\nAs you can see, it's just an addition, leaving out the carried bit.How did I got to the answer? My first thought was just a need for symmetry. 4 turns to get back where I started. At first I thought, that's 2bits Gray code. Then I thought actually standard binary is enough.",
                "Here is a solution that is inspired by the requirement or claim that complex numbers can not be used to solve this problem. Multiplying by the square root of -1 is an idea, that only seems to fail because -1 does not have a square root over the integers. But playing around with a program like mathematica gives for example the equation\n(18494364652+1) mod (232-3) = 0.\n(18494364652+1) mod (232-3) = 0.232and this is almost as good as having a square root of -1. The result of the function needs to be a signed integer. Hence I'm going to use a modified modulo operation mods(x,n) that returns the integer y congruent to x modulo n that is closest to 0. Only very few programming languages have suc a modulo operation, but it can easily be defined. E.g. in python it is:def mods(x, n):\n    y = x % n\n    if y > n/2: y-= n\n    return y\ndef mods(x, n):\n    y = x % n\n    if y > n/2: y-= n\n    return y\nUsing the equation above, the problem can now be solved as def f(x):\n    return mods(x*1849436465, 2**32-3)\ndef f(x):\n    return mods(x*1849436465, 2**32-3)\nThis satisfies f(f(x)) = -x for all integers in the range [-231-2, 231-2]. The results of f(x) are also in this range, but of course the computation would need 64-bit integers.f(f(x)) = -x[-23131-2, 23131-2]f(x)",
                "C# for a range of 2^32 - 1 numbers, all int32 numbers except (Int32.MinValue)    Func<int, int> f = n =>\n        n < 0\n           ? (n & (1 << 30)) == (1 << 30) ? (n ^ (1 << 30)) : - (n | (1 << 30))\n           : (n & (1 << 30)) == (1 << 30) ? -(n ^ (1 << 30)) : (n | (1 << 30));\n\n    Console.WriteLine(f(f(Int32.MinValue + 1))); // -2147483648 + 1\n    for (int i = -3; i <= 3  ; i++)\n        Console.WriteLine(f(f(i)));\n    Console.WriteLine(f(f(Int32.MaxValue))); // 2147483647\n    Func<int, int> f = n =>\n        n < 0\n           ? (n & (1 << 30)) == (1 << 30) ? (n ^ (1 << 30)) : - (n | (1 << 30))\n           : (n & (1 << 30)) == (1 << 30) ? -(n ^ (1 << 30)) : (n | (1 << 30));\n\n    Console.WriteLine(f(f(Int32.MinValue + 1))); // -2147483648 + 1\n    for (int i = -3; i <= 3  ; i++)\n        Console.WriteLine(f(f(i)));\n    Console.WriteLine(f(f(Int32.MaxValue))); // 2147483647\nprints:2147483647\n3\n2\n1\n0\n-1\n-2\n-3\n-2147483647\n2147483647\n3\n2\n1\n0\n-1\n-2\n-3\n-2147483647\n",
                "Essentially the function has to divide the available range into cycles of size 4, with -n at the opposite end of n's cycle. However, 0 must be part of a cycle of size 1, because otherwise 0->x->0->x != -x. Because of 0 being alone, there must be 3 other values in our range (whose size is a multiple of 4) not in a proper cycle with 4 elements.0->x->0->x != -xI chose these extra weird values to be MIN_INT, MAX_INT, and MIN_INT+1. Furthermore, MIN_INT+1 will map to MAX_INT correctly, but get stuck there and not map back. I think this is the best compromise, because it has the nice property of only the extreme values not working correctly. Also, it means it would work for all BigInts.MIN_INTMAX_INTMIN_INT+1MIN_INT+1MAX_INTallint f(int n):\n    if n == 0 or n == MIN_INT or n == MAX_INT: return n\n    return ((Math.abs(n) mod 2) * 2 - 1) * n + Math.sign(n)\nint f(int n):\n    if n == 0 or n == MIN_INT or n == MAX_INT: return n\n    return ((Math.abs(n) mod 2) * 2 - 1) * n + Math.sign(n)\n",
                "Nobody said it had to be stateless.int32 f(int32 x) {\n    static bool idempotent = false;\n    if (!idempotent) {\n        idempotent = true;\n        return -x;\n    } else {\n        return x;\n    }\n}\nint32 f(int32 x) {\n    static bool idempotent = false;\n    if (!idempotent) {\n        idempotent = true;\n        return -x;\n    } else {\n        return x;\n    }\n}\nCheating, but not as much as a lot of the examples. Even more evil would be to peek up the stack to see if your caller's address is &f, but this is going to be more portable (although not thread safe... the thread-safe version would use TLS). Even more evil:int32 f (int32 x) {\n    static int32 answer = -x;\n    return answer;\n}\nint32 f (int32 x) {\n    static int32 answer = -x;\n    return answer;\n}\nOf course, neither of these works too well for the case of MIN_INT32, but there is precious little you can do about that unless you are allowed to return a wider type.",
                "I could imagine using the 31st bit as an imaginary (i) bit would be an approach that would support half the total range.i",
                "works for n= [0 .. 2^31-1]int f(int n) {\n  if (n & (1 << 31)) // highest bit set?\n    return -(n & ~(1 << 31)); // return negative of original n\n  else\n    return n | (1 << 31); // return n with highest bit set\n}\nint f(int n) {\n  if (n & (1 << 31)) // highest bit set?\n    return -(n & ~(1 << 31)); // return negative of original n\n  else\n    return n | (1 << 31); // return n with highest bit set\n}\n",
                "The problem states \"32-bit signed integers\" but doesn't specify whether they are twos-complement or ones-complement.twos-complementones-complementIf you use ones-complement then all 2^32 values occur in cycles of length four - you don't need a special case for zero, and you also don't need conditionals.In C:int32_t f(int32_t x)\n{\n  return (((x & 0xFFFFU) << 16) | ((x & 0xFFFF0000U) >> 16)) ^ 0xFFFFU;\n}\nint32_t f(int32_t x)\n{\n  return (((x & 0xFFFFU) << 16) | ((x & 0xFFFF0000U) >> 16)) ^ 0xFFFFU;\n}\nThis works by\nExchanging the high and low 16-bit blocks\nInverting one of the blocks\nExchanging the high and low 16-bit blocksInverting one of the blocksAfter two passes we have the bitwise inverse of the original value.  Which in ones-complement representation is equivalent to negation.Examples:Pass |        x\n-----+-------------------\n   0 | 00000001      (+1)\n   1 | 0001FFFF (+131071)\n   2 | FFFFFFFE      (-1)\n   3 | FFFE0000 (-131071)\n   4 | 00000001      (+1)\n\nPass |        x\n-----+-------------------\n   0 | 00000000      (+0)\n   1 | 0000FFFF  (+65535)\n   2 | FFFFFFFF      (-0)\n   3 | FFFF0000  (-65535)\n   4 | 00000000      (+0)\nPass |        x\n-----+-------------------\n   0 | 00000001      (+1)\n   1 | 0001FFFF (+131071)\n   2 | FFFFFFFE      (-1)\n   3 | FFFE0000 (-131071)\n   4 | 00000001      (+1)\n\nPass |        x\n-----+-------------------\n   0 | 00000000      (+0)\n   1 | 0000FFFF  (+65535)\n   2 | FFFFFFFF      (-0)\n   3 | FFFF0000  (-65535)\n   4 | 00000000      (+0)\n",
                ":Dboolean inner = true;\n\nint f(int input) {\n   if(inner) {\n      inner = false;\n      return input;\n   } else {\n      inner = true;\n      return -input;\n   }\n}\nboolean inner = true;\n\nint f(int input) {\n   if(inner) {\n      inner = false;\n      return input;\n   } else {\n      inner = true;\n      return -input;\n   }\n}\n",
                "return x ^ ((x%2) ? 1 : -INT_MAX);\nreturn x ^ ((x%2) ? 1 : -INT_MAX);\n",
                "I'd like to share my point of view on this interesting problem as a mathematician. I think I have the most efficient solution.If I remember correctly, you negate a signed 32-bit integer by just flipping the first bit. For example, if n = 1001 1101 1110 1011 1110 0000 1110 1010, then -n = 0001 1101 1110 1011 1110 0000 1110 1010.So how do we define a function f that takes a signed 32-bit integer and returns another signed 32-bit integer with the property that taking f twice is the same as flipping the first bit?Let me rephrase the question without mentioning arithmetic concepts like integers.How do we define a function f that takes a sequence of zeros and ones of length 32 and returns a sequence of zeros and ones of the same length, with the property that taking f twice is the same as flipping the first bit?Observation: If you can answer the above question for 32 bit case, then you can also answer for 64 bit case, 100 bit case, etc. You just apply f to the first 32 bit.Now if you can answer the question for 2 bit case, Voila!And yes it turns out that changing the first 2 bits is enough.Here's the pseudo-code1. take n, which is a signed 32-bit integer.\n2. swap the first bit and the second bit.\n3. flip the first bit.\n4. return the result.\n1. take n, which is a signed 32-bit integer.\n2. swap the first bit and the second bit.\n3. flip the first bit.\n4. return the result.\nRemark: The step 2 and the step 3 together can be summerised as (a,b) --> (-b, a). Looks familiar? That should remind you of the 90 degree rotation of the plane and the multiplication by the squar root of -1.If I just presented the pseudo-code alone without the long prelude, it would seem like a rabbit out of the hat, I wanted to explain how I got the solution."
            ]
        },
        {
            "tag": "c#",
            "patterns": [
                "How can I convert String to Int?",
                "how do i convert a string in an integer?",
                "how do i convert a string to an integer?",
                "what can i do to convert a string to an int?",
                "how do i convert a string to an int?",
                "how do i convert strings in int?",
                "how do i convert string to int?"
            ],
            "responses": [
                "Try this:int x = Int32.Parse(TextBoxD1.Text);\nint x = Int32.Parse(TextBoxD1.Text);\nor better yet:int x = 0;\n\nInt32.TryParse(TextBoxD1.Text, out x);\nint x = 0;\n\nInt32.TryParse(TextBoxD1.Text, out x);\nAlso, since Int32.TryParse returns a bool you can use its return value to make decisions about the results of the parsing attempt:Int32.TryParseInt32.TryParseboolint x = 0;\n\nif (Int32.TryParse(TextBoxD1.Text, out x))\n{\n    // you know that the parsing attempt\n    // was successful\n}\nint x = 0;\n\nif (Int32.TryParse(TextBoxD1.Text, out x))\n{\n    // you know that the parsing attempt\n    // was successful\n}\nIf you are curious, the difference between Parse and TryParse is best summed up like this:ParseTryParse\nThe TryParse method is like the Parse\n  method, except the TryParse method\n  does not throw an exception if the\n  conversion fails. It eliminates the\n  need to use exception handling to test\n  for a FormatException in the event\n  that s is invalid and cannot be\n  successfully parsed. - MSDN\nThe TryParse method is like the Parse\n  method, except the TryParse method\n  does not throw an exception if the\n  conversion fails. It eliminates the\n  need to use exception handling to test\n  for a FormatException in the event\n  that s is invalid and cannot be\n  successfully parsed. - MSDNMSDN",
                "Convert.ToInt32( TextBoxD1.Text );\nConvert.ToInt32( TextBoxD1.Text );\nUse this if you feel confident that the contents of the text box is a valid int. A safer option isintint val = 0;\nInt32.TryParse( TextBoxD1.Text, out val );\nint val = 0;\nInt32.TryParse( TextBoxD1.Text, out val );\nThis will provide you with some default value you can use. Int32.TryParse also returns a Boolean value indicating whether it was able to parse or not, so you can even use it as the condition of an if statement.Int32.TryParseifif( Int32.TryParse( TextBoxD1.Text, out val ){\n  DoSomething(..);\n} else {\n  HandleBadInput(..);\n}\nif( Int32.TryParse( TextBoxD1.Text, out val ){\n  DoSomething(..);\n} else {\n  HandleBadInput(..);\n}\n",
                "int.TryParse()\nint.TryParse()\nIt won't throw if the text is not numeric.",
                "int myInt = int.Parse(TextBoxD1.Text)\nint myInt = int.Parse(TextBoxD1.Text)\nAnother way would be:bool isConvertible = false;\nint myInt = 0;\n\nisConvertible = int.TryParse(TextBoxD1.Text, out myInt);\nbool isConvertible = false;\nint myInt = 0;\n\nisConvertible = int.TryParse(TextBoxD1.Text, out myInt);\nThe difference between the two is that the first one would throw an exception if the value in your textbox can't be converted, whereas the second one would just return false.",
                "Be careful when using Convert.ToInt32() on a char!\nIt will return the UTF-16 code of the character!Convert.ToInt32()UTF-16If you access the string only in a certain position using the [i] indexing operator, it will return a char and not a string![i]charstringString input = \"123678\";\n                    ^\n                    |\nint indexOfSeven =  4;\n\nint x = Convert.ToInt32(input[indexOfSeven]);             // Returns 55\n\nint x = Convert.ToInt32(input[indexOfSeven].toString());  // Returns 7\nString input = \"123678\";\n                    ^\n                    |\nint indexOfSeven =  4;\n\nint x = Convert.ToInt32(input[indexOfSeven]);             // Returns 55\n\nint x = Convert.ToInt32(input[indexOfSeven].toString());  // Returns 7\n",
                "You need to parse the string, and you also need to ensure that it is truly in the format of an integer.The easiest way is this:int parsedInt = 0;\nif (int.TryParse(TextBoxD1.Text, out parsedInt))\n{\n   // Code for if the string was valid\n}\nelse\n{\n   // Code for if the string was invalid\n}\nint parsedInt = 0;\nif (int.TryParse(TextBoxD1.Text, out parsedInt))\n{\n   // Code for if the string was valid\n}\nelse\n{\n   // Code for if the string was invalid\n}\n",
                "int x = 0;\nint.TryParse(TextBoxD1.Text, out x);\nint x = 0;\nint.TryParse(TextBoxD1.Text, out x);\nThe TryParse statement returns a boolean representing whether the parse has succeeded or not. If it succeeded, the parsed value is stored into the second parameter.See Int32.TryParse Method (String, Int32) for more detailed information.Int32.TryParse Method (String, Int32)Int32.TryParse Method (String, Int32)",
                "Enjoy it...int i = 0;\nstring s = \"123\";\ni =int.Parse(s);\ni = Convert.ToInt32(s);\nint i = 0;\nstring s = \"123\";\ni =int.Parse(s);\ni = Convert.ToInt32(s);\n",
                "While there are already many solutions here that describe int.Parse, there's something important missing in all the answers. Typically, the string representations of numeric values differ by culture. Elements of numeric strings such as currency symbols, group (or thousands) separators, and decimal separators all vary by culture. int.ParseIf you want to create a robust way to parse a string to an integer, it's therefore important to take the culture information into account. If you don't, the current culture settings will be used. That might give a user a pretty nasty surprise -- or even worse, if you're parsing file formats. If you just want English parsing, it's best to simply make it explicit, by specifying the culture settings to use:current culture settingsvar culture = CultureInfo.GetCulture(\"en-US\");\nint result = 0;\nif (int.TryParse(myString, NumberStyles.Integer, culture, out result))\n{\n    // use result...\n}\nvar culture = CultureInfo.GetCulture(\"en-US\");\nint result = 0;\nif (int.TryParse(myString, NumberStyles.Integer, culture, out result))\n{\n    // use result...\n}\nFor more information, read up on CultureInfo, specifically NumberFormatInfo on MSDN.NumberFormatInfo",
                "int x = Int32.TryParse(TextBoxD1.Text, out x) ? x : 0;\nint x = Int32.TryParse(TextBoxD1.Text, out x) ? x : 0;\n",
                "You can write your own extension methodYou can write your own extension methodpublic static class IntegerExtensions\n{\n    public static int ParseInt(this string value, int defaultValue = 0)\n    {\n        int parsedValue;\n        if (int.TryParse(value, out parsedValue))\n        {\n            return parsedValue;\n        }\n\n        return defaultValue;\n    }\n\n    public static int? ParseNullableInt(this string value)\n    {\n        if (string.IsNullOrEmpty(value))\n        {\n            return null;\n        }\n\n        return value.ParseInt();\n    }\n}\npublic static class IntegerExtensions\n{\n    public static int ParseInt(this string value, int defaultValue = 0)\n    {\n        int parsedValue;\n        if (int.TryParse(value, out parsedValue))\n        {\n            return parsedValue;\n        }\n\n        return defaultValue;\n    }\n\n    public static int? ParseNullableInt(this string value)\n    {\n        if (string.IsNullOrEmpty(value))\n        {\n            return null;\n        }\n\n        return value.ParseInt();\n    }\n}\nAnd wherever in code just callAnd wherever in code just callint myNumber = someString.ParseInt(); // Returns value or 0\nint age = someString.ParseInt(18); // With default value 18\nint? userId = someString.ParseNullableInt(); // Returns value or null\nint myNumber = someString.ParseInt(); // Returns value or 0\nint age = someString.ParseInt(18); // With default value 18\nint? userId = someString.ParseNullableInt(); // Returns value or null\nIn this concrete caseIn this concrete caseint yourValue = TextBoxD1.Text.ParseInt();\nint yourValue = TextBoxD1.Text.ParseInt();\n",
                "As explained in the TryParse documentation, TryParse() returns a Boolean which indicates that a valid number was found:TryParse documentationbool success = Int32.TryParse(TextBoxD1.Text, out val);\n\nif (success)\n{\n    // Put val in database\n}\nelse\n{\n    // Handle the case that the string doesn't contain a valid number\n}\nbool success = Int32.TryParse(TextBoxD1.Text, out val);\n\nif (success)\n{\n    // Put val in database\n}\nelse\n{\n    // Handle the case that the string doesn't contain a valid number\n}\n",
                "Conversion of string to int can be done for: int, Int32, Int64 and other data types reflecting integer data types in .NETstringintintInt32Int64Below example shows this conversion:This shows (for info) data adapter element initialized to int value. The same can be done directly like,int xxiiqVal = Int32.Parse(strNabcd);\nint xxiiqVal = Int32.Parse(strNabcd);\nEx.string strNii = \"\";\nUsrDataAdapter.SelectCommand.Parameters[\"@Nii\"].Value = Int32.Parse(strNii );\nstring strNii = \"\";\nUsrDataAdapter.SelectCommand.Parameters[\"@Nii\"].Value = Int32.Parse(strNii );\nLink to see this demo.Link to see this demo",
                "You can convert string to int many different type methods in C#First one is mostly use :string test = \"123\";\nint x = Convert.ToInt16(test);\nstring test = \"123\";\nint x = Convert.ToInt16(test);\nif int value is higher you should use int32 type.Second one:int x = int.Parse(text);\nint x = int.Parse(text);\nif you want to error check, you can use TryParse method. In below I add nullable type;int i=0;\nInt32.TryParse(text, out i) ? i : (int?)null);\nint i=0;\nInt32.TryParse(text, out i) ? i : (int?)null);\nEnjoy your codes....",
                "int i = Convert.ToInt32(TextBoxD1.Text);\nint i = Convert.ToInt32(TextBoxD1.Text);\n",
                "//May be quite some time ago but I just want throw in some line for any one who may still need it\n\nint intValue;\nstring strValue = \"2021\";\n\ntry\n{\n    intValue = Convert.ToInt32(strValue);\n}\ncatch\n{\n    //Default Value if conversion fails OR return specified error\n    // Example \n    intValue = 2000;\n}\n//May be quite some time ago but I just want throw in some line for any one who may still need it\n\nint intValue;\nstring strValue = \"2021\";\n\ntry\n{\n    intValue = Convert.ToInt32(strValue);\n}\ncatch\n{\n    //Default Value if conversion fails OR return specified error\n    // Example \n    intValue = 2000;\n}\n",
                "You can use either,int i = Convert.ToInt32(TextBoxD1.Text);\nint i = Convert.ToInt32(TextBoxD1.Text);\norint i = int.Parse(TextBoxD1.Text);\nint i = int.Parse(TextBoxD1.Text);\n",
                "You can do like below without TryParse or inbuilt functions:static int convertToInt(string a)\n{\n    int x = 0;\n    for (int i = 0; i < a.Length; i++)\n    {\n        int temp = a[i] - '0';\n        if (temp != 0)\n        {\n            x += temp * (int)Math.Pow(10, (a.Length - (i+1)));\n        }\n    }\n    return x;\n}\nstatic int convertToInt(string a)\n{\n    int x = 0;\n    for (int i = 0; i < a.Length; i++)\n    {\n        int temp = a[i] - '0';\n        if (temp != 0)\n        {\n            x += temp * (int)Math.Pow(10, (a.Length - (i+1)));\n        }\n    }\n    return x;\n}\n",
                "You also may use an extension method, so it will be more readable (although everybody is already used to the regular Parse functions).extension methodpublic static class StringExtensions\n{\n    /// <summary>\n    /// Converts a string to int.\n    /// </summary>\n    /// <param name=\"value\">The string to convert.</param>\n    /// <returns>The converted integer.</returns>\n    public static int ParseToInt32(this string value)\n    {\n        return int.Parse(value);\n    }\n\n    /// <summary>\n    /// Checks whether the value is integer.\n    /// </summary>\n    /// <param name=\"value\">The string to check.</param>\n    /// <param name=\"result\">The out int parameter.</param>\n    /// <returns>true if the value is an integer; otherwise, false.</returns>\n    public static bool TryParseToInt32(this string value, out int result)\n    {\n        return int.TryParse(value, out result);\n    }\n}\npublic static class StringExtensions\n{\n    /// <summary>\n    /// Converts a string to int.\n    /// </summary>\n    /// <param name=\"value\">The string to convert.</param>\n    /// <returns>The converted integer.</returns>\n    public static int ParseToInt32(this string value)\n    {\n        return int.Parse(value);\n    }\n\n    /// <summary>\n    /// Checks whether the value is integer.\n    /// </summary>\n    /// <param name=\"value\">The string to check.</param>\n    /// <param name=\"result\">The out int parameter.</param>\n    /// <returns>true if the value is an integer; otherwise, false.</returns>\n    public static bool TryParseToInt32(this string value, out int result)\n    {\n        return int.TryParse(value, out result);\n    }\n}\nAnd then you can call it that way:\nIf you are sure that your string is an integer, like \"50\".\nint num = TextBoxD1.Text.ParseToInt32();\n\nIf you are not sure and want to prevent crashes.\nint num;\nif (TextBoxD1.Text.TryParseToInt32(out num))\n{\n    //The parse was successful, the num has the parsed value.\n}\n\nIf you are sure that your string is an integer, like \"50\".\nint num = TextBoxD1.Text.ParseToInt32();\nIf you are sure that your string is an integer, like \"50\".int num = TextBoxD1.Text.ParseToInt32();\nint num = TextBoxD1.Text.ParseToInt32();\nIf you are not sure and want to prevent crashes.\nint num;\nif (TextBoxD1.Text.TryParseToInt32(out num))\n{\n    //The parse was successful, the num has the parsed value.\n}\nIf you are not sure and want to prevent crashes.int num;\nif (TextBoxD1.Text.TryParseToInt32(out num))\n{\n    //The parse was successful, the num has the parsed value.\n}\nint num;\nif (TextBoxD1.Text.TryParseToInt32(out num))\n{\n    //The parse was successful, the num has the parsed value.\n}\nTo make it more dynamic, so you can parse it also to double, float, etc., you can make a generic extension.",
                "You can convert a string to int in C# using:Functions of convert class i.e. Convert.ToInt16(), Convert.ToInt32(), Convert.ToInt64() or by using Parse and TryParse Functions. Examples are given here.Convert.ToInt16()Convert.ToInt32()Convert.ToInt64()ParseTryParsehere",
                "This would dostring x = TextBoxD1.Text;\nint xi = Convert.ToInt32(x);\nstring x = TextBoxD1.Text;\nint xi = Convert.ToInt32(x);\nOr you can useint xi = Int32.Parse(x);\nint xi = Int32.Parse(x);\nRefer Microsoft Developer Network for more informationMicrosoft Developer Network for more information",
                "You can convert string to an integer value with the help of parse method. Eg: int val = Int32.parse(stringToBeParsed);\nint x = Int32.parse(1234);\nint val = Int32.parse(stringToBeParsed);\nint x = Int32.parse(1234);\n",
                "In C# v.7 you could use an inline out parameter, without an additional variable declaration:int.TryParse(TextBoxD1.Text, out int x);\nint.TryParse(TextBoxD1.Text, out int x);\n",
                "The way I always do this is like this:using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace example_string_to_int\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void button1_Click(object sender, EventArgs e)\n        {\n            string a = textBox1.Text;\n            // This turns the text in text box 1 into a string\n            int b;\n            if (!int.TryParse(a, out b))\n            {\n                MessageBox.Show(\"This is not a number\");\n            }\n            else\n            {\n                textBox2.Text = a+\" is a number\" ;\n            }\n            // Then this 'if' statement says if the string is not a number, display an error, else now you will have an integer.\n        }\n    }\n}\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace example_string_to_int\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void button1_Click(object sender, EventArgs e)\n        {\n            string a = textBox1.Text;\n            // This turns the text in text box 1 into a string\n            int b;\n            if (!int.TryParse(a, out b))\n            {\n                MessageBox.Show(\"This is not a number\");\n            }\n            else\n            {\n                textBox2.Text = a+\" is a number\" ;\n            }\n            // Then this 'if' statement says if the string is not a number, display an error, else now you will have an integer.\n        }\n    }\n}\nThis is how I would do it.",
                "All the above answers are good but for information, we can use int.TryParse which is safe to convert string to int, for exampleint.TryParse// TryParse returns true if the conversion succeeded\n// and stores the result in j.\nint j;\nif (Int32.TryParse(\"-105\", out j))\n   Console.WriteLine(j);\nelse\n   Console.WriteLine(\"String could not be parsed.\");\n// Output: -105\n// TryParse returns true if the conversion succeeded\n// and stores the result in j.\nint j;\nif (Int32.TryParse(\"-105\", out j))\n   Console.WriteLine(j);\nelse\n   Console.WriteLine(\"String could not be parsed.\");\n// Output: -105\nTryParse never throws an exception\u2014even on invalid input and null. It is overall preferable to int.Parse in most program contexts.int.ParseSource: How to convert string to int in C#? (With Difference between Int.Parse and Int.TryParse)How to convert string to int in C#? (With Difference between Int.Parse and Int.TryParse)",
                "In case you know the string is an integer do:int value = int.Parse(TextBoxD1.Text);\nint value = int.Parse(TextBoxD1.Text);\nIn case you don't know the string is an integer do it safely with TryParse.TryParseIn C# 7.0 you can use inline variable declaration.C# 7.0inline variable declaration\nIf parse successes - value = its parsed value.\nIf parse fails - value = 0.\nIf parse successes - value = its parsed value.If parse fails - value = 0.Code:if (int.TryParse(TextBoxD1.Text, out int value))\n{\n    // Parse succeed\n}\nif (int.TryParse(TextBoxD1.Text, out int value))\n{\n    // Parse succeed\n}\nDrawback:You cannot differentiate between a 0 value and a non parsed value.",
                "Here is the version of doing it via an Extension Method that has an option to set the default value as well, if the converting fails. In fact, this is what I used to convert a string input to any convertible type:using System;\nusing System.ComponentModel;\n\npublic static class StringExtensions\n{\n    public static TOutput AsOrDefault<TOutput>(this string input, TOutput defaultValue = default)\n        where TOutput : IConvertible\n    {\n        TOutput output = defaultValue;\n\n        try\n        {\n            var converter = TypeDescriptor.GetConverter(typeof(TOutput));\n            if (converter != null)\n            {\n                output = (TOutput)converter.ConvertFromString(input);\n            }\n        }\n        catch { }\n\n        return output;\n    }\n}\nusing System;\nusing System.ComponentModel;\n\npublic static class StringExtensions\n{\n    public static TOutput AsOrDefault<TOutput>(this string input, TOutput defaultValue = default)\n        where TOutput : IConvertible\n    {\n        TOutput output = defaultValue;\n\n        try\n        {\n            var converter = TypeDescriptor.GetConverter(typeof(TOutput));\n            if (converter != null)\n            {\n                output = (TOutput)converter.ConvertFromString(input);\n            }\n        }\n        catch { }\n\n        return output;\n    }\n}\nFor my usage, I limited the output to be one of the convertible types: https://learn.microsoft.com/en-us/dotnet/api/system.iconvertible?view=net-5.0. I don't need crazy logics to convert a string to a class, for example.https://learn.microsoft.com/en-us/dotnet/api/system.iconvertible?view=net-5.0To use it to convert a string to int:using FluentAssertions;\nusing Xunit;\n\n[Theory]\n[InlineData(\"0\", 0)]\n[InlineData(\"1\", 1)]\n[InlineData(\"123\", 123)]\n[InlineData(\"-123\", -123)]\npublic void ValidStringWithNoDefaultValue_ReturnsExpectedResult(string input, int expectedResult)\n{\n    var result = input.AsOrDefault<int>();\n\n    result.Should().Be(expectedResult);\n}\n\n[Theory]\n[InlineData(\"0\", 999, 0)]\n[InlineData(\"1\", 999, 1)]\n[InlineData(\"123\", 999, 123)]\n[InlineData(\"-123\", -999, -123)]\npublic void ValidStringWithDefaultValue_ReturnsExpectedResult(string input, int defaultValue, int expectedResult)\n{\n    var result = input.AsOrDefault(defaultValue);\n\n    result.Should().Be(expectedResult);\n}\n\n[Theory]\n[InlineData(\"\")]\n[InlineData(\" \")]\n[InlineData(\"abc\")]\npublic void InvalidStringWithNoDefaultValue_ReturnsIntegerDefault(string input)\n{\n    var result = input.AsOrDefault<int>();\n\n    result.Should().Be(default(int));\n}\n\n[Theory]\n[InlineData(\"\", 0)]\n[InlineData(\" \", 1)]\n[InlineData(\"abc\", 234)]\npublic void InvalidStringWithDefaultValue_ReturnsDefaultValue(string input, int defaultValue)\n{\n    var result = input.AsOrDefault(defaultValue);\n\n    result.Should().Be(defaultValue);\n}\nusing FluentAssertions;\nusing Xunit;\n\n[Theory]\n[InlineData(\"0\", 0)]\n[InlineData(\"1\", 1)]\n[InlineData(\"123\", 123)]\n[InlineData(\"-123\", -123)]\npublic void ValidStringWithNoDefaultValue_ReturnsExpectedResult(string input, int expectedResult)\n{\n    var result = input.AsOrDefault<int>();\n\n    result.Should().Be(expectedResult);\n}\n\n[Theory]\n[InlineData(\"0\", 999, 0)]\n[InlineData(\"1\", 999, 1)]\n[InlineData(\"123\", 999, 123)]\n[InlineData(\"-123\", -999, -123)]\npublic void ValidStringWithDefaultValue_ReturnsExpectedResult(string input, int defaultValue, int expectedResult)\n{\n    var result = input.AsOrDefault(defaultValue);\n\n    result.Should().Be(expectedResult);\n}\n\n[Theory]\n[InlineData(\"\")]\n[InlineData(\" \")]\n[InlineData(\"abc\")]\npublic void InvalidStringWithNoDefaultValue_ReturnsIntegerDefault(string input)\n{\n    var result = input.AsOrDefault<int>();\n\n    result.Should().Be(default(int));\n}\n\n[Theory]\n[InlineData(\"\", 0)]\n[InlineData(\" \", 1)]\n[InlineData(\"abc\", 234)]\npublic void InvalidStringWithDefaultValue_ReturnsDefaultValue(string input, int defaultValue)\n{\n    var result = input.AsOrDefault(defaultValue);\n\n    result.Should().Be(defaultValue);\n}\n",
                "METHOD 1int  TheAnswer1 = 0;\nbool Success = Int32.TryParse(\"42\", out TheAnswer1);\nif (!Success) {\n    Console.WriteLine(\"String not Convertable to an Integer\");\n}\nint  TheAnswer1 = 0;\nbool Success = Int32.TryParse(\"42\", out TheAnswer1);\nif (!Success) {\n    Console.WriteLine(\"String not Convertable to an Integer\");\n}\nMETHOD 2int TheAnswer2 = 0;\ntry {\n    TheAnswer2 = Int32.Parse(\"42\");\n}\ncatch {\n    Console.WriteLine(\"String not Convertable to an Integer\");\n}\nint TheAnswer2 = 0;\ntry {\n    TheAnswer2 = Int32.Parse(\"42\");\n}\ncatch {\n    Console.WriteLine(\"String not Convertable to an Integer\");\n}\nMETHOD 3int TheAnswer3 = 0;\ntry {\n    TheAnswer3 = Int32.Parse(\"42\");\n}\ncatch (FormatException) {\n    Console.WriteLine(\"String not in the correct format for an Integer\");\n}\ncatch (ArgumentNullException) {\n    Console.WriteLine(\"String is null\");\n}\ncatch (OverflowException) {\n    Console.WriteLine(\"String represents a number less than\"\n                      + \"MinValue or greater than MaxValue\");\n}\nint TheAnswer3 = 0;\ntry {\n    TheAnswer3 = Int32.Parse(\"42\");\n}\ncatch (FormatException) {\n    Console.WriteLine(\"String not in the correct format for an Integer\");\n}\ncatch (ArgumentNullException) {\n    Console.WriteLine(\"String is null\");\n}\ncatch (OverflowException) {\n    Console.WriteLine(\"String represents a number less than\"\n                      + \"MinValue or greater than MaxValue\");\n}\n",
                "You can try the following. It will work:int x = Convert.ToInt32(TextBoxD1.Text);\nint x = Convert.ToInt32(TextBoxD1.Text);\nThe string value in the variable TextBoxD1.Text will be converted into Int32 and will be stored in x.",
                "While I agree on using the TryParse method, a lot of people dislike the use of out parameter (myself included). With tuple support having been added to C#, an alternative is to create an extension method that will limit the number of times you use out to a single instance:TryParseoutoutpublic static class StringExtensions\n{\n    public static (int result, bool canParse) TryParse(this string s)\n    {\n        int res;\n        var valid = int.TryParse(s, out res);\n        return (result: res, canParse: valid);\n    }\n}\npublic static class StringExtensions\n{\n    public static (int result, bool canParse) TryParse(this string s)\n    {\n        int res;\n        var valid = int.TryParse(s, out res);\n        return (result: res, canParse: valid);\n    }\n}\n(Source: C# how to convert a string to int)C# how to convert a string to int"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "How can I force division to be floating point? Division keeps rounding down to 0?",
                "How can I force division to be floating point? Division keeps rounding down to 0?"
            ],
            "responses": [
                "In Python 2, division of two ints produces an int. In Python 3, it produces a float. We can get the new behaviour by importing from __future__.__future__>>> from __future__ import division\n>>> a = 4\n>>> b = 6\n>>> c = a / b\n>>> c\n0.66666666666666663\n>>> from __future__ import division\n>>> a = 4\n>>> b = 6\n>>> c = a / b\n>>> c\n0.66666666666666663\n",
                "You can cast to float by doing c = a / float(b). If the numerator or denominator is a float, then the result will be also.c = a / float(b)A caveat: as commenters have pointed out, this won't work if b might be something other than an integer or floating-point number (or a string representing one). If you might be dealing with other types (such as complex numbers) you'll need to either check for those or use a different method.b",
                "\nHow can I force division to be floating point in Python?\nI have two integer values a and b, but I need their ratio in floating point. I know that a < b and I want to calculate a/b, so if I use integer division I'll always get 0 with a remainder of a.\nHow can I force c to be a floating point number in Python in the following?\nc = a / b\n\nHow can I force division to be floating point in Python?I have two integer values a and b, but I need their ratio in floating point. I know that a < b and I want to calculate a/b, so if I use integer division I'll always get 0 with a remainder of a.How can I force c to be a floating point number in Python in the following?c = a / b\nc = a / b\nWhat is really being asked here is:\"How do I force true division such that a / b will return a fraction?\"a / bUpgrade to Python 3In Python 3, to get true division, you simply do a / b.a / b>>> 1/2\n0.5\n>>> 1/2\n0.5\nFloor division, the classic division behavior for integers, is now a // b:a // b>>> 1//2\n0\n>>> 1//2.0\n0.0\n>>> 1//2\n0\n>>> 1//2.0\n0.0\nHowever, you may be stuck using Python 2, or you may be writing code that must work in both 2 and 3.If Using Python 2In Python 2, it's not so simple. Some ways of dealing with classic Python 2 division are better and more robust than others.Recommendation for Python 2You can get Python 3 division behavior in any given module with the following import at the top:from __future__ import division\nfrom __future__ import division\nwhich then applies Python 3 style division to the entire module. It also works in a python shell at any given point. In Python 2:>>> from __future__ import division\n>>> 1/2\n0.5\n>>> 1//2\n0\n>>> 1//2.0\n0.0\n>>> from __future__ import division\n>>> 1/2\n0.5\n>>> 1//2\n0\n>>> 1//2.0\n0.0\nThis is really the best solution as it ensures the code in your module is more forward compatible with Python 3.Other Options for Python 2If you don't want to apply this to the entire module, you're limited to a few workarounds. The most popular is to coerce one of the operands to a float. One robust solution is a / (b * 1.0). In a fresh Python shell:a / (b * 1.0)>>> 1/(2 * 1.0)\n0.5\n>>> 1/(2 * 1.0)\n0.5\nAlso robust is truediv from the operator module operator.truediv(a, b), but this is likely slower because it's a function call:truedivoperatoroperator.truediv(a, b)>>> from operator import truediv\n>>> truediv(1, 2)\n0.5\n>>> from operator import truediv\n>>> truediv(1, 2)\n0.5\nNot Recommended for Python 2Commonly seen is a / float(b). This will raise a TypeError if b is a complex number. Since division with complex numbers is defined, it makes sense to me to not have division fail when passed a complex number for the divisor.a / float(b)>>> 1 / float(2)\n0.5\n>>> 1 / float(2j)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can't convert complex to float\n>>> 1 / float(2)\n0.5\n>>> 1 / float(2j)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can't convert complex to float\nIt doesn't make much sense to me to purposefully make your code more brittle.You can also run Python with the -Qnew flag, but this has the downside of executing all modules with the new Python 3 behavior, and some of your modules may expect classic division, so I don't recommend this except for testing. But to demonstrate:-Qnew$ python -Qnew -c 'print 1/2'\n0.5\n$ python -Qnew -c 'print 1/2j'\n-0.5j\n$ python -Qnew -c 'print 1/2'\n0.5\n$ python -Qnew -c 'print 1/2j'\n-0.5j\n",
                "c = a / (b * 1.0)\nc = a / (b * 1.0)\n",
                "In Python 3.x, the single slash (/) always means true (non-truncating) division. (The // operator is used for truncating division.) In Python 2.x (2.2 and above), you can get this same behavior by putting a///from __future__ import division\nfrom __future__ import division\nat the top of your module.",
                "Just making any of the parameters for division in floating-point format also produces the output in floating-point.Example:>>> 4.0/3\n1.3333333333333333\n>>> 4.0/3\n1.3333333333333333\nor,>>> 4 / 3.0\n1.3333333333333333\n>>> 4 / 3.0\n1.3333333333333333\nor, >>> 4 / float(3)\n1.3333333333333333\n>>> 4 / float(3)\n1.3333333333333333\nor, >>> float(4) / 3\n1.3333333333333333\n>>> float(4) / 3\n1.3333333333333333\n",
                "Add a dot (.) to indicate floating point numbers.>>> 4/3.\n1.3333333333333333\n>>> 4/3.\n1.3333333333333333\n",
                "This will also work>>> u=1./5\n>>> print u\n0.2\n>>> u=1./5\n>>> print u\n0.2\n",
                "If you want to use \"true\" (floating point) division by default, there is a command line flag:python -Q new foo.py\npython -Q new foo.py\nThere are some drawbacks (from the PEP):\nIt has been argued that a command line option to change the\n        default is evil.  It can certainly be dangerous in the wrong\n        hands: for example, it would be impossible to combine a 3rd\n        party library package that requires -Qnew with another one that\n        requires -Qold. \nIt has been argued that a command line option to change the\n        default is evil.  It can certainly be dangerous in the wrong\n        hands: for example, it would be impossible to combine a 3rd\n        party library package that requires -Qnew with another one that\n        requires -Qold. You can learn more about the other flags values that change / warn-about the behavior of division by looking at the python man page.For full details on division changes read: PEP 238 -- Changing the Division OperatorPEP 238 -- Changing the Division Operator",
                "from operator import truediv\n\nc = truediv(a, b)\nfrom operator import truediv\n\nc = truediv(a, b)\n",
                "from operator import truediv\n\nc = truediv(a, b)\nfrom operator import truediv\n\nc = truediv(a, b)\nwhere a is dividend and b is the divisor.\nThis function is handy when quotient after division  of two integers is a float."
            ]
        },
        {
            "tag": "c",
            "patterns": [
                "What is size_t in C?",
                "what does sizet in c mean?"
            ],
            "responses": [
                "From Wikipedia:From Wikipedia\nAccording to the 1999 ISO C standard\n  (C99), size_t is an unsigned integer\n  type of at least 16 bit (see sections\n  7.17 and 7.18.3).\nsize_tis an unsigned data type\n  defined by several C/C++ standards,\n  e.g. the C99 ISO/IEC 9899 standard,\n  that is defined in stddef.h.1 It can\n  be further imported by inclusion of\n  stdlib.h as this file internally sub\n  includes stddef.h.\nThis type is used to represent the\n  size of an object. Library functions\n  that take or return sizes expect them\n  to be of type or have the return type\n  of size_t. Further, the most\n  frequently used compiler-based\n  operator sizeof should evaluate to a\n  constant value that is compatible with\n  size_t.\nAccording to the 1999 ISO C standard\n  (C99), size_t is an unsigned integer\n  type of at least 16 bit (see sections\n  7.17 and 7.18.3).size_tsize_tis an unsigned data type\n  defined by several C/C++ standards,\n  e.g. the C99 ISO/IEC 9899 standard,\n  that is defined in stddef.h.1 It can\n  be further imported by inclusion of\n  stdlib.h as this file internally sub\n  includes stddef.h.size_tstddef.h1stdlib.hstddef.hThis type is used to represent the\n  size of an object. Library functions\n  that take or return sizes expect them\n  to be of type or have the return type\n  of size_t. Further, the most\n  frequently used compiler-based\n  operator sizeof should evaluate to a\n  constant value that is compatible with\n  size_t.size_tsize_tAs an implication, size_t is a type guaranteed to hold any array index.size_t",
                "size_t is an unsigned type.  So, it cannot represent any negative values(<0).  You use it when you are counting something, and are sure that it cannot be negative.  For example, strlen() returns a size_t because the length of a string has to be at least 0.size_tstrlen()strlen()size_tIn your example, if your loop index is going to be always greater than 0, it might make sense to use size_t, or any other unsigned data type.size_tWhen you use a size_t object, you have to make sure that in all the contexts it is used, including arithmetic, you want non-negative values.  For example, let's say you have:size_tsize_t s1 = strlen(str1);\nsize_t s2 = strlen(str2);\nsize_t s1 = strlen(str1);\nsize_t s2 = strlen(str2);\nand you want to find the difference of the lengths of str2 and str1.  You cannot do:str2str1int diff = s2 - s1; /* bad */\nint diff = s2 - s1; /* bad */\nThis is because the value assigned to diff is always going to be a positive number, even when s2 < s1, because the calculation is done with unsigned types.  In this case, depending upon what your use case is, you might be better off using int (or long long) for s1 and s2.diffs2 < s1intlong longs1s2There are some functions in C/POSIX that could/should use size_t, but don't because of historical reasons.  For example, the second parameter to fgets should ideally be size_t, but is int.size_tfgetssize_tint",
                "size_t is a type that can hold any array index.size_tDepending on the implementation, it can be any of:unsigned charunsigned charunsigned shortunsigned shortunsigned intunsigned intunsigned longunsigned longunsigned long longunsigned long longHere's how size_t is defined in stddef.h of my machine:size_tstddef.htypedef unsigned long size_t;\ntypedef unsigned long size_t;\n",
                "If you are the empirical type,If you are the empirical typeecho | gcc -E -xc -include 'stddef.h' - | grep size_t\necho | gcc -E -xc -include 'stddef.h' - | grep size_t\nOutput for Ubuntu 14.04 64-bit GCC 4.8:typedef long unsigned int size_t;\ntypedef long unsigned int size_t;\nNote that stddef.h is provided by GCC and not glibc under src/gcc/ginclude/stddef.h in GCC 4.2.stddef.hsrc/gcc/ginclude/stddef.hInteresting C99 appearancesInteresting C99 appearances\nmalloc takes size_t as an argument, so it determines the maximum size that may be allocated.\nAnd since it is also returned by sizeof, I think it limits the maximum size of any array.\nSee also: What is the maximum size of an array in C?\nmalloc takes size_t as an argument, so it determines the maximum size that may be allocated.\nAnd since it is also returned by sizeof, I think it limits the maximum size of any array.\nSee also: What is the maximum size of an array in C?malloc takes size_t as an argument, so it determines the maximum size that may be allocated.mallocsize_tAnd since it is also returned by sizeof, I think it limits the maximum size of any array.sizeofSee also: What is the maximum size of an array in C?What is the maximum size of an array in C?",
                "The manpage for types.h says:types.h\nsize_t shall be an unsigned integer type\nsize_t shall be an unsigned integer type",
                "To go into why size_t needed to exist and how we got here:size_tIn pragmatic terms, size_t and ptrdiff_t are guaranteed to be 64 bits wide on a 64-bit implementation, 32 bits wide on a 32-bit implementation, and so on.  They could not force any existing type to mean that, on every compiler, without breaking legacy code.size_tptrdiff_tA size_t or ptrdiff_t is not necessarily the same as an intptr_t or uintptr_t.  They were different on certain architectures that were still in use when size_t and ptrdiff_t were added to the Standard in the late 1980s, and becoming obsolete when C99 added many new types but not gone yet (such as 16-bit Windows). The x86 in 16-bit protected mode had a segmented memory where the largest possible array or structure could be only 65,536 bytes in size, but a far pointer needed to be 32 bits wide, wider than the registers.  On those, intptr_t would have been 32 bits wide but size_t and ptrdiff_t could be 16 bits wide and fit in a register. And who knew what kind of operating system might be written in the future?  In theory, the i386 architecture offers a 32-bit segmentation model with 48-bit pointers that no operating system has ever actually used.size_tptrdiff_tintptr_tuintptr_tsize_tptrdiff_tC99farintptr_tsize_tptrdiff_tThe type of a memory offset could not be long because far too much legacy code assumes that long is exactly 32 bits wide.  This assumption was even built into the UNIX and Windows APIs.  Unfortunately, a lot of other legacy code also assumed that a long is wide enough to hold a pointer, a file offset, the number of seconds that have elapsed since 1970, and so on.  POSIX now provides a standardized way to force the latter assumption to be true instead of the former, but neither is a portable assumption to make.longlonglongIt couldn\u2019t be int because only a tiny handful of compilers in the \u201990s made int 64 bits wide.  Then they really got weird by keeping long 32 bits wide.  The next revision of the Standard declared it illegal for int to be wider than long, but int is still 32 bits wide on most 64-bit systems.intintlongintlongintIt couldn\u2019t be long long int, which anyway was added later, since that was created to be at least 64 bits wide even on 32-bit systems.long long intSo, a new type was needed.  Even if it weren\u2019t, all those other types meant something other than an offset within an array or object.  And if there was one lesson from the fiasco of 32-to-64-bit migration, it was to be specific about what properties a type needed to have, and not use one that meant different things in different programs.",
                "Since nobody has yet mentioned it, the primary linguistic significance of size_t is that the sizeof operator returns a value of that type.  Likewise, the primary significance of ptrdiff_t is that subtracting one pointer from another will yield a value of that type.  Library functions that accept it do so because it will allow such functions to work with objects whose size exceeds UINT_MAX on systems where such objects could exist, without forcing callers to waste code passing a value larger than \"unsigned int\" on systems where the larger type would suffice for all possible objects.size_tsizeofptrdiff_t",
                "size_t and int are not interchangeable. For instance on 64-bit Linux size_t is 64-bit in size (i.e. sizeof(void*)) but int is 32-bit.size_tintsize_tsizeof(void*)intAlso note that size_t is unsigned. If you need signed version then there is ssize_t on some platforms and it would be more relevant to your example.size_tssize_tAs a general rule I would suggest using int for most general cases and only use size_t/ssize_t when there is a specific need for it (with mmap() for example).intsize_tssize_tmmap()",
                "size_t is an unsigned integer data type which can assign only 0 and greater than 0 integer values. It measure bytes of any object's size and is returned by sizeof operator.size_tsizeofconst is the syntax representation of size_t, but without const you can run the program.constsize_tconstconst size_t number;\nconst size_t number;\nsize_t regularly used for array indexing and loop counting. If the compiler is 32-bit it would work on unsigned int. If the compiler is 64-bit it would work on unsigned long long int also. There for maximum size of size_t depending on the compiler type.size_t32-bitunsigned int64-bitunsigned long long intsize_tsize_t already defined in the <stdio.h> header file, but it can also be defined by the\n<stddef.h>, <stdlib.h>, <string.h>, <time.h>, and <wchar.h> headers.size_t<stdio.h><stddef.h><stdlib.h><string.h><time.h><wchar.h>Example (with const)const#include <stdio.h>\n\nint main()\n{\n    const size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0 ; i < value ; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(\"size = %zu\\n\", size);\n}\n#include <stdio.h>\n\nint main()\n{\n    const size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0 ; i < value ; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(\"size = %zu\\n\", size);\n}\nOutput: size = 800Output:size = 800Example (without const)const#include <stdio.h>\n\nint main()\n{\n    size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0; i < value; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(\"size = %zu\\n\", size);\n}\n#include <stdio.h>\n\nint main()\n{\n    size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0; i < value; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(\"size = %zu\\n\", size);\n}\nOutput: size = 800Output:size = 800",
                "size_t is a typedef which is used to represent the size of any object in bytes. (Typedefs are used to create an additional name/alias for another data type, but does not create a new type.)size_tFind it defined in stddef.h as follows:stddef.htypedef unsigned long long size_t;\ntypedef unsigned long long size_t;\nsize_t is also defined in the <stdio.h>.size_t<stdio.h>size_t is used as the return type by the sizeof operator.size_tUse size_t, in conjunction with sizeof, to define the data type of the array size argument as follows:size_t#include <stdio.h>\n\nvoid disp_ary(int *ary, size_t ary_size)\n{\n    for (int i = 0; i < ary_size; i++)\n    {\n        printf(\"%d \", ary[i]);\n    }\n}\n \nint main(void)\n{\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n    int ary_size = sizeof(arr)/sizeof(int);\n    disp_ary(arr, ary_size);\n    return 0;\n}\n#include <stdio.h>\n\nvoid disp_ary(int *ary, size_t ary_size)\n{\n    for (int i = 0; i < ary_size; i++)\n    {\n        printf(\"%d \", ary[i]);\n    }\n}\n \nint main(void)\n{\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n    int ary_size = sizeof(arr)/sizeof(int);\n    disp_ary(arr, ary_size);\n    return 0;\n}\nsize_t is guaranteed to be big enough to contain the size of the biggest object the host system can handle.size_tNote that an array's size limitation is really a factor the system's stack size limitations where this code is compiled and executed. You should be able to adjust the stack size at link time (see ld commands's --stack-size parameter).ldstack-sizeTo give you an idea of approximate stack sizes:\n4K on an embedded device\n1M on Win10\n7.4M on Linux\n4K on an embedded device1M on Win107.4M on LinuxMany C library functions like malloc, memcpy and strlen declare their arguments and return type as size_t.mallocmemcpystrlensize_tsize_t affords the programmer with the ability to deal with different types, by adding/subtracting the number of elements required instead of using the offset in bytes.size_tLet's get a deeper appreciate for what size_t can do for us by examining its usage in pointer arithmetic operations of a C string and an integer array:size_tHere's an example using a C string:const char* reverse(char *orig)\n{\n  size_t len = strlen(orig);\n  char *rev = orig + len - 1;\n  while (rev >= orig)\n  {\n    printf(\"%c\", *rev);\n    rev = rev - 1;  // <= See below\n  }\n  return rev;\n}\n\nint main() {\n  char *string = \"123\";\n  printf(\"%c\", reverse(string));\n}\n// Output: 321\n\n0x7ff626939004 \"123\"  // <= orig\n0x7ff626939006 \"3\"    // <= rev - 1 of 3\n0x7ff626939005 \"23\"   // <= rev - 2 of 3\n0x7ff626939004 \"123\"  // <= rev - 3 of 3\n0x7ff6aade9003 \"\"     // <= rev is indeterminant. This can be exploited as an out of bounds bug to read memory contents that this program has no business reading.\nconst char* reverse(char *orig)\n{\n  size_t len = strlen(orig);\n  char *rev = orig + len - 1;\n  while (rev >= orig)\n  {\n    printf(\"%c\", *rev);\n    rev = rev - 1;  // <= See below\n  }\n  return rev;\n}\n\nint main() {\n  char *string = \"123\";\n  printf(\"%c\", reverse(string));\n}\n// Output: 321\n\n0x7ff626939004 \"123\"  // <= orig\n0x7ff626939006 \"3\"    // <= rev - 1 of 3\n0x7ff626939005 \"23\"   // <= rev - 2 of 3\n0x7ff626939004 \"123\"  // <= rev - 3 of 3\n0x7ff6aade9003 \"\"     // <= rev is indeterminant. This can be exploited as an out of bounds bug to read memory contents that this program has no business reading.\nThat's not very helpful in understanding the benefits of using size_t since a character is one byte, regardless of your architecture.size_tWhen we're dealing with numerical types, size_t becomes very beneficial.size_tsize_t type is like an integer with benefits that can hold a physical memory address; That address changes its size according to the type of platform in which it is executed.size_tHere's how we can leverage sizeof and size_t when passing an array of ints:void print_reverse(int *orig, size_t ary_size)\n{\n  int *rev = orig + ary_size - 1;\n  while (rev >= orig)\n  {\n    printf(\"%i\", *rev);\n    rev = rev - 1;\n  }\n}\n\nint main()\n{\n  int nums[] = {1, 2, 3};\n  print_reverse(nums, sizeof(nums)/sizeof(*nums));\n\n  return 0;\n}\n\n0x617d3ffb44 1  // <= orig\n0x617d3ffb4c 3  // <= rev - 1 of 3\n0x617d3ffb48 2  // <= rev - 2 of 3\n0x617d3ffb44 1  // <= rev - 3 of 3\nvoid print_reverse(int *orig, size_t ary_size)\n{\n  int *rev = orig + ary_size - 1;\n  while (rev >= orig)\n  {\n    printf(\"%i\", *rev);\n    rev = rev - 1;\n  }\n}\n\nint main()\n{\n  int nums[] = {1, 2, 3};\n  print_reverse(nums, sizeof(nums)/sizeof(*nums));\n\n  return 0;\n}\n\n0x617d3ffb44 1  // <= orig\n0x617d3ffb4c 3  // <= rev - 1 of 3\n0x617d3ffb48 2  // <= rev - 2 of 3\n0x617d3ffb44 1  // <= rev - 3 of 3\nAbove, we see than an int takes 4 bytes (and since there are 8 bits per byte, an int occupies 32 bits).If we were to create an array of longs we'd discover that a long takes 64 bits on a linux64 operating system, but only 32 bits on a Win64 system.  Hence, using t_size, will save a lot of coding and potential bugs, especially when running C code that performs Address Arithmetic on different architectures.32 bits on a Win64 systemt_sizeSo the moral of this story is \"Use size_t and let your C-compiler do the error-prone work of pointer arithmetic.\"size_t",
                "size_t is unsigned integer data type. On systems using the GNU C Library, this will be\u00a0unsigned\u00a0int\u00a0or\u00a0unsigned\u00a0long\u00a0int. size_t\u00a0is commonly used for array indexing and loop counting.",
                "In general, if you are starting at 0 and going upward, always use an unsigned type to avoid an overflow taking you into a negative value situation. This is critically important, because if your array bounds happens to be less than the max of your loop, but your loop max happens to be greater than the max of your type, you will wrap around negative and you may experience a segmentation fault (SIGSEGV). So, in general, never use int for a loop starting at 0 and going upwards. Use an unsigned.segmentation fault",
                "size_t or any unsigned type might be seen used as loop variable as loop variables are typically greater than or equal to 0.size_tWhen we use a size_t object, we have to make sure that in all the contexts it is used, including arithmetic, we want only non-negative values. For instance, following program would definitely give the unexpected result:size_t// C program to demonstrate that size_t or\n// any unsigned int type should be used \n// carefully when used in a loop\n\n#include<stdio.h>\nint main()\n{\nconst size_t N = 10;\nint a[N];\n\n// This is fine\nfor (size_t n = 0; n < N; ++n)\na[n] = n;\n\n// But reverse cycles are tricky for unsigned \n// types as can lead to infinite loop\nfor (size_t n = N-1; n >= 0; --n)\nprintf(\"%d \", a[n]);\n}\n\nOutput\nInfinite loop and then segmentation fault\n// C program to demonstrate that size_t or\n// any unsigned int type should be used \n// carefully when used in a loop\n\n#include<stdio.h>\nint main()\n{\nconst size_t N = 10;\nint a[N];\n\n// This is fine\nfor (size_t n = 0; n < N; ++n)\na[n] = n;\n\n// But reverse cycles are tricky for unsigned \n// types as can lead to infinite loop\nfor (size_t n = N-1; n >= 0; --n)\nprintf(\"%d \", a[n]);\n}\n\nOutput\nInfinite loop and then segmentation fault\n",
                "This is a platform-specific typedef. For example, on a particular machine, it might be unsigned int or unsigned long. You should use this definition for more portability of your code.typedefunsigned intunsigned long",
                "From my understanding, size_t is an unsigned integer whose bit size is large enough to hold a pointer of the native architecture.size_tunsignedSo:sizeof(size_t) >= sizeof(void*)\nsizeof(size_t) >= sizeof(void*)\n"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Convert all strings in a list to int",
                "convert all strings in a list into ints",
                "convert all strings in a list to int's",
                "convert all strings in a list into int",
                "convert all strings in a list to ints",
                "convert all strings in a list to int"
            ],
            "responses": [
                "Given:xs = ['1', '2', '3']\nxs = ['1', '2', '3']\nUse map then list to obtain a list of integers:mapmaplistlist(map(int, xs))\nlist(map(int, xs))\nIn Python 2, list was unnecessary since map returned a list:listmapmapmap(int, xs)\nmap(int, xs)\n",
                "Use a list comprehension on the list xs:list comprehensionxs[int(x) for x in xs]\n[int(x) for x in xs]\ne.g.>>> xs = [\"1\", \"2\", \"3\"]\n>>> [int(x) for x in xs]\n[1, 2, 3]\n>>> xs = [\"1\", \"2\", \"3\"]\n>>> [int(x) for x in xs]\n[1, 2, 3]\n",
                "There are several methods to convert string numbers in a list to integers.In Python 2.x you can use the map function:map>>> results = ['1', '2', '3']\n>>> results = map(int, results)\n>>> results\n[1, 2, 3]\n>>> results = ['1', '2', '3']\n>>> results = map(int, results)\n>>> results\n[1, 2, 3]\nHere, It returns the list of elements after applying the function.In Python 3.x you can use the same mapmap>>> results = ['1', '2', '3']\n>>> results = list(map(int, results))\n>>> results\n[1, 2, 3]\n>>> results = ['1', '2', '3']\n>>> results = list(map(int, results))\n>>> results\n[1, 2, 3]\nUnlike python 2.x, Here map function will return map object i.e. iterator which will yield the result(values) one by one that's the reason further we need to add a function named as list which will be applied to all the iterable items.iteratorlistRefer to the image below for the return value of the map function and it's type in the case of python 3.xmapThe third method which is common for both python 2.x and python 3.x i.e List ComprehensionsList Comprehensions>>> results = ['1', '2', '3']\n>>> results = [int(i) for i in results]\n>>> results\n[1, 2, 3]\n>>> results = ['1', '2', '3']\n>>> results = [int(i) for i in results]\n>>> results\n[1, 2, 3]\n",
                "You can easily convert string list items into int items using loop shorthand in pythonSay you have a string result = ['1','2','3']result = ['1','2','3']Just do,result = [int(item) for item in result]\nprint(result)\nresult = [int(item) for item in result]\nprint(result)\nIt'll give you output like[1,2,3]\n[1,2,3]\n",
                "If your list contains pure integer strings, the accepted answer is the way to go. It will crash if you give it things that are not integers.So: if you have data that may contain ints, possibly floats or other things as well - you can leverage your own function with errorhandling:def maybeMakeNumber(s):\n    \"\"\"Returns a string 's' into a integer if possible, a float if needed or\n    returns it as is.\"\"\"\n\n    # handle None, \"\", 0\n    if not s:\n        return s\n    try:\n        f = float(s)\n        i = int(f)\n        return i if f == i else f\n    except ValueError:\n        return s\n\ndata = [\"unkind\", \"data\", \"42\", 98, \"47.11\", \"of mixed\", \"types\"]\n\nconverted = list(map(maybeMakeNumber, data))\nprint(converted)\ndef maybeMakeNumber(s):\n    \"\"\"Returns a string 's' into a integer if possible, a float if needed or\n    returns it as is.\"\"\"\n\n    # handle None, \"\", 0\n    if not s:\n        return s\n    try:\n        f = float(s)\n        i = int(f)\n        return i if f == i else f\n    except ValueError:\n        return s\n\ndata = [\"unkind\", \"data\", \"42\", 98, \"47.11\", \"of mixed\", \"types\"]\n\nconverted = list(map(maybeMakeNumber, data))\nprint(converted)\nOutput:['unkind', 'data', 42, 98, 47.11, 'of mixed', 'types']\n['unkind', 'data', 42, 98, 47.11, 'of mixed', 'types']\nTo also handle iterables inside iterables you can use this helper:from collections.abc import Iterable, Mapping\n\ndef convertEr(iterab):\n    \"\"\"Tries to convert an iterable to list of floats, ints or the original thing\n    from the iterable. Converts any iterable (tuple,set, ...) to itself in output.\n    Does not work for Mappings  - you would need to check abc.Mapping and handle \n    things like {1:42, \"1\":84} when converting them - so they come out as is.\"\"\"\n\n    if isinstance(iterab, str):\n        return maybeMakeNumber(iterab)\n\n    if isinstance(iterab, Mapping):\n        return iterab\n\n    if isinstance(iterab, Iterable):\n        return  iterab.__class__(convertEr(p) for p in iterab)\n\n\ndata = [\"unkind\", {1: 3,\"1\":42}, \"data\", \"42\", 98, \"47.11\", \"of mixed\", \n        (\"0\", \"8\", {\"15\", \"things\"}, \"3.141\"), \"types\"]\n\nconverted = convertEr(data)\nprint(converted)\nfrom collections.abc import Iterable, Mapping\n\ndef convertEr(iterab):\n    \"\"\"Tries to convert an iterable to list of floats, ints or the original thing\n    from the iterable. Converts any iterable (tuple,set, ...) to itself in output.\n    Does not work for Mappings  - you would need to check abc.Mapping and handle \n    things like {1:42, \"1\":84} when converting them - so they come out as is.\"\"\"\n\n    if isinstance(iterab, str):\n        return maybeMakeNumber(iterab)\n\n    if isinstance(iterab, Mapping):\n        return iterab\n\n    if isinstance(iterab, Iterable):\n        return  iterab.__class__(convertEr(p) for p in iterab)\n\n\ndata = [\"unkind\", {1: 3,\"1\":42}, \"data\", \"42\", 98, \"47.11\", \"of mixed\", \n        (\"0\", \"8\", {\"15\", \"things\"}, \"3.141\"), \"types\"]\n\nconverted = convertEr(data)\nprint(converted)\nOutput:['unkind', {1: 3, '1': 42}, 'data', 42, 98, 47.11, 'of mixed', \n (0, 8, {'things', 15}, 3.141), 'types'] # sets are unordered, hence diffrent order\n['unkind', {1: 3, '1': 42}, 'data', 42, 98, 47.11, 'of mixed', \n (0, 8, {'things', 15}, 3.141), 'types'] # sets are unordered, hence diffrent order\n",
                "A little bit more expanded than list comprehension but likewise useful:def str_list_to_int_list(str_list):\n    n = 0\n    while n < len(str_list):\n        str_list[n] = int(str_list[n])\n        n += 1\n    return(str_list)\ndef str_list_to_int_list(str_list):\n    n = 0\n    while n < len(str_list):\n        str_list[n] = int(str_list[n])\n        n += 1\n    return(str_list)\ne.g.>>> results = [\"1\", \"2\", \"3\"]\n>>> str_list_to_int_list(results)\n[1, 2, 3]\n>>> results = [\"1\", \"2\", \"3\"]\n>>> str_list_to_int_list(results)\n[1, 2, 3]\nAlso: def str_list_to_int_list(str_list):\n    int_list = [int(n) for n in str_list]\n    return int_list\ndef str_list_to_int_list(str_list):\n    int_list = [int(n) for n in str_list]\n    return int_list\n",
                "Here is a simple solution with explanation for your query. a=['1','2','3','4','5'] #The integer represented as a string in this list\n b=[] #Fresh list\n for i in a: #Declaring variable (i) as an item in the list (a).\n     b.append(int(i)) #Look below for explanation\n print(b)\n a=['1','2','3','4','5'] #The integer represented as a string in this list\n b=[] #Fresh list\n for i in a: #Declaring variable (i) as an item in the list (a).\n     b.append(int(i)) #Look below for explanation\n print(b)\nHere, append() is used to add items ( i.e integer version of string (i) in this program ) to the end of the list (b).append()Note: int() is a function that helps to convert an integer in the form of string, back to its integer form.int()Output console:Output console:[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\nSo, we can convert the string items in the list to an integer only if the given string is entirely composed of numbers or else an error will be generated.",
                "You can do it simply in one line when taking input.[int(i) for i in input().split(\"\")]\n[int(i) for i in input().split(\"\")]\nSplit it where you want.If you want to convert a list not list simply put your list name in the place of input().split(\"\").input().split(\"\")",
                "I also want to add Python | Converting all strings in list to integersPython | Converting all strings in list to integersMethod #1 : Naive MethodMethod #1 : Naive Method# Python3 code to demonstrate \n# converting list of strings to int \n# using naive method \n\n# initializing list \ntest_list = ['1', '4', '3', '6', '7'] \n\n# Printing original list \nprint (\"Original list is : \" + str(test_list)) \n\n# using naive method to \n# perform conversion \nfor i in range(0, len(test_list)): \n    test_list[i] = int(test_list[i]) \n    \n\n# Printing modified list \nprint (\"Modified list is : \" + str(test_list)) \n# Python3 code to demonstrate \n# converting list of strings to int \n# using naive method \n\n# initializing list \ntest_list = ['1', '4', '3', '6', '7'] \n\n# Printing original list \nprint (\"Original list is : \" + str(test_list)) \n\n# using naive method to \n# perform conversion \nfor i in range(0, len(test_list)): \n    test_list[i] = int(test_list[i]) \n    \n\n# Printing modified list \nprint (\"Modified list is : \" + str(test_list)) \nOutput:Output:Original list is : ['1', '4', '3', '6', '7']\nModified list is : [1, 4, 3, 6, 7]\nOriginal list is : ['1', '4', '3', '6', '7']\nModified list is : [1, 4, 3, 6, 7]\nMethod #2 : Using list comprehensionMethod #2 : Using list comprehension# Python3 code to demonstrate \n# converting list of strings to int \n# using list comprehension \n\n# initializing list \ntest_list = ['1', '4', '3', '6', '7'] \n\n# Printing original list \nprint (\"Original list is : \" + str(test_list)) \n\n# using list comprehension to \n# perform conversion \ntest_list = [int(i) for i in test_list] \n    \n\n# Printing modified list \nprint (\"Modified list is : \" + str(test_list)) \n# Python3 code to demonstrate \n# converting list of strings to int \n# using list comprehension \n\n# initializing list \ntest_list = ['1', '4', '3', '6', '7'] \n\n# Printing original list \nprint (\"Original list is : \" + str(test_list)) \n\n# using list comprehension to \n# perform conversion \ntest_list = [int(i) for i in test_list] \n    \n\n# Printing modified list \nprint (\"Modified list is : \" + str(test_list)) \nOutput:Output:Original list is : ['1', '4', '3', '6', '7']\nModified list is : [1, 4, 3, 6, 7]\nOriginal list is : ['1', '4', '3', '6', '7']\nModified list is : [1, 4, 3, 6, 7]\nMethod #3 : Using map()Method #3 : Using map()# Python3 code to demonstrate \n# converting list of strings to int \n# using map() \n\n# initializing list \ntest_list = ['1', '4', '3', '6', '7'] \n\n# Printing original list \nprint (\"Original list is : \" + str(test_list)) \n\n# using map() to \n# perform conversion \ntest_list = list(map(int, test_list)) \n    \n\n# Printing modified list \nprint (\"Modified list is : \" + str(test_list)) \n# Python3 code to demonstrate \n# converting list of strings to int \n# using map() \n\n# initializing list \ntest_list = ['1', '4', '3', '6', '7'] \n\n# Printing original list \nprint (\"Original list is : \" + str(test_list)) \n\n# using map() to \n# perform conversion \ntest_list = list(map(int, test_list)) \n    \n\n# Printing modified list \nprint (\"Modified list is : \" + str(test_list)) \nOutput:Output:Original list is : ['1', '4', '3', '6', '7']\nModified list is : [1, 4, 3, 6, 7]\nOriginal list is : ['1', '4', '3', '6', '7']\nModified list is : [1, 4, 3, 6, 7]\n",
                "The answers below, even the most popular ones, do not work for all situations. I have such a solution for super resistant thrust str.\nI had such a thing:AA = ['0', '0.5', '0.5', '0.1', '0.1', '0.1', '0.1']AA = ['0', '0.5', '0.5', '0.1', '0.1', '0.1', '0.1']AA = pd.DataFrame(AA, dtype=np.float64)\nAA = AA.values.flatten()\nAA = list(AA.flatten())\nAA\nAA = pd.DataFrame(AA, dtype=np.float64)\nAA = AA.values.flatten()\nAA = list(AA.flatten())\nAA\n[0.0, 0.5, 0.5, 0.1, 0.1, 0.1, 0.1][0.0, 0.5, 0.5, 0.1, 0.1, 0.1, 0.1]You can laugh, but it works."
            ]
        },
        {
            "tag": "c++",
            "patterns": [
                "How to concatenate a std::string and an int",
                "how can i concatenate a string with an int?"
            ],
            "responses": [
                "In alphabetical order:std::string name = \"John\";\nint age = 21;\nstd::string result;\n\n// 1. with Boost\nresult = name + boost::lexical_cast<std::string>(age);\n\n// 2. with C++11\nresult = name + std::to_string(age);\n\n// 3. with FastFormat.Format\nfastformat::fmt(result, \"{0}{1}\", name, age);\n\n// 4. with FastFormat.Write\nfastformat::write(result, name, age);\n\n// 5. with the {fmt} library\nresult = fmt::format(\"{}{}\", name, age);\n\n// 6. with IOStreams\nstd::stringstream sstm;\nsstm << name << age;\nresult = sstm.str();\n\n// 7. with itoa\nchar numstr[21]; // enough to hold all numbers up to 64-bits\nresult = name + itoa(age, numstr, 10);\n\n// 8. with sprintf\nchar numstr[21]; // enough to hold all numbers up to 64-bits\nsprintf(numstr, \"%d\", age);\nresult = name + numstr;\n\n// 9. with STLSoft's integer_to_string\nchar numstr[21]; // enough to hold all numbers up to 64-bits\nresult = name + stlsoft::integer_to_string(numstr, 21, age);\n\n// 10. with STLSoft's winstl::int_to_string()\nresult = name + winstl::int_to_string(age);\n\n// 11. With Poco NumberFormatter\nresult = name + Poco::NumberFormatter().format(age);\nstd::string name = \"John\";\nint age = 21;\nstd::string result;\n\n// 1. with Boost\nresult = name + boost::lexical_cast<std::string>(age);\n\n// 2. with C++11\nresult = name + std::to_string(age);\n\n// 3. with FastFormat.Format\nfastformat::fmt(result, \"{0}{1}\", name, age);\n\n// 4. with FastFormat.Write\nfastformat::write(result, name, age);\n\n// 5. with the {fmt} library\nresult = fmt::format(\"{}{}\", name, age);\n\n// 6. with IOStreams\nstd::stringstream sstm;\nsstm << name << age;\nresult = sstm.str();\n\n// 7. with itoa\nchar numstr[21]; // enough to hold all numbers up to 64-bits\nresult = name + itoa(age, numstr, 10);\n\n// 8. with sprintf\nchar numstr[21]; // enough to hold all numbers up to 64-bits\nsprintf(numstr, \"%d\", age);\nresult = name + numstr;\n\n// 9. with STLSoft's integer_to_string\nchar numstr[21]; // enough to hold all numbers up to 64-bits\nresult = name + stlsoft::integer_to_string(numstr, 21, age);\n\n// 10. with STLSoft's winstl::int_to_string()\nresult = name + winstl::int_to_string(age);\n\n// 11. With Poco NumberFormatter\nresult = name + Poco::NumberFormatter().format(age);\n\nis safe, but slow; requires Boost (header-only); most/all platforms\nis safe, requires C++11 (to_string() is already included in #include <string>)\nis safe, and fast; requires FastFormat, which must be compiled; most/all platforms\n(ditto)\nis safe, and fast; requires the {fmt} library, which can either be compiled or used in a header-only mode; most/all platforms\nsafe, slow, and verbose; requires #include <sstream> (from standard C++)\nis brittle (you must supply a large enough buffer), fast, and verbose; itoa() is a non-standard extension, and not guaranteed to be available for all platforms\nis brittle (you must supply a large enough buffer), fast, and verbose; requires nothing (is standard C++); all platforms\nis brittle (you must supply a large enough buffer), probably the fastest-possible conversion, verbose; requires STLSoft (header-only); most/all platforms\nsafe-ish (you don't use more than one int_to_string() call in a single statement), fast; requires STLSoft (header-only); Windows-only\nis safe, but slow; requires Poco C++ ; most/all platforms\nis safe, but slow; requires Boost (header-only); most/all platformsBoostis safe, requires C++11 (to_string() is already included in #include <string>)to_string()#include <string>is safe, and fast; requires FastFormat, which must be compiled; most/all platformsFastFormat(ditto)dittois safe, and fast; requires the {fmt} library, which can either be compiled or used in a header-only mode; most/all platformsthe {fmt} librarysafe, slow, and verbose; requires #include <sstream> (from standard C++)#include <sstream>is brittle (you must supply a large enough buffer), fast, and verbose; itoa() is a non-standard extension, and not guaranteed to be available for all platformsis brittle (you must supply a large enough buffer), fast, and verbose; requires nothing (is standard C++); all platformsis brittle (you must supply a large enough buffer), probably the fastest-possible conversion, verbose; requires STLSoft (header-only); most/all platformsprobably the fastest-possible conversionSTLSoftsafe-ish (you don't use more than one int_to_string() call in a single statement), fast; requires STLSoft (header-only); Windows-onlyint_to_string()STLSoftis safe, but slow; requires Poco C++ ; most/all platformsPoco C++",
                "In C++11, you can use std::to_string, e.g.:std::to_stringauto result = name + std::to_string( age );\nauto result = name + std::to_string( age );\n",
                "If you have Boost, you can convert the integer to a string using boost::lexical_cast<std::string>(age).boost::lexical_cast<std::string>(age)Another way is to use stringstreams:std::stringstream ss;\nss << age;\nstd::cout << name << ss.str() << std::endl;\nstd::stringstream ss;\nss << age;\nstd::cout << name << ss.str() << std::endl;\nA third approach would be to use sprintf or snprintf from the C library.sprintfsnprintfchar buffer[128];\nsnprintf(buffer, sizeof(buffer), \"%s%d\", name.c_str(), age);\nstd::cout << buffer << std::endl;\nchar buffer[128];\nsnprintf(buffer, sizeof(buffer), \"%s%d\", name.c_str(), age);\nstd::cout << buffer << std::endl;\nOther posters suggested using itoa. This is NOT a standard function, so your code will not be portable if you use it. There are compilers that don't support it.itoa",
                "#include <iostream>\n#include <sstream>\n\nstd::ostringstream o;\no << name << age;\nstd::cout << o.str();\n#include <iostream>\n#include <sstream>\n\nstd::ostringstream o;\no << name << age;\nstd::cout << o.str();\n",
                "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\nstring itos(int i) // convert int to string\n{\n    stringstream s;\n    s << i;\n    return s.str();\n}\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\nstring itos(int i) // convert int to string\n{\n    stringstream s;\n    s << i;\n    return s.str();\n}\nShamelessly stolen from http://www.research.att.com/~bs/bs_faq2.html.http://www.research.att.com/~bs/bs_faq2.html",
                "This is the easiest way:string s = name + std::to_string(age);\nstring s = name + std::to_string(age);\n",
                "If you have C++11, you can use std::to_string.std::to_stringExample:std::string name = \"John\";\nint age = 21;\n\nname += std::to_string(age);\n\nstd::cout << name;\nstd::string name = \"John\";\nint age = 21;\n\nname += std::to_string(age);\n\nstd::cout << name;\nOutput:John21\nJohn21\n",
                "It seems to me that the simplest answer is to use the sprintf function:sprintfsprintf(outString,\"%s%d\",name,age);\nsprintf(outString,\"%s%d\",name,age);\n",
                "#include <string>\n#include <sstream>\nusing namespace std;\nstring concatenate(std::string const& name, int i)\n{\n    stringstream s;\n    s << name << i;\n    return s.str();\n}\n#include <string>\n#include <sstream>\nusing namespace std;\nstring concatenate(std::string const& name, int i)\n{\n    stringstream s;\n    s << name << i;\n    return s.str();\n}\n",
                "#include <sstream>\n\ntemplate <class T>\ninline std::string to_string (const T& t)\n{\n   std::stringstream ss;\n   ss << t;\n   return ss.str();\n}\n#include <sstream>\n\ntemplate <class T>\ninline std::string to_string (const T& t)\n{\n   std::stringstream ss;\n   ss << t;\n   return ss.str();\n}\nThen your usage would look something like this   std::string szName = \"John\";\n   int numAge = 23;\n   szName += to_string<int>(numAge);\n   cout << szName << endl;\n   std::string szName = \"John\";\n   int numAge = 23;\n   szName += to_string<int>(numAge);\n   cout << szName << endl;\nGoogled [and tested :p ]Googled",
                "This problem can be done in many ways. I will show it in two ways:\nConvert the number to string using to_string(i).\nUsing string streams.\nCode:\n#include <string>\n#include <sstream>\n#include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string name = \"John\";\n    int age = 21;\n\n    string answer1 = \"\";\n    // Method 1). string s1 = to_string(age).\n\n    string s1=to_string(age); // Know the integer get converted into string\n    // where as we know that concatenation can easily be done using '+' in C++\n\n    answer1 = name + s1;\n\n    cout << answer1 << endl;\n\n    // Method 2). Using string streams\n\n    ostringstream s2;\n\n    s2 << age;\n\n    string s3 = s2.str(); // The str() function will convert a number into a string\n\n    string answer2 = \"\";  // For concatenation of strings.\n\n    answer2 = name + s3;\n\n    cout << answer2 << endl;\n\n    return 0;\n}\n\nConvert the number to string using to_string(i).Convert the number to string using to_string(i).to_string(i)Using string streams.\nCode:\n#include <string>\n#include <sstream>\n#include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string name = \"John\";\n    int age = 21;\n\n    string answer1 = \"\";\n    // Method 1). string s1 = to_string(age).\n\n    string s1=to_string(age); // Know the integer get converted into string\n    // where as we know that concatenation can easily be done using '+' in C++\n\n    answer1 = name + s1;\n\n    cout << answer1 << endl;\n\n    // Method 2). Using string streams\n\n    ostringstream s2;\n\n    s2 << age;\n\n    string s3 = s2.str(); // The str() function will convert a number into a string\n\n    string answer2 = \"\";  // For concatenation of strings.\n\n    answer2 = name + s3;\n\n    cout << answer2 << endl;\n\n    return 0;\n}\nUsing string streams.Code:#include <string>\n#include <sstream>\n#include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string name = \"John\";\n    int age = 21;\n\n    string answer1 = \"\";\n    // Method 1). string s1 = to_string(age).\n\n    string s1=to_string(age); // Know the integer get converted into string\n    // where as we know that concatenation can easily be done using '+' in C++\n\n    answer1 = name + s1;\n\n    cout << answer1 << endl;\n\n    // Method 2). Using string streams\n\n    ostringstream s2;\n\n    s2 << age;\n\n    string s3 = s2.str(); // The str() function will convert a number into a string\n\n    string answer2 = \"\";  // For concatenation of strings.\n\n    answer2 = name + s3;\n\n    cout << answer2 << endl;\n\n    return 0;\n}\n#include <string>\n#include <sstream>\n#include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string name = \"John\";\n    int age = 21;\n\n    string answer1 = \"\";\n    // Method 1). string s1 = to_string(age).\n\n    string s1=to_string(age); // Know the integer get converted into string\n    // where as we know that concatenation can easily be done using '+' in C++\n\n    answer1 = name + s1;\n\n    cout << answer1 << endl;\n\n    // Method 2). Using string streams\n\n    ostringstream s2;\n\n    s2 << age;\n\n    string s3 = s2.str(); // The str() function will convert a number into a string\n\n    string answer2 = \"\";  // For concatenation of strings.\n\n    answer2 = name + s3;\n\n    cout << answer2 << endl;\n\n    return 0;\n}\n",
                "In C++20 you'll be able to do:auto result = std::format(\"{}{}\", name, age);\nauto result = std::format(\"{}{}\", name, age);\nIn the meantime you can use the {fmt} library, std::format is based on:the {fmt} librarystd::formatauto result = fmt::format(\"{}{}\", name, age);\nauto result = fmt::format(\"{}{}\", name, age);\nDisclaimer: I'm the author of the {fmt} library and C++20 std::format.Disclaimerstd::format",
                "If you'd like to use + for concatenation of anything which has an output operator, you can provide a template version of operator+:+operator+template <typename L, typename R> std::string operator+(L left, R right) {\n  std::ostringstream os;\n  os << left << right;\n  return os.str();\n}\ntemplate <typename L, typename R> std::string operator+(L left, R right) {\n  std::ostringstream os;\n  os << left << right;\n  return os.str();\n}\nThen you can write your concatenations in a straightforward way:std::string foo(\"the answer is \");\nint i = 42;\nstd::string bar(foo + i);    \nstd::cout << bar << std::endl;\nstd::string foo(\"the answer is \");\nint i = 42;\nstd::string bar(foo + i);    \nstd::cout << bar << std::endl;\nOutput:the answer is 42\nthe answer is 42\nThis isn't the most efficient way, but you don't need the most efficient way unless you're doing a lot of concatenation inside a loop.",
                "If you are using MFC, you can use a CStringCString nameAge = \"\";\nnameAge.Format(\"%s%d\", \"John\", 21);\nCString nameAge = \"\";\nnameAge.Format(\"%s%d\", \"John\", 21);\nManaged C++ also has a \n string formatter. string formatter",
                "As a one liner: name += std::to_string(age);name += std::to_string(age);",
                "The std::ostringstream is a good method, but sometimes this additional trick might get handy transforming the formatting to a one-liner:#include <sstream>\n#define MAKE_STRING(tokens) /****************/ \\\n    static_cast<std::ostringstream&>(          \\\n        std::ostringstream().flush() << tokens \\\n    ).str()                                    \\\n    /**/\n#include <sstream>\n#define MAKE_STRING(tokens) /****************/ \\\n    static_cast<std::ostringstream&>(          \\\n        std::ostringstream().flush() << tokens \\\n    ).str()                                    \\\n    /**/\nNow you can format strings like this:int main() {\n    int i = 123;\n    std::string message = MAKE_STRING(\"i = \" << i);\n    std::cout << message << std::endl; // prints: \"i = 123\"\n}\nint main() {\n    int i = 123;\n    std::string message = MAKE_STRING(\"i = \" << i);\n    std::cout << message << std::endl; // prints: \"i = 123\"\n}\n",
                "As a Qt-related question was closed in favour of this one, here's how to do it using Qt:QString string = QString(\"Some string %1 with an int somewhere\").arg(someIntVariable);\nstring.append(someOtherIntVariable);\nQString string = QString(\"Some string %1 with an int somewhere\").arg(someIntVariable);\nstring.append(someOtherIntVariable);\nThe string variable now has someIntVariable's value in place of %1 and someOtherIntVariable's value at the end.",
                "There are more options possible to use to concatenate integer (or other numerric object) with string. It is Boost.FormatBoost.Format#include <boost/format.hpp>\n#include <string>\nint main()\n{\n    using boost::format;\n\n    int age = 22;\n    std::string str_age = str(format(\"age is %1%\") % age);\n}\n#include <boost/format.hpp>\n#include <string>\nint main()\n{\n    using boost::format;\n\n    int age = 22;\n    std::string str_age = str(format(\"age is %1%\") % age);\n}\nand Karma from Boost.Spirit (v2)Boost.Spirit#include <boost/spirit/include/karma.hpp>\n#include <iterator>\n#include <string>\nint main()\n{\n    using namespace boost::spirit;\n\n    int age = 22;\n    std::string str_age(\"age is \");\n    std::back_insert_iterator<std::string> sink(str_age);\n    karma::generate(sink, int_, age);\n\n    return 0;\n}\n#include <boost/spirit/include/karma.hpp>\n#include <iterator>\n#include <string>\nint main()\n{\n    using namespace boost::spirit;\n\n    int age = 22;\n    std::string str_age(\"age is \");\n    std::back_insert_iterator<std::string> sink(str_age);\n    karma::generate(sink, int_, age);\n\n    return 0;\n}\nBoost.Spirit Karma claims to be one of the fastest option for integer to string conversion.fastest option for integer to string",
                "\nstd::ostringstream\nstd::ostringstream\n#include <sstream>\n\nstd::ostringstream s;\ns << \"John \" << age;\nstd::string query(s.str());\n\n#include <sstream>\n\nstd::ostringstream s;\ns << \"John \" << age;\nstd::string query(s.str());\n#include <sstream>\n\nstd::ostringstream s;\ns << \"John \" << age;\nstd::string query(s.str());\n\nstd::to_string (C++11)\nstd::to_string (C++11)\nstd::string query(\"John \" + std::to_string(age));\n\nstd::string query(\"John \" + std::to_string(age));\nstd::string query(\"John \" + std::to_string(age));\n\nboost::lexical_cast\nboost::lexical_cast\n#include <boost/lexical_cast.hpp>\n\nstd::string query(\"John \" + boost::lexical_cast<std::string>(age));\n\n#include <boost/lexical_cast.hpp>\n\nstd::string query(\"John \" + boost::lexical_cast<std::string>(age));\n#include <boost/lexical_cast.hpp>\n\nstd::string query(\"John \" + boost::lexical_cast<std::string>(age));\n",
                "Here is an implementation of how to append an int to a string using the parsing and formatting facets from the IOStreams library.#include <iostream>\n#include <locale>\n#include <string>\n\ntemplate <class Facet>\nstruct erasable_facet : Facet\n{\n    erasable_facet() : Facet(1) { }\n    ~erasable_facet() { }\n};\n\nvoid append_int(std::string& s, int n)\n{\n    erasable_facet<std::num_put<char,\n                                std::back_insert_iterator<std::string>>> facet;\n    std::ios str(nullptr);\n\n    facet.put(std::back_inserter(s), str,\n                                     str.fill(), static_cast<unsigned long>(n));\n}\n\nint main()\n{\n    std::string str = \"ID: \";\n    int id = 123;\n\n    append_int(str, id);\n\n    std::cout << str; // ID: 123\n}\n#include <iostream>\n#include <locale>\n#include <string>\n\ntemplate <class Facet>\nstruct erasable_facet : Facet\n{\n    erasable_facet() : Facet(1) { }\n    ~erasable_facet() { }\n};\n\nvoid append_int(std::string& s, int n)\n{\n    erasable_facet<std::num_put<char,\n                                std::back_insert_iterator<std::string>>> facet;\n    std::ios str(nullptr);\n\n    facet.put(std::back_inserter(s), str,\n                                     str.fill(), static_cast<unsigned long>(n));\n}\n\nint main()\n{\n    std::string str = \"ID: \";\n    int id = 123;\n\n    append_int(str, id);\n\n    std::cout << str; // ID: 123\n}\n",
                "Common Answer: itoa()itoa()This is bad.  itoa is non-standard, as pointed out here. itoahere",
                "You can concatenate int to string by using the given below simple trick, but note that this only works when integer is of single digit. Otherwise, add integer digit by digit to that string.string name = \"John\";\nint age = 5;\nchar temp = 5 + '0';\nname = name + temp;\ncout << name << endl;\n\nOutput:  John5\nstring name = \"John\";\nint age = 5;\nchar temp = 5 + '0';\nname = name + temp;\ncout << name << endl;\n\nOutput:  John5\n",
                "There is a function I wrote, which takes the int number as the parameter, and convert it to a string literal. This function is dependent on another function that converts a single digit to its char equivalent:char intToChar(int num)\n{\n    if (num < 10 && num >= 0)\n    {\n        return num + 48;\n        //48 is the number that we add to an integer number to have its character equivalent (see the unsigned ASCII table)\n    }\n    else\n    {\n        return '*';\n    }\n}\n\nstring intToString(int num)\n{\n    int digits = 0, process, single;\n    string numString;\n    process = num;\n\n    // The following process the number of digits in num\n    while (process != 0)\n    {\n        single  = process % 10; // 'single' now holds the rightmost portion of the int\n        process = (process - single)/10;\n        // Take out the rightmost number of the int (it's a zero in this portion of the int), then divide it by 10\n        // The above combination eliminates the rightmost portion of the int\n        digits ++;\n    }\n\n    process = num;\n\n    // Fill the numString with '*' times digits\n    for (int i = 0; i < digits; i++)\n    {\n        numString += '*';\n    }\n\n\n    for (int i = digits-1; i >= 0; i--)\n    {\n        single = process % 10;\n        numString[i] = intToChar ( single);\n        process = (process - single) / 10;\n    }\n\n    return numString;\n}\nchar intToChar(int num)\n{\n    if (num < 10 && num >= 0)\n    {\n        return num + 48;\n        //48 is the number that we add to an integer number to have its character equivalent (see the unsigned ASCII table)\n    }\n    else\n    {\n        return '*';\n    }\n}\n\nstring intToString(int num)\n{\n    int digits = 0, process, single;\n    string numString;\n    process = num;\n\n    // The following process the number of digits in num\n    while (process != 0)\n    {\n        single  = process % 10; // 'single' now holds the rightmost portion of the int\n        process = (process - single)/10;\n        // Take out the rightmost number of the int (it's a zero in this portion of the int), then divide it by 10\n        // The above combination eliminates the rightmost portion of the int\n        digits ++;\n    }\n\n    process = num;\n\n    // Fill the numString with '*' times digits\n    for (int i = 0; i < digits; i++)\n    {\n        numString += '*';\n    }\n\n\n    for (int i = digits-1; i >= 0; i--)\n    {\n        single = process % 10;\n        numString[i] = intToChar ( single);\n        process = (process - single) / 10;\n    }\n\n    return numString;\n}\n",
                "In C++ 20 you can have a variadic lambda that does concatenate arbitrary streamable types to a string in a few lines:auto make_string=[os=std::ostringstream{}](auto&& ...p) mutable \n{ \n  (os << ... << std::forward<decltype(p)>(p) ); \n  return std::move(os).str();\n};\n\nint main() {\nstd::cout << make_string(\"Hello world: \",4,2, \" is \", 42.0);\n}\nauto make_string=[os=std::ostringstream{}](auto&& ...p) mutable \n{ \n  (os << ... << std::forward<decltype(p)>(p) ); \n  return std::move(os).str();\n};\n\nint main() {\nstd::cout << make_string(\"Hello world: \",4,2, \" is \", 42.0);\n}\nsee https://godbolt.org/z/dEe9h75ebhttps://godbolt.org/z/dEe9h75ebusing move(os).str() guarantees that the ostringstream object's stringbuffer  is empty next time the lambda is  called."
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "How do you round UP a number?",
                "how do you round up a number?"
            ],
            "responses": [
                "The math.ceil (ceiling) function returns the smallest integer higher or equal to x.math.ceilxFor Python 3:import math\nprint(math.ceil(4.2))\nimport math\nprint(math.ceil(4.2))\nFor Python 2:import math\nprint(int(math.ceil(4.2)))\nimport math\nprint(int(math.ceil(4.2)))\n",
                "I know this answer is for a question from a while back, but if you don't want to import math and you just want to round up, this works for me.>>> int(21 / 5)\n4\n>>> int(21 / 5) + (21 % 5 > 0)\n5\n>>> int(21 / 5)\n4\n>>> int(21 / 5) + (21 % 5 > 0)\n5\nThe first part becomes 4 and the second part evaluates to \"True\" if there is a remainder, which in addition True = 1; False = 0. So if there is no remainder, then it stays the same integer, but if there is a remainder it adds 1.",
                "Interesting Python 2.x issue to keep in mind:>>> import math\n>>> math.ceil(4500/1000)\n4.0\n>>> math.ceil(4500/1000.0)\n5.0\n>>> import math\n>>> math.ceil(4500/1000)\n4.0\n>>> math.ceil(4500/1000.0)\n5.0\nThe problem is that dividing two ints in python produces another int and that's truncated before the ceiling call. You have to make one value a float (or cast) to get a correct result.In javascript, the exact same code produces a different result:console.log(Math.ceil(4500/1000));\n5\nconsole.log(Math.ceil(4500/1000));\n5\n",
                "If working with integers, one way of rounding up is to take advantage of the fact that // rounds down: Just do the division on the negative number, then negate the answer.  No import, floating point, or conditional needed.//rounded_up = -(-numerator // denominator)\nrounded_up = -(-numerator // denominator)\nFor example:>>> print(-(-101 // 5))\n21\n>>> print(-(-101 // 5))\n21\n",
                "You might also like numpy:>>> import numpy as np\n>>> np.ceil(2.3)\n3.0\n>>> import numpy as np\n>>> np.ceil(2.3)\n3.0\nI'm not saying it's better than math, but if you were already using numpy for other purposes, you can keep your code consistent. Anyway, just a detail I came across. I use numpy a lot and was surprised it didn't get mentioned, but of course the accepted answer works perfectly fine.",
                "Use math.ceil to round up:Use math.ceilmath.ceil>>> import math\n>>> math.ceil(5.4)\n6.0\n>>> import math\n>>> math.ceil(5.4)\n6.0\nNOTE: The input should be float.NOTEIf you need an integer, call int to convert it:int>>> int(math.ceil(5.4))\n6\n>>> int(math.ceil(5.4))\n6\nBTW, use math.floor to round down and round to round to nearest integer.math.floordownround>>> math.floor(4.4), math.floor(4.5), math.floor(5.4), math.floor(5.5)\n(4.0, 4.0, 5.0, 5.0)\n>>> round(4.4), round(4.5), round(5.4), round(5.5)\n(4.0, 5.0, 5.0, 6.0)\n>>> math.ceil(4.4), math.ceil(4.5), math.ceil(5.4), math.ceil(5.5)\n(5.0, 5.0, 6.0, 6.0)\n>>> math.floor(4.4), math.floor(4.5), math.floor(5.4), math.floor(5.5)\n(4.0, 4.0, 5.0, 5.0)\n>>> round(4.4), round(4.5), round(5.4), round(5.5)\n(4.0, 5.0, 5.0, 6.0)\n>>> math.ceil(4.4), math.ceil(4.5), math.ceil(5.4), math.ceil(5.5)\n(5.0, 5.0, 6.0, 6.0)\n",
                "I am surprised nobody suggested(numerator + denominator - 1) // denominator\n(numerator + denominator - 1) // denominator\nfor integer division with rounding up. Used to be the common way for C/C++/CUDA (cf. divup)divup",
                "The syntax may not be as pythonic as one might like, but it is a powerful library.https://docs.python.org/2/library/decimal.htmlhttps://docs.python.org/2/library/decimal.htmlfrom decimal import *\nprint(int(Decimal(2.3).quantize(Decimal('1.'), rounding=ROUND_UP)))\nfrom decimal import *\nprint(int(Decimal(2.3).quantize(Decimal('1.'), rounding=ROUND_UP)))\n",
                "For those who want to round up a / b and get integer:a / bAnother variant using integer division isdef int_ceil(a, b):\n    return (a - 1) // b + 1\n\n>>> int_ceil(19, 5)\n4\n>>> int_ceil(20, 5)\n4\n>>> int_ceil(21, 5)\n5\ndef int_ceil(a, b):\n    return (a - 1) // b + 1\n\n>>> int_ceil(19, 5)\n4\n>>> int_ceil(20, 5)\n4\n>>> int_ceil(21, 5)\n5\nNote: a and b must be non-negative integersNote: a and b must be non-negative integersab",
                "Try this:a = 211.0\nprint(int(a) + ((int(a) - a) != 0))\na = 211.0\nprint(int(a) + ((int(a) - a) != 0))\n",
                "Here is a way using modulo and boolmodulobooln = 2.3\nint(n) + bool(n%1)\nn = 2.3\nint(n) + bool(n%1)\nOutput:3\n3\n",
                "Be shure rounded value should be float a = 8 \nb = 21\nprint math.ceil(a / b)\n>>> 0\na = 8 \nb = 21\nprint math.ceil(a / b)\n>>> 0\nbutprint math.ceil(float(a) / b)\n>>> 1.0\nprint math.ceil(float(a) / b)\n>>> 1.0\n",
                "The above answers are correct, however, importing the math module just for this one function usually feels like a bit of an overkill for me. Luckily, there is another way to do it:mathg = 7/5\ng = int(g) + (not g.is_integer())\ng = 7/5\ng = int(g) + (not g.is_integer())\nTrue and False are interpreted as 1 and 0 in a statement involving numbers in python. g.is_interger() basically translates to g.has_no_decimal() or g == int(g). So the last statement in English reads round g down and add one if g has decimal.TrueFalse10g.is_interger()g.has_no_decimal()g == int(g)round g down and add one if g has decimal",
                "In case anyone is looking to round up to a specific decimal place:import math\ndef round_up(n, decimals=0):\n    multiplier = 10 ** decimals\n    return math.ceil(n * multiplier) / multiplier\nimport math\ndef round_up(n, decimals=0):\n    multiplier = 10 ** decimals\n    return math.ceil(n * multiplier) / multiplier\n",
                "Without importing math // using basic envionment:a) method / class methoddef ceil(fl): \n  return int(fl) + (1 if fl-int(fl) else 0)\n\ndef ceil(self, fl): \n  return int(fl) + (1 if fl-int(fl) else 0)\ndef ceil(fl): \n  return int(fl) + (1 if fl-int(fl) else 0)\n\ndef ceil(self, fl): \n  return int(fl) + (1 if fl-int(fl) else 0)\nb) lambda:ceil = lambda fl:int(fl)+(1 if fl-int(fl) else 0)\nceil = lambda fl:int(fl)+(1 if fl-int(fl) else 0)\n",
                ">>> def roundup(number):\n...     return round(number+.5)\n>>> roundup(2.3)\n3\n>>> roundup(19.00000000001)\n20\n>>> def roundup(number):\n...     return round(number+.5)\n>>> roundup(2.3)\n3\n>>> roundup(19.00000000001)\n20\nThis function requires no modules.",
                "x * -1 // 1 * -1x * -1 // 1 * -1Confusing but it works: For x=7.1, you get 8.0. For x = -1.1, you get -1.0x=7.18.0x = -1.1-1.0No need to import a module.",
                "For those who doesn't want to use import.For a given list or any number:x = [2, 2.1, 2.5, 3, 3.1, 3.5, 2.499,2.4999999999, 3.4999999,3.99999999999]\nx = [2, 2.1, 2.5, 3, 3.1, 3.5, 2.499,2.4999999999, 3.4999999,3.99999999999]\nYou must first evaluate if the number is equal to its integer, which always rounds down. If the result is True, you return the number, if is not, return the integer(number) + 1.w = lambda x: x if x == int(x) else int(x)+1\n[w(i) for i in z]\n>>> [2, 3, 3, 3, 4, 4, 3, 3, 4, 4]\nw = lambda x: x if x == int(x) else int(x)+1\n[w(i) for i in z]\n>>> [2, 3, 3, 3, 4, 4, 3, 3, 4, 4]\nMath logic:\nIf the number has decimal part: round_up - round_down == 1, always.\nIf the number doens't have decimal part: round_up - round_down == 0.\nIf the number has decimal part: round_up - round_down == 1, always.If the number doens't have decimal part: round_up - round_down == 0.So:\nround_up == x + round_down\nround_up == x + round_downWith:\nx == 1 if number != round_down\nx == 0 if number == round_down\nx == 1 if number != round_downx == 0 if number == round_downYou are cutting the number in 2 parts, the integer and decimal. If decimal isn't 0, you add 1.PS:I explained this in details since some comments above asked for that and I'm still noob here, so I can't comment.",
                "If you don't want to import anything, you can always write your own simple function as:def RoundUP(num):\n    if num== int(num):\n        return num\n    return int(num + 1)\ndef RoundUP(num):\n    if num== int(num):\n        return num\n    return int(num + 1)\n",
                "You could use round like this:cost_per_person = round(150 / 2, 2)\n\n  \ncost_per_person = round(150 / 2, 2)\n\n  \n",
                "To do it without any import:>>> round_up = lambda num: int(num + 1) if int(num) != num else int(num)\n>>> round_up(2.0)\n2\n>>> round_up(2.1)\n3\n>>> round_up = lambda num: int(num + 1) if int(num) != num else int(num)\n>>> round_up(2.0)\n2\n>>> round_up(2.1)\n3\n",
                "I know this is from quite a while back, but I found a quite interesting answer, so here goes:-round(-x-0.5)\n-round(-x-0.5)\nThis fixes the edges cases and works for both positive and negative numbers, and doesn't require any function importCheers",
                "I'm surprised I haven't seen this answer yet round(x + 0.4999), so I'm going to put it down. Note that this works with any Python version. Changes made to the Python rounding scheme has made things difficult. See this post.round(x + 0.4999)postWithout importing, I use:def roundUp(num):\n    return round(num + 0.49)\n\ntestCases = list(x*0.1 for x in range(0, 50))\n\nprint(testCases)\nfor test in testCases:\n    print(\"{:5.2f}  -> {:5.2f}\".format(test, roundUp(test)))\ndef roundUp(num):\n    return round(num + 0.49)\n\ntestCases = list(x*0.1 for x in range(0, 50))\n\nprint(testCases)\nfor test in testCases:\n    print(\"{:5.2f}  -> {:5.2f}\".format(test, roundUp(test)))\nWhy this worksWhy this worksFrom the docs\nFor the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus n; if two multiples are equally close, rounding is done toward the even choice\nFor the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus n; if two multiples are equally close, rounding is done toward the even choiceTherefore 2.5 gets rounded to 2 and 3.5 gets rounded to 4. If this was not the case then rounding up could be done by adding 0.5, but we want to avoid getting to the halfway point. So, if you add 0.4999 you will get close, but with enough margin to be rounded to what you would normally expect. Of course, this will fail if the x + 0.4999 is equal to [n].5000, but that is unlikely.x + 0.4999[n].5000",
                "You can use floor devision and add 1 to it.\n2.3 // 2 + 1",
                "when you operate 4500/1000 in python, result will be 4, because for default python asume as integer the result, logically:\n4500/1000 = 4.5  -->  int(4.5) = 4\nand ceil of 4 obviouslly is 4using 4500/1000.0 the result will be 4.5 and ceil of 4.5 --> 5Using javascript you will recieve 4.5 as result of 4500/1000, because javascript asume only the result as \"numeric type\" and return a result directly as floatGood Luck!!",
                "I think you are confusing the working mechanisms between int() and round().int()round()int() always truncates the decimal numbers if a floating number is given; whereas round(), in case of 2.5 where 2 and 3 are both within equal distance from 2.5, Python returns whichever that is more away from the 0 point. int()round()2.5232.5round(2.5) = 3\nint(2.5) = 2\nround(2.5) = 3\nint(2.5) = 2\n",
                "My shareI have tested  print(-(-101 // 5)) = 21 given example above.print(-(-101 // 5)) = 21Now for rounding  up: 101 * 19% = 19.19\n101 * 19% = 19.19\nI can not use ** so I spread the multiply to division:**(-(-101 //(1/0.19))) = 20\n(-(-101 //(1/0.19))) = 20\n",
                "I'm basically a beginner at Python, but if you're just trying to round up instead of down why not do:round(integer) + 1\nround(integer) + 1\n"
            ]
        },
        {
            "tag": "string",
            "patterns": [
                "How to convert an int value to string in Go?",
                "how do you convert the value of an int into a string in go?",
                "how can you convert an int value to a string in go?",
                "how can i convert an int value to string in go?"
            ],
            "responses": [
                "Use the strconv package's Itoa function.strconvstrconvItoaFor example:package main\n\nimport (\n    \"strconv\"\n    \"fmt\"\n)\n\nfunc main() {\n    t := strconv.Itoa(123)\n    fmt.Println(t)\n}\npackage main\n\nimport (\n    \"strconv\"\n    \"fmt\"\n)\n\nfunc main() {\n    t := strconv.Itoa(123)\n    fmt.Println(t)\n}\nYou can concat strings simply by +'ing them, or by using the Join function of the strings package.+Joinstringsstrings",
                "fmt.Sprintf(\"%v\",value);\nfmt.Sprintf(\"%v\",value);\nIf you know the specific type of value use the corresponding formatter for example %d for int %dintMore info - fmtfmt",
                "fmt.Sprintf, strconv.Itoa and strconv.FormatInt will do the job. But Sprintf will use the package reflect, and it will allocate one more object,  so it's not an efficient choice.fmt.Sprintfstrconv.Itoastrconv.FormatIntSprintfreflect",
                "It is interesting to note that strconv.Itoa is shorthand for strconv.Itoashorthandfunc FormatInt(i int64, base int) string\nfunc FormatInt(i int64, base int) string\nwith base 10For Example:strconv.Itoa(123)\nstrconv.Itoa(123)\nis equivalent tostrconv.FormatInt(int64(123), 10)\nstrconv.FormatInt(int64(123), 10)\n",
                "You can use fmt.Sprintf or strconv.FormatFloatfmt.Sprintfstrconv.FormatFloatFor examplepackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    val := 14.7\n    s := fmt.Sprintf(\"%f\", val)\n    fmt.Println(s)\n}\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    val := 14.7\n    s := fmt.Sprintf(\"%f\", val)\n    fmt.Println(s)\n}\n",
                "In this case both strconv and fmt.Sprintf do the same job but using the strconv package's Itoa function is the best choice, because fmt.Sprintf allocate one more object during conversion. strconvfmt.SprintfstrconvItoafmt.Sprintf\ncheck the benchmark here: https://gist.github.com/evalphobia/caee1602969a640a4530https://gist.github.com/evalphobia/caee1602969a640a4530see https://play.golang.org/p/hlaz_rMa0D for example.https://play.golang.org/p/hlaz_rMa0D",
                "Converting int64:int64n := int64(32)\nstr := strconv.FormatInt(n, 10)\n\nfmt.Println(str)\n// Prints \"32\"\nn := int64(32)\nstr := strconv.FormatInt(n, 10)\n\nfmt.Println(str)\n// Prints \"32\"\n",
                "ok,most of them have shown you something good.\nLet'me give you this:// ToString Change arg to string\nfunc ToString(arg interface{}, timeFormat ...string) string {\n    if len(timeFormat) > 1 {\n        log.SetFlags(log.Llongfile | log.LstdFlags)\n        log.Println(errors.New(fmt.Sprintf(\"timeFormat's length should be one\")))\n    }\n    var tmp = reflect.Indirect(reflect.ValueOf(arg)).Interface()\n    switch v := tmp.(type) {\n    case int:\n        return strconv.Itoa(v)\n    case int8:\n        return strconv.FormatInt(int64(v), 10)\n    case int16:\n        return strconv.FormatInt(int64(v), 10)\n    case int32:\n        return strconv.FormatInt(int64(v), 10)\n    case int64:\n        return strconv.FormatInt(v, 10)\n    case string:\n        return v\n    case float32:\n        return strconv.FormatFloat(float64(v), 'f', -1, 32)\n    case float64:\n        return strconv.FormatFloat(v, 'f', -1, 64)\n    case time.Time:\n        if len(timeFormat) == 1 {\n            return v.Format(timeFormat[0])\n        }\n        return v.Format(\"2006-01-02 15:04:05\")\n    case jsoncrack.Time:\n        if len(timeFormat) == 1 {\n            return v.Time().Format(timeFormat[0])\n        }\n        return v.Time().Format(\"2006-01-02 15:04:05\")\n    case fmt.Stringer:\n        return v.String()\n    case reflect.Value:\n        return ToString(v.Interface(), timeFormat...)\n    default:\n        return \"\"\n    }\n}\n// ToString Change arg to string\nfunc ToString(arg interface{}, timeFormat ...string) string {\n    if len(timeFormat) > 1 {\n        log.SetFlags(log.Llongfile | log.LstdFlags)\n        log.Println(errors.New(fmt.Sprintf(\"timeFormat's length should be one\")))\n    }\n    var tmp = reflect.Indirect(reflect.ValueOf(arg)).Interface()\n    switch v := tmp.(type) {\n    case int:\n        return strconv.Itoa(v)\n    case int8:\n        return strconv.FormatInt(int64(v), 10)\n    case int16:\n        return strconv.FormatInt(int64(v), 10)\n    case int32:\n        return strconv.FormatInt(int64(v), 10)\n    case int64:\n        return strconv.FormatInt(v, 10)\n    case string:\n        return v\n    case float32:\n        return strconv.FormatFloat(float64(v), 'f', -1, 32)\n    case float64:\n        return strconv.FormatFloat(v, 'f', -1, 64)\n    case time.Time:\n        if len(timeFormat) == 1 {\n            return v.Format(timeFormat[0])\n        }\n        return v.Format(\"2006-01-02 15:04:05\")\n    case jsoncrack.Time:\n        if len(timeFormat) == 1 {\n            return v.Time().Format(timeFormat[0])\n        }\n        return v.Time().Format(\"2006-01-02 15:04:05\")\n    case fmt.Stringer:\n        return v.String()\n    case reflect.Value:\n        return ToString(v.Interface(), timeFormat...)\n    default:\n        return \"\"\n    }\n}\n",
                "Another option:package main\nimport \"fmt\"\n\nfunc main() {\n   n := 123\n   s := fmt.Sprint(n)\n   fmt.Println(s == \"123\")\n}\npackage main\nimport \"fmt\"\n\nfunc main() {\n   n := 123\n   s := fmt.Sprint(n)\n   fmt.Println(s == \"123\")\n}\nhttps://golang.org/pkg/fmt#Sprinthttps://golang.org/pkg/fmt#Sprint",
                "package main\n\nimport (\n    \"fmt\" \n    \"strconv\"\n)\n\nfunc main(){\n//First question: how to get int string?\n\n    intValue := 123\n    // keeping it in separate variable : \n    strValue := strconv.Itoa(intValue) \n    fmt.Println(strValue)\n\n//Second question: how to concat two strings?\n\n    firstStr := \"ab\"\n    secondStr := \"c\"\n    s := firstStr + secondStr\n    fmt.Println(s)\n}\npackage main\n\nimport (\n    \"fmt\" \n    \"strconv\"\n)\n\nfunc main(){\n//First question: how to get int string?\n\n    intValue := 123\n    // keeping it in separate variable : \n    strValue := strconv.Itoa(intValue) \n    fmt.Println(strValue)\n\n//Second question: how to concat two strings?\n\n    firstStr := \"ab\"\n    secondStr := \"c\"\n    s := firstStr + secondStr\n    fmt.Println(s)\n}\n"
            ]
        },
        {
            "tag": "c++",
            "patterns": [
                "How can I convert a std::string to int?",
                "how do i convert strings int from stdstring?",
                "how do i convert a string like stdstring to int?",
                "how do i convert a string int?",
                "what can i do to convert stdstring into int?",
                "how do i convert stdstring into int?",
                "how do i convert a string to int?",
                "how can you convert stdstring to int?"
            ],
            "responses": [
                "In C++11 there are some nice new convert functions from std::string to a number type.std::stringSo instead of atoi( str.c_str() )\natoi( str.c_str() )\nyou can usestd::stoi( str )\nstd::stoi( str )\nwhere str is your number as std::string.strstd::stringThere are version for all flavours of numbers:\nlong stol(string), float stof(string), double stod(string),...\nsee http://en.cppreference.com/w/cpp/string/basic_string/stollong stol(string)float stof(string)double stod(string)http://en.cppreference.com/w/cpp/string/basic_string/stol",
                "The possible options are described below:1. sscanf()1. sscanf()    #include <cstdio>\n    #include <string>\n\n        int i;\n        float f;\n        double d;\n        std::string str;\n\n        // string -> integer\n        if(sscanf(str.c_str(), \"%d\", &i) != 1)\n            // error management\n\n        // string -> float\n        if(sscanf(str.c_str(), \"%f\", &f) != 1)\n            // error management\n    \n        // string -> double \n        if(sscanf(str.c_str(), \"%lf\", &d) != 1)\n            // error management\n    #include <cstdio>\n    #include <string>\n\n        int i;\n        float f;\n        double d;\n        std::string str;\n\n        // string -> integer\n        if(sscanf(str.c_str(), \"%d\", &i) != 1)\n            // error management\n\n        // string -> float\n        if(sscanf(str.c_str(), \"%f\", &f) != 1)\n            // error management\n    \n        // string -> double \n        if(sscanf(str.c_str(), \"%lf\", &d) != 1)\n            // error management\nThis is an error (also shown by cppcheck) because \"scanf without field width limits can crash with huge input data on some versions of libc\" (see here, and here).\"scanf without field width limits can crash with huge input data on some versions of libc\"herehere2. std::sto()*2. std::sto()2. std::sto    #include <iostream>\n    #include <string>\n\n        int i;\n        float f;\n        double d;\n        std::string str;\n\n        try {\n            // string -> integer\n            int i = std::stoi(str);\n\n            // string -> float\n            float f = std::stof(str);\n\n            // string -> double \n            double d = std::stod(str);\n        } catch (...) {\n            // error management\n        }   \n    #include <iostream>\n    #include <string>\n\n        int i;\n        float f;\n        double d;\n        std::string str;\n\n        try {\n            // string -> integer\n            int i = std::stoi(str);\n\n            // string -> float\n            float f = std::stof(str);\n\n            // string -> double \n            double d = std::stod(str);\n        } catch (...) {\n            // error management\n        }   \nThis solution is short and elegant, but it is available only on on C++11 compliant compilers.3. sstreams3. sstreams    #include <string>\n    #include <sstream>\n\n        int i;\n        float f;\n        double d;\n        std::string str;\n\n        // string -> integer\n        std::istringstream ( str ) >> i;\n\n        // string -> float\n        std::istringstream ( str ) >> f;\n\n        // string -> double \n        std::istringstream ( str ) >> d;\n\n        // error management ??\n    #include <string>\n    #include <sstream>\n\n        int i;\n        float f;\n        double d;\n        std::string str;\n\n        // string -> integer\n        std::istringstream ( str ) >> i;\n\n        // string -> float\n        std::istringstream ( str ) >> f;\n\n        // string -> double \n        std::istringstream ( str ) >> d;\n\n        // error management ??\nHowever, with this solution is hard to distinguish between bad input (see here).here4. Boost's lexical_cast4. Boost's lexical_cast    #include <boost/lexical_cast.hpp>\n    #include <string>\n\n        std::string str;\n\n        try {\n            int i = boost::lexical_cast<int>( str.c_str());\n            float f = boost::lexical_cast<int>( str.c_str());\n            double d = boost::lexical_cast<int>( str.c_str());\n            } catch( boost::bad_lexical_cast const& ) {\n                // Error management\n        }\n    #include <boost/lexical_cast.hpp>\n    #include <string>\n\n        std::string str;\n\n        try {\n            int i = boost::lexical_cast<int>( str.c_str());\n            float f = boost::lexical_cast<int>( str.c_str());\n            double d = boost::lexical_cast<int>( str.c_str());\n            } catch( boost::bad_lexical_cast const& ) {\n                // Error management\n        }\nHowever, this is just a wrapper of sstream, and the documentation suggests to use sstream for better error management (see here).sstreamsstreamhere5. strto()*5. strto()5. strtoThis solution is very long, due to error management, and it is described here. Since no function returns a plain int, a conversion is needed in case of integer (see here for how this conversion can be achieved).here6. Qt6. Qt    #include <QString>\n    #include <string>\n\n        bool ok;\n        std::string;\n\n        int i = QString::fromStdString(str).toInt(&ok);\n        if (!ok)\n            // Error management\n    \n        float f = QString::fromStdString(str).toFloat(&ok);\n        if (!ok)\n            // Error management \n\n        double d = QString::fromStdString(str).toDouble(&ok);\n        if (!ok)\n    // Error management     \n    \n    #include <QString>\n    #include <string>\n\n        bool ok;\n        std::string;\n\n        int i = QString::fromStdString(str).toInt(&ok);\n        if (!ok)\n            // Error management\n    \n        float f = QString::fromStdString(str).toFloat(&ok);\n        if (!ok)\n            // Error management \n\n        double d = QString::fromStdString(str).toDouble(&ok);\n        if (!ok)\n    // Error management     \n    \nConclusionsConclusionsSumming up, the best solution is C++11 std::stoi() or, as a second option, the use of Qt libraries. All other solutions are discouraged or buggy.std::stoi()",
                "std::istringstream ss(thestring);\nss >> thevalue;\nstd::istringstream ss(thestring);\nss >> thevalue;\nTo be fully correct you'll want to check the error flags.",
                "use the atoi function to convert the string to an integer:string a = \"25\";\n\nint b = atoi(a.c_str());\nstring a = \"25\";\n\nint b = atoi(a.c_str());\nhttp://www.cplusplus.com/reference/clibrary/cstdlib/atoi/http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/",
                "To be more exhaustive (and as it has been requested in comments), I add the solution given by C++17 using std::from_chars.std::from_charsstd::from_charsstd::string str = \"10\";\nint number;\nstd::from_chars(str.data(), str.data()+str.size(), number);\nstd::string str = \"10\";\nint number;\nstd::from_chars(str.data(), str.data()+str.size(), number);\nIf you want to check whether the conversion was successful:std::string str = \"10\";\nint number;\nauto [ptr, ec] = std::from_chars(str.data(), str.data()+str.size(), number);\nassert(ec == std::errc{});\n// ptr points to chars after read number\nstd::string str = \"10\";\nint number;\nauto [ptr, ec] = std::from_chars(str.data(), str.data()+str.size(), number);\nassert(ec == std::errc{});\n// ptr points to chars after read number\nMoreover, to compare the performance of all these solutions, see the following quick-bench link: https://quick-bench.com/q/GBzK53Gc-YSWpEA9XskSZLU963Yhttps://quick-bench.com/q/GBzK53Gc-YSWpEA9XskSZLU963Y(std::from_chars is the fastest and std::istringstream is the slowest)std::from_charsstd::istringstream",
                "1. std::stoistd::string str = \"10\";  \nint number = std::stoi(str); \nstd::string str = \"10\";  \nint number = std::stoi(str); \n2. string streamsstd::string str = \"10\";  \nint number;  \nstd::istringstream(str) >> number\nstd::string str = \"10\";  \nint number;  \nstd::istringstream(str) >> number\n3. boost::lexical_cast#include <boost/lexical_cast.hpp>\nstd::string str = \"10\";  \nint number;\n    \ntry \n{\n    number = boost::lexical_cast<int>(str);\n    std::cout << number << std::endl;\n}\ncatch (boost::bad_lexical_cast const &e) // bad input\n{\n    std::cout << \"error\" << std::endl;\n}\n#include <boost/lexical_cast.hpp>\nstd::string str = \"10\";  \nint number;\n    \ntry \n{\n    number = boost::lexical_cast<int>(str);\n    std::cout << number << std::endl;\n}\ncatch (boost::bad_lexical_cast const &e) // bad input\n{\n    std::cout << \"error\" << std::endl;\n}\n4. std::atoistd::string str = \"10\";\nint number = std::atoi(str.c_str()); \nstd::string str = \"10\";\nint number = std::atoi(str.c_str()); \n5. sscanf() std::string str = \"10\";\n int number;\n if (sscanf(str .c_str(), \"%d\", &number) == 1) \n {\n     std::cout << number << '\\n';\n } \n else \n {\n     std::cout << \"Bad Input\";\n }\n std::string str = \"10\";\n int number;\n if (sscanf(str .c_str(), \"%d\", &number) == 1) \n {\n     std::cout << number << '\\n';\n } \n else \n {\n     std::cout << \"Bad Input\";\n }\n",
                "What about Boost.Lexical_cast?Boost.Lexical_castHere is their example:\nThe following example treats command line arguments as a sequence of numeric data:\nThe following example treats command line arguments as a sequence of numeric data:int main(int argc, char * argv[])\n{\n    using boost::lexical_cast;\n    using boost::bad_lexical_cast;\n\n    std::vector<short> args;\n\n    while(*++argv)\n    {\n        try\n        {\n            args.push_back(lexical_cast<short>(*argv));\n        }\n        catch(bad_lexical_cast &)\n        {\n            args.push_back(0);\n        }\n    }\n    ...\n}\nint main(int argc, char * argv[])\n{\n    using boost::lexical_cast;\n    using boost::bad_lexical_cast;\n\n    std::vector<short> args;\n\n    while(*++argv)\n    {\n        try\n        {\n            args.push_back(lexical_cast<short>(*argv));\n        }\n        catch(bad_lexical_cast &)\n        {\n            args.push_back(0);\n        }\n    }\n    ...\n}\n",
                "Admittedly, my solution wouldn't work for negative integers, but it will extract all positive integers from input text containing integers. It makes use of numeric_only locale:numeric_onlyint main() {\n        int num;\n        std::cin.imbue(std::locale(std::locale(), new numeric_only()));\n        while ( std::cin >> num)\n             std::cout << num << std::endl;\n        return 0;\n}\nint main() {\n        int num;\n        std::cin.imbue(std::locale(std::locale(), new numeric_only()));\n        while ( std::cin >> num)\n             std::cout << num << std::endl;\n        return 0;\n}\nInput text: the format (-5) or (25) etc... some text.. and then.. 7987...78hjh.hhjg9878\n the format (-5) or (25) etc... some text.. and then.. 7987...78hjh.hhjg9878\nOutput integers: 5\n25\n7987\n78\n9878\n 5\n25\n7987\n78\n9878\nThe class numeric_only is defined as:numeric_onlystruct numeric_only: std::ctype<char> \n{\n    numeric_only(): std::ctype<char>(get_table()) {}\n\n    static std::ctype_base::mask const* get_table()\n    {\n        static std::vector<std::ctype_base::mask> \n            rc(std::ctype<char>::table_size,std::ctype_base::space);\n\n        std::fill(&rc['0'], &rc[':'], std::ctype_base::digit);\n        return &rc[0];\n    }\n};\nstruct numeric_only: std::ctype<char> \n{\n    numeric_only(): std::ctype<char>(get_table()) {}\n\n    static std::ctype_base::mask const* get_table()\n    {\n        static std::vector<std::ctype_base::mask> \n            rc(std::ctype<char>::table_size,std::ctype_base::space);\n\n        std::fill(&rc['0'], &rc[':'], std::ctype_base::digit);\n        return &rc[0];\n    }\n};\nComplete online demo : http://ideone.com/dRWSjhttp://ideone.com/dRWSj",
                "In C++11 we can use \"stoi\" function to convert string into a int\"stoi\"#include <iostream>\n#include <string>\nusing namespace std;\n \nint main()\n{\n    string s1 = \"16\";\n    string s2 = \"9.49\";\n    string s3 = \"1226\";\n \n    int num1 = stoi(s1);\n    int num2 = stoi(s2);\n    int num3 = stoi(s3);\n \n    cout << \"stoi(\\\"\" << s1 << \"\\\") is \" << num1 << '\\n';\n    cout << \"stoi(\\\"\" << s2 << \"\\\") is \" << num2 << '\\n';\n    cout << \"stoi(\\\"\" << s3 << \"\\\") is \" << num3 << '\\n';\n \n    return 0;\n}\n#include <iostream>\n#include <string>\nusing namespace std;\n \nint main()\n{\n    string s1 = \"16\";\n    string s2 = \"9.49\";\n    string s3 = \"1226\";\n \n    int num1 = stoi(s1);\n    int num2 = stoi(s2);\n    int num3 = stoi(s3);\n \n    cout << \"stoi(\\\"\" << s1 << \"\\\") is \" << num1 << '\\n';\n    cout << \"stoi(\\\"\" << s2 << \"\\\") is \" << num2 << '\\n';\n    cout << \"stoi(\\\"\" << s3 << \"\\\") is \" << num3 << '\\n';\n \n    return 0;\n}\n",
                "It's probably a bit of overkill, but \nboost::lexical_cast<int>( theString ) should to the job\nquite well. boost::lexical_cast<int>( theString )",
                "Well, lot of answers, lot of possibilities. What I am missing here is some universal method that converts a string to different C++ integral types (short, int, long, bool, ...).\nI came up with following solution:#include<sstream>\n#include<exception>\n#include<string>\n#include<type_traits>\n\nusing namespace std;\n\ntemplate<typename T>\nT toIntegralType(const string &str) {\n    static_assert(is_integral<T>::value, \"Integral type required.\");\n    T ret;\n    stringstream ss(str);\n    ss >> ret;\n    if ( to_string(ret) != str)\n        throw invalid_argument(\"Can't convert \" + str);\n    return ret;\n}\n#include<sstream>\n#include<exception>\n#include<string>\n#include<type_traits>\n\nusing namespace std;\n\ntemplate<typename T>\nT toIntegralType(const string &str) {\n    static_assert(is_integral<T>::value, \"Integral type required.\");\n    T ret;\n    stringstream ss(str);\n    ss >> ret;\n    if ( to_string(ret) != str)\n        throw invalid_argument(\"Can't convert \" + str);\n    return ret;\n}\nHere are examples of usage:string str = \"123\";\nint x = toIntegralType<int>(str); // x = 123\n\nstr = \"123a\";\nx = toIntegralType<int>(str); // throws exception, because \"123a\" is not int\n\nstr = \"1\";\nbool y = toIntegralType<bool>(str); // y is true\nstr = \"0\";\ny = toIntegralType<bool>(str); // y is false\nstr = \"00\";\ny = toIntegralType<bool>(str); // throws exception\nstring str = \"123\";\nint x = toIntegralType<int>(str); // x = 123\n\nstr = \"123a\";\nx = toIntegralType<int>(str); // throws exception, because \"123a\" is not int\n\nstr = \"1\";\nbool y = toIntegralType<bool>(str); // y is true\nstr = \"0\";\ny = toIntegralType<bool>(str); // y is false\nstr = \"00\";\ny = toIntegralType<bool>(str); // throws exception\nWhy not just use stringstream output operator to convert a string into an integral type?\nHere is the answer:\nLet's say a string contains a value that exceeds the limit for intended integral type. For examle, on Wndows 64 max int is 2147483647.\nLet's assign to a string a value max int + 1: string str = \"2147483648\". \nNow, when converting the string to an int:stringstream ss(str);\nint x;\nss >> x;\nstringstream ss(str);\nint x;\nss >> x;\nx becomes 2147483647, what is definitely an error: string \"2147483648\" was not supposed to be converted to the int 2147483647. The provided function toIntegralType spots such errors and throws exception.",
                "In Windows, you could use:const std::wstring hex = L\"0x13\";\nconst std::wstring dec = L\"19\";\n\nint ret;\nif (StrToIntEx(hex.c_str(), STIF_SUPPORT_HEX, &ret)) {\n    std::cout << ret << \"\\n\";\n}\nif (StrToIntEx(dec.c_str(), STIF_SUPPORT_HEX, &ret)) {\n    std::cout << ret << \"\\n\";\n}\nconst std::wstring hex = L\"0x13\";\nconst std::wstring dec = L\"19\";\n\nint ret;\nif (StrToIntEx(hex.c_str(), STIF_SUPPORT_HEX, &ret)) {\n    std::cout << ret << \"\\n\";\n}\nif (StrToIntEx(dec.c_str(), STIF_SUPPORT_HEX, &ret)) {\n    std::cout << ret << \"\\n\";\n}\nstrtol,stringstream need to specify the base if you need to interpret hexdecimal.strtolstringstream",
                "I know this question is really old but I think there's a better way of doing this#include <string>\n#include <sstream>\n\nbool string_to_int(std::string value, int * result) {\n  std::stringstream stream1, stream2;\n  std::string stringednumber;\n  int tempnumber;\n  stream1 << value;\n  stream1 >> tempnumber;\n  stream2 << tempnumber;\n  stream2 >> stringednumber;\n  if (!value.compare(stringednumber)) {\n    *result = tempnumber;\n    return true;\n  }\n  else return false;\n}\n#include <string>\n#include <sstream>\n\nbool string_to_int(std::string value, int * result) {\n  std::stringstream stream1, stream2;\n  std::string stringednumber;\n  int tempnumber;\n  stream1 << value;\n  stream1 >> tempnumber;\n  stream2 << tempnumber;\n  stream2 >> stringednumber;\n  if (!value.compare(stringednumber)) {\n    *result = tempnumber;\n    return true;\n  }\n  else return false;\n}\nIf I wrote the code right, this will return a boolean value that tells you if the string was a valid number, if false, it wasn't a number, if true it was a number and that number is now result, you would call this this way:std::string input;\nstd::cin >> input;\nbool worked = string_to_int(input, &result);\nstd::string input;\nstd::cin >> input;\nbool worked = string_to_int(input, &result);\n",
                "You can use std::stringstream, here's an example:std::stringstream#include <iostream>\n#include <sstream>\nusing namespace std;\nstring r;\nint main() {\n    cin >> r;\n    stringstream tmp(r);\n    int s;\n    tmp >> s;\n    cout << s;\n    return 0;\n}\n#include <iostream>\n#include <sstream>\nusing namespace std;\nstring r;\nint main() {\n    cin >> r;\n    stringstream tmp(r);\n    int s;\n    tmp >> s;\n    cout << s;\n    return 0;\n}\n",
                "atoi is a built-in function that converts a string to an integer, assuming that the string begins with an integer representation.atoihttp://www.cplusplus.com/reference/clibrary/cstdlib/atoi/http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/",
                "From http://www.cplusplus.com/reference/string/stoi/http://www.cplusplus.com/reference/string/stoi/// stoi example\n#include <iostream>   // std::cout\n#include <string>     // std::string, std::stoi\n\nint main ()\n{\n  std::string str_dec = \"2001, A Space Odyssey\";\n  std::string str_hex = \"40c3\";\n  std::string str_bin = \"-10010110001\";\n  std::string str_auto = \"0x7f\";\n\n  std::string::size_type sz;   // alias of size_t\n\n  int i_dec = std::stoi (str_dec,&sz);\n  int i_hex = std::stoi (str_hex,nullptr,16);\n  int i_bin = std::stoi (str_bin,nullptr,2);\n  int i_auto = std::stoi (str_auto,nullptr,0);\n\n  std::cout << str_dec << \": \" << i_dec << \" and [\" << str_dec.substr(sz) << \"]\\n\";\n  std::cout << str_hex << \": \" << i_hex << '\\n';\n  std::cout << str_bin << \": \" << i_bin << '\\n';\n  std::cout << str_auto << \": \" << i_auto << '\\n';\n\n  return 0;\n}\n// stoi example\n#include <iostream>   // std::cout\n#include <string>     // std::string, std::stoi\n\nint main ()\n{\n  std::string str_dec = \"2001, A Space Odyssey\";\n  std::string str_hex = \"40c3\";\n  std::string str_bin = \"-10010110001\";\n  std::string str_auto = \"0x7f\";\n\n  std::string::size_type sz;   // alias of size_t\n\n  int i_dec = std::stoi (str_dec,&sz);\n  int i_hex = std::stoi (str_hex,nullptr,16);\n  int i_bin = std::stoi (str_bin,nullptr,2);\n  int i_auto = std::stoi (str_auto,nullptr,0);\n\n  std::cout << str_dec << \": \" << i_dec << \" and [\" << str_dec.substr(sz) << \"]\\n\";\n  std::cout << str_hex << \": \" << i_hex << '\\n';\n  std::cout << str_bin << \": \" << i_bin << '\\n';\n  std::cout << str_auto << \": \" << i_auto << '\\n';\n\n  return 0;\n}\nOutput:2001, A Space Odyssey: 2001 and [, A Space Odyssey]40c3:  16579-10010110001: -12010x7f: 127",
                "My Code:#include <iostream>\nusing namespace std;\n\nint main()\n{\n    string s=\"32\";  //String\n    int n=stoi(s);  //Convert to int\n    cout << n + 1 << endl;\n\n    return 0;\n}\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    string s=\"32\";  //String\n    int n=stoi(s);  //Convert to int\n    cout << n + 1 << endl;\n\n    return 0;\n}\n",
                "ll toll(string a){\n    ll ret=0;\n    bool minus=false;\n    for(auto i:a){\n        if(i=='-'){ minus=true; continue; }\n        ret*=10;\n        ret+=(i-'0');\n    } if(minus) ret*=-1;\n    return ret;\n    # ll is defined as, #define ll long long int\n    # usage: ll a = toll(string(\"-1234\"));\n}\nll toll(string a){\n    ll ret=0;\n    bool minus=false;\n    for(auto i:a){\n        if(i=='-'){ minus=true; continue; }\n        ret*=10;\n        ret+=(i-'0');\n    } if(minus) ret*=-1;\n    return ret;\n    # ll is defined as, #define ll long long int\n    # usage: ll a = toll(string(\"-1234\"));\n}\n",
                "To convert from string representation to integer value, we can use std::stringstream.if the value converted is out of range for integer data type, it returns INT_MIN or INT_MAX.Also if the string value can\u2019t be represented as an valid int data type, then 0 is returned.#include \n#include \n#include \n\nint main() {\n\n    std::string x = \"50\";\n    int y;\n    std::istringstream(x) >> y;\n    std::cout << y << '\\n';\n    return 0;\n}\n#include \n#include \n#include \n\nint main() {\n\n    std::string x = \"50\";\n    int y;\n    std::istringstream(x) >> y;\n    std::cout << y << '\\n';\n    return 0;\n}\nOutput:\n50As per the above output, we can see it converted from string numbers to integer number.Source and more at string to int c++string to int c++",
                " int stringToInt(std::string value) {    \n if(value.length() == 0 ) return 0; //tu zmiana..\n\n if (value.find(  std::string(\"NULL\") ) != std::string::npos) {\n     return 0;\n  }\n \n  if (value.find(  std::string(\"null\") ) != std::string::npos) {\n     return 0;\n  }\n \n \nint i;\nstd::stringstream stream1;\nstream1.clear();\nstream1.str(value);\nstream1 >> i;\nreturn i;\n int stringToInt(std::string value) {    \n if(value.length() == 0 ) return 0; //tu zmiana..\n\n if (value.find(  std::string(\"NULL\") ) != std::string::npos) {\n     return 0;\n  }\n \n  if (value.find(  std::string(\"null\") ) != std::string::npos) {\n     return 0;\n  }\n \n \nint i;\nstd::stringstream stream1;\nstream1.clear();\nstream1.str(value);\nstream1 >> i;\nreturn i;\n};",
                "there is another easy way : suppose you have a character like c='4' therefore you can do one of these steps :c='4'1st : int q q=(int) c ; (q is now 52 in ascii table ) .\nq=q-48; remember that adding 48 to digits is their ascii code .q=(int) c ; (q is now 52 in ascii table ) .\nq=q-48; remember that adding 48 to digits is their ascii code .the second way : q=c-'0'; the same , character '0' means 48q=c-'0'; the same , character '0' means 48",
                "One line version: long n = strtol(s.c_str(), NULL, base); . long n = strtol(s.c_str(), NULL, base);(s is the string, and base is an int such as 2, 8, 10, 16.)sbaseintYou can refer to this link for more details of strtol.this linkstrtolThe core idea is to use strtol function, which is included in cstdlib.strtolstrtolcstdlibSince strtol only handles with char array, we need to convert string to char array. You can refer to this link.strtolcharstringcharthis linkAn example:#include <iostream>\n#include <string>   // string type\n#include <bitset>   // bitset type used in the output\n\nint main(){\n    s = \"1111000001011010\";\n    long t = strtol(s.c_str(), NULL, 2); // 2 is the base which parse the string\n\n    cout << s << endl;\n    cout << t << endl;\n    cout << hex << t << endl;\n    cout << bitset<16> (t) << endl;\n\n    return 0;\n}\n#include <iostream>\n#include <string>   // string type\n#include <bitset>   // bitset type used in the output\n\nint main(){\n    s = \"1111000001011010\";\n    long t = strtol(s.c_str(), NULL, 2); // 2 is the base which parse the string\n\n    cout << s << endl;\n    cout << t << endl;\n    cout << hex << t << endl;\n    cout << bitset<16> (t) << endl;\n\n    return 0;\n}\nwhich will output:1111000001011010\n61530\nf05a\n1111000001011010\n1111000001011010\n61530\nf05a\n1111000001011010\n",
                "I think that converting from int to std::string or vice versa needs some special functions like std::stoi()\nbut if you need to convert a double into a string use to_string() (NOT C#. C# is .ToString() not to_string())intstd::stringstd::stoi()doublestringto_string()",
                "If you wot hard code :)If you wot hard code :)bool strCanBeInt(std::string string){\n    for (char n : string) {\n        if (n != '0' && n != '1' && n != '2' && n != '3' && n != '4' && n != '5'\n            && n != '6' && n != '7' && n != '8' && n != '9') {\n            return false;\n        }\n    }\n    return true;\n}\n\nint strToInt(std::string string) {\n    int integer = 0;\n    int numInt;\n    for (char n : string) {\n        if(n == '0') numInt = 0;\n        if(n == '1') numInt = 1;\n        if(n == '2') numInt = 2;\n        if(n == '3') numInt = 3;\n        if(n == '4') numInt = 4;\n        if(n == '5') numInt = 5;\n        if(n == '6') numInt = 6;\n        if(n == '7') numInt = 7;\n        if(n == '8') numInt = 8;\n        if(n == '9') numInt = 9;\n        if (integer){\n            integer *= 10;\n        }\n        integer += numInt;\n    }\n    return integer;\n}\nbool strCanBeInt(std::string string){\n    for (char n : string) {\n        if (n != '0' && n != '1' && n != '2' && n != '3' && n != '4' && n != '5'\n            && n != '6' && n != '7' && n != '8' && n != '9') {\n            return false;\n        }\n    }\n    return true;\n}\n\nint strToInt(std::string string) {\n    int integer = 0;\n    int numInt;\n    for (char n : string) {\n        if(n == '0') numInt = 0;\n        if(n == '1') numInt = 1;\n        if(n == '2') numInt = 2;\n        if(n == '3') numInt = 3;\n        if(n == '4') numInt = 4;\n        if(n == '5') numInt = 5;\n        if(n == '6') numInt = 6;\n        if(n == '7') numInt = 7;\n        if(n == '8') numInt = 8;\n        if(n == '9') numInt = 9;\n        if (integer){\n            integer *= 10;\n        }\n        integer += numInt;\n    }\n    return integer;\n}\n"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "How can I check if a string represents an int, without using try/except?",
                "is it possible to see if a string of string is an int without trying?",
                "how do i know whether a string represents an int without tryexcept?",
                "how do i check if a string is an int without using tryexcept?",
                "how do i check if a string represents an int without tryexcept?",
                "how do i know if a string represents an int without using tryexcept?",
                "how can you check if a string represents an int without using tryexcept?"
            ],
            "responses": [
                "with positive integers you could use .isdigit:.isdigit.isdigit>>> '16'.isdigit()\nTrue\n>>> '16'.isdigit()\nTrue\nit doesn't work with negative integers though. suppose you could try the following:>>> s = '-17'\n>>> s.startswith('-') and s[1:].isdigit()\nTrue\n>>> s = '-17'\n>>> s.startswith('-') and s[1:].isdigit()\nTrue\nit won't work with '16.0' format, which is similar to int casting in this sense.'16.0'intedit:editdef check_int(s):\n    if s[0] in ('-', '+'):\n        return s[1:].isdigit()\n    return s.isdigit()\ndef check_int(s):\n    if s[0] in ('-', '+'):\n        return s[1:].isdigit()\n    return s.isdigit()\n",
                "If you're really just annoyed at using try/excepts all over the place, please just write a helper function:try/exceptdef RepresentsInt(s):\n    try: \n        int(s)\n        return True\n    except ValueError:\n        return False\n\n>>> print RepresentsInt(\"+123\")\nTrue\n>>> print RepresentsInt(\"10.0\")\nFalse\ndef RepresentsInt(s):\n    try: \n        int(s)\n        return True\n    except ValueError:\n        return False\n\n>>> print RepresentsInt(\"+123\")\nTrue\n>>> print RepresentsInt(\"10.0\")\nFalse\nIt's going to be WAY more code to exactly cover all the strings that Python considers integers.  I say just be pythonic on this one.",
                "You know, I've found (and I've tested this over and over) that try/except does not perform all that well, for whatever reason.  I frequently try several ways of doing things, and I don't think I've ever found a method that uses try/except to perform the best of those tested, in fact it seems to me those methods have usually come out close to the worst, if not the worst.  Not in every case, but in many cases.  I know a lot of people say it's the \"Pythonic\" way, but that's one area where I part ways with them.  To me, it's neither very performant nor very elegant, so, I tend to only use it for error trapping and reporting.I was going to gripe that PHP, perl, ruby, C, and even the freaking shell have simple functions for testing a string for integer-hood, but due diligence in verifying those assumptions tripped me up!  Apparently this lack is a common sickness.Here's a quick and dirty edit of Bruno's post:import sys, time, re\n\ng_intRegex = re.compile(r\"^([+-]?[1-9]\\d*|0)$\")\n\ntestvals = [\n    # integers\n    0, 1, -1, 1.0, -1.0,\n    '0', '0.','0.0', '1', '-1', '+1', '1.0', '-1.0', '+1.0', '06',\n    # non-integers\n    'abc 123',\n    1.1, -1.1, '1.1', '-1.1', '+1.1',\n    '1.1.1', '1.1.0', '1.0.1', '1.0.0',\n    '1.0.', '1..0', '1..',\n    '0.0.', '0..0', '0..',\n    'one', object(), (1,2,3), [1,2,3], {'one':'two'},\n    # with spaces\n    ' 0 ', ' 0.', ' .0','.01 '\n]\n\ndef isInt_try(v):\n    try:     i = int(v)\n    except:  return False\n    return True\n\ndef isInt_str(v):\n    v = str(v).strip()\n    return v=='0' or (v if v.find('..') > -1 else v.lstrip('-+').rstrip('0').rstrip('.')).isdigit()\n\ndef isInt_re(v):\n    import re\n    if not hasattr(isInt_re, 'intRegex'):\n        isInt_re.intRegex = re.compile(r\"^([+-]?[1-9]\\d*|0)$\")\n    return isInt_re.intRegex.match(str(v).strip()) is not None\n\ndef isInt_re2(v):\n    return g_intRegex.match(str(v).strip()) is not None\n\ndef check_int(s):\n    s = str(s)\n    if s[0] in ('-', '+'):\n        return s[1:].isdigit()\n    return s.isdigit()    \n\n\ndef timeFunc(func, times):\n    t1 = time.time()\n    for n in range(times):\n        for v in testvals: \n            r = func(v)\n    t2 = time.time()\n    return t2 - t1\n\ndef testFuncs(funcs):\n    for func in funcs:\n        sys.stdout.write( \"\\t%s\\t|\" % func.__name__)\n    print()\n    for v in testvals:\n        if type(v) == type(''):\n            sys.stdout.write(\"'%s'\" % v)\n        else:\n            sys.stdout.write(\"%s\" % str(v))\n        for func in funcs:\n            sys.stdout.write( \"\\t\\t%s\\t|\" % func(v))\n        sys.stdout.write(\"\\r\\n\") \n\nif __name__ == '__main__':\n    print()\n    print(\"tests..\")\n    testFuncs((isInt_try, isInt_str, isInt_re, isInt_re2, check_int))\n    print()\n\n    print(\"timings..\")\n    print(\"isInt_try:   %6.4f\" % timeFunc(isInt_try, 10000))\n    print(\"isInt_str:   %6.4f\" % timeFunc(isInt_str, 10000)) \n    print(\"isInt_re:    %6.4f\" % timeFunc(isInt_re, 10000))\n    print(\"isInt_re2:   %6.4f\" % timeFunc(isInt_re2, 10000))\n    print(\"check_int:   %6.4f\" % timeFunc(check_int, 10000))\nimport sys, time, re\n\ng_intRegex = re.compile(r\"^([+-]?[1-9]\\d*|0)$\")\n\ntestvals = [\n    # integers\n    0, 1, -1, 1.0, -1.0,\n    '0', '0.','0.0', '1', '-1', '+1', '1.0', '-1.0', '+1.0', '06',\n    # non-integers\n    'abc 123',\n    1.1, -1.1, '1.1', '-1.1', '+1.1',\n    '1.1.1', '1.1.0', '1.0.1', '1.0.0',\n    '1.0.', '1..0', '1..',\n    '0.0.', '0..0', '0..',\n    'one', object(), (1,2,3), [1,2,3], {'one':'two'},\n    # with spaces\n    ' 0 ', ' 0.', ' .0','.01 '\n]\n\ndef isInt_try(v):\n    try:     i = int(v)\n    except:  return False\n    return True\n\ndef isInt_str(v):\n    v = str(v).strip()\n    return v=='0' or (v if v.find('..') > -1 else v.lstrip('-+').rstrip('0').rstrip('.')).isdigit()\n\ndef isInt_re(v):\n    import re\n    if not hasattr(isInt_re, 'intRegex'):\n        isInt_re.intRegex = re.compile(r\"^([+-]?[1-9]\\d*|0)$\")\n    return isInt_re.intRegex.match(str(v).strip()) is not None\n\ndef isInt_re2(v):\n    return g_intRegex.match(str(v).strip()) is not None\n\ndef check_int(s):\n    s = str(s)\n    if s[0] in ('-', '+'):\n        return s[1:].isdigit()\n    return s.isdigit()    \n\n\ndef timeFunc(func, times):\n    t1 = time.time()\n    for n in range(times):\n        for v in testvals: \n            r = func(v)\n    t2 = time.time()\n    return t2 - t1\n\ndef testFuncs(funcs):\n    for func in funcs:\n        sys.stdout.write( \"\\t%s\\t|\" % func.__name__)\n    print()\n    for v in testvals:\n        if type(v) == type(''):\n            sys.stdout.write(\"'%s'\" % v)\n        else:\n            sys.stdout.write(\"%s\" % str(v))\n        for func in funcs:\n            sys.stdout.write( \"\\t\\t%s\\t|\" % func(v))\n        sys.stdout.write(\"\\r\\n\") \n\nif __name__ == '__main__':\n    print()\n    print(\"tests..\")\n    testFuncs((isInt_try, isInt_str, isInt_re, isInt_re2, check_int))\n    print()\n\n    print(\"timings..\")\n    print(\"isInt_try:   %6.4f\" % timeFunc(isInt_try, 10000))\n    print(\"isInt_str:   %6.4f\" % timeFunc(isInt_str, 10000)) \n    print(\"isInt_re:    %6.4f\" % timeFunc(isInt_re, 10000))\n    print(\"isInt_re2:   %6.4f\" % timeFunc(isInt_re2, 10000))\n    print(\"check_int:   %6.4f\" % timeFunc(check_int, 10000))\nHere are the performance comparison results:timings..\nisInt_try:   0.6426\nisInt_str:   0.7382\nisInt_re:    1.1156\nisInt_re2:   0.5344\ncheck_int:   0.3452\ntimings..\nisInt_try:   0.6426\nisInt_str:   0.7382\nisInt_re:    1.1156\nisInt_re2:   0.5344\ncheck_int:   0.3452\nA C method could scan it Once Through, and be done.  A C method that scans the string once through would be the Right Thing to do, I think.EDIT:I've updated the code above to work in Python 3.5, and to include the check_int function from the currently most voted up answer, and to use the current most popular regex that I can find for testing for integer-hood. This regex rejects strings like 'abc 123'. I've added 'abc 123' as a test value.It is Very Interesting to me to note, at this point, that NONE of the functions tested, including the try method, the popular check_int function, and the most popular regex for testing for integer-hood, return the correct answers for all of the test values (well, depending on what you think the correct answers are; see the test results below).The built-in int() function silently truncates the fractional part of a floating point number and returns the integer part before the decimal, unless the floating point number is first converted to a string.The check_int() function returns false for values like 0.0 and 1.0 (which technically are integers) and returns true for values like '06'.Here are the current (Python 3.5) test results:              isInt_try |       isInt_str       |       isInt_re        |       isInt_re2       |   check_int   |\n0               True    |               True    |               True    |               True    |       True    |\n1               True    |               True    |               True    |               True    |       True    |\n-1              True    |               True    |               True    |               True    |       True    |\n1.0             True    |               True    |               False   |               False   |       False   |\n-1.0            True    |               True    |               False   |               False   |       False   |\n'0'             True    |               True    |               True    |               True    |       True    |\n'0.'            False   |               True    |               False   |               False   |       False   |\n'0.0'           False   |               True    |               False   |               False   |       False   |\n'1'             True    |               True    |               True    |               True    |       True    |\n'-1'            True    |               True    |               True    |               True    |       True    |\n'+1'            True    |               True    |               True    |               True    |       True    |\n'1.0'           False   |               True    |               False   |               False   |       False   |\n'-1.0'          False   |               True    |               False   |               False   |       False   |\n'+1.0'          False   |               True    |               False   |               False   |       False   |\n'06'            True    |               True    |               False   |               False   |       True    |\n'abc 123'       False   |               False   |               False   |               False   |       False   |\n1.1             True    |               False   |               False   |               False   |       False   |\n-1.1            True    |               False   |               False   |               False   |       False   |\n'1.1'           False   |               False   |               False   |               False   |       False   |\n'-1.1'          False   |               False   |               False   |               False   |       False   |\n'+1.1'          False   |               False   |               False   |               False   |       False   |\n'1.1.1'         False   |               False   |               False   |               False   |       False   |\n'1.1.0'         False   |               False   |               False   |               False   |       False   |\n'1.0.1'         False   |               False   |               False   |               False   |       False   |\n'1.0.0'         False   |               False   |               False   |               False   |       False   |\n'1.0.'          False   |               False   |               False   |               False   |       False   |\n'1..0'          False   |               False   |               False   |               False   |       False   |\n'1..'           False   |               False   |               False   |               False   |       False   |\n'0.0.'          False   |               False   |               False   |               False   |       False   |\n'0..0'          False   |               False   |               False   |               False   |       False   |\n'0..'           False   |               False   |               False   |               False   |       False   |\n'one'           False   |               False   |               False   |               False   |       False   |\n<obj..>         False   |               False   |               False   |               False   |       False   |\n(1, 2, 3)       False   |               False   |               False   |               False   |       False   |\n[1, 2, 3]       False   |               False   |               False   |               False   |       False   |\n{'one': 'two'}  False   |               False   |               False   |               False   |       False   |\n' 0 '           True    |               True    |               True    |               True    |       False   |\n' 0.'           False   |               True    |               False   |               False   |       False   |\n' .0'           False   |               False   |               False   |               False   |       False   |\n'.01 '          False   |               False   |               False   |               False   |       False   |\n              isInt_try |       isInt_str       |       isInt_re        |       isInt_re2       |   check_int   |\n0               True    |               True    |               True    |               True    |       True    |\n1               True    |               True    |               True    |               True    |       True    |\n-1              True    |               True    |               True    |               True    |       True    |\n1.0             True    |               True    |               False   |               False   |       False   |\n-1.0            True    |               True    |               False   |               False   |       False   |\n'0'             True    |               True    |               True    |               True    |       True    |\n'0.'            False   |               True    |               False   |               False   |       False   |\n'0.0'           False   |               True    |               False   |               False   |       False   |\n'1'             True    |               True    |               True    |               True    |       True    |\n'-1'            True    |               True    |               True    |               True    |       True    |\n'+1'            True    |               True    |               True    |               True    |       True    |\n'1.0'           False   |               True    |               False   |               False   |       False   |\n'-1.0'          False   |               True    |               False   |               False   |       False   |\n'+1.0'          False   |               True    |               False   |               False   |       False   |\n'06'            True    |               True    |               False   |               False   |       True    |\n'abc 123'       False   |               False   |               False   |               False   |       False   |\n1.1             True    |               False   |               False   |               False   |       False   |\n-1.1            True    |               False   |               False   |               False   |       False   |\n'1.1'           False   |               False   |               False   |               False   |       False   |\n'-1.1'          False   |               False   |               False   |               False   |       False   |\n'+1.1'          False   |               False   |               False   |               False   |       False   |\n'1.1.1'         False   |               False   |               False   |               False   |       False   |\n'1.1.0'         False   |               False   |               False   |               False   |       False   |\n'1.0.1'         False   |               False   |               False   |               False   |       False   |\n'1.0.0'         False   |               False   |               False   |               False   |       False   |\n'1.0.'          False   |               False   |               False   |               False   |       False   |\n'1..0'          False   |               False   |               False   |               False   |       False   |\n'1..'           False   |               False   |               False   |               False   |       False   |\n'0.0.'          False   |               False   |               False   |               False   |       False   |\n'0..0'          False   |               False   |               False   |               False   |       False   |\n'0..'           False   |               False   |               False   |               False   |       False   |\n'one'           False   |               False   |               False   |               False   |       False   |\n<obj..>         False   |               False   |               False   |               False   |       False   |\n(1, 2, 3)       False   |               False   |               False   |               False   |       False   |\n[1, 2, 3]       False   |               False   |               False   |               False   |       False   |\n{'one': 'two'}  False   |               False   |               False   |               False   |       False   |\n' 0 '           True    |               True    |               True    |               True    |       False   |\n' 0.'           False   |               True    |               False   |               False   |       False   |\n' .0'           False   |               False   |               False   |               False   |       False   |\n'.01 '          False   |               False   |               False   |               False   |       False   |\nJust now I tried adding this function:def isInt_float(s):\n    try:\n        return float(str(s)).is_integer()\n    except:\n        return False\ndef isInt_float(s):\n    try:\n        return float(str(s)).is_integer()\n    except:\n        return False\nIt performs almost as well as check_int (0.3486) and it returns true for values like 1.0 and 0.0 and +1.0 and 0. and .0 and so on. But it also returns true for '06', so. Pick your poison, I guess.",
                "str.isdigit() should do the trick.str.isdigit()Examples:str.isdigit(\"23\") ## True\nstr.isdigit(\"abc\") ## False\nstr.isdigit(\"23.4\") ## False\nstr.isdigit(\"23\") ## True\nstr.isdigit(\"abc\") ## False\nstr.isdigit(\"23.4\") ## False\nEDIT:\nAs @BuzzMoschetti pointed out, this way will fail for minus number (e.g, \"-23\"). In case your input_num can be less than 0, use re.sub(regex_search,regex_replace,contents) before applying str.isdigit(). For example: EDITminus number\"-23\"input_numre.sub(regex_search,regex_replace,contents)str.isdigit()import re\ninput_num = \"-23\"\ninput_num = re.sub(\"^-\", \"\", input_num) ## \"^\" indicates to remove the first \"-\" only\nstr.isdigit(input_num) ## True\nimport re\ninput_num = \"-23\"\ninput_num = re.sub(\"^-\", \"\", input_num) ## \"^\" indicates to remove the first \"-\" only\nstr.isdigit(input_num) ## True\n",
                "Use a regular expression:import re\ndef RepresentsInt(s):\n    return re.match(r\"[-+]?\\d+$\", s) is not None\nimport re\ndef RepresentsInt(s):\n    return re.match(r\"[-+]?\\d+$\", s) is not None\nIf you must accept decimal fractions also:def RepresentsInt(s):\n    return re.match(r\"[-+]?\\d+(\\.0*)?$\", s) is not None\ndef RepresentsInt(s):\n    return re.match(r\"[-+]?\\d+(\\.0*)?$\", s) is not None\nFor improved performance if you're doing this often, compile the regular expression only once using re.compile().re.compile()",
                "The proper RegEx solution would combine the ideas of Greg Hewgill and Nowell, but not use a global variable. You can accomplish this by attaching an attribute to the method. Also, I know that it is frowned upon to put imports in a method, but what I'm going for is a \"lazy module\" effect like http://peak.telecommunity.com/DevCenter/Importing#lazy-importshttp://peak.telecommunity.com/DevCenter/Importing#lazy-importsedit: My favorite technique so far is to use exclusively methods of the String object.edit:#!/usr/bin/env python\n\n# Uses exclusively methods of the String object\ndef isInteger(i):\n    i = str(i)\n    return i=='0' or (i if i.find('..') > -1 else i.lstrip('-+').rstrip('0').rstrip('.')).isdigit()\n\n# Uses re module for regex\ndef isIntegre(i):\n    import re\n    if not hasattr(isIntegre, '_re'):\n        print(\"I compile only once. Remove this line when you are confident in that.\")\n        isIntegre._re = re.compile(r\"[-+]?\\d+(\\.0*)?$\")\n    return isIntegre._re.match(str(i)) is not None\n\n# When executed directly run Unit Tests\nif __name__ == '__main__':\n    for obj in [\n                # integers\n                0, 1, -1, 1.0, -1.0,\n                '0', '0.','0.0', '1', '-1', '+1', '1.0', '-1.0', '+1.0',\n                # non-integers\n                1.1, -1.1, '1.1', '-1.1', '+1.1',\n                '1.1.1', '1.1.0', '1.0.1', '1.0.0',\n                '1.0.', '1..0', '1..',\n                '0.0.', '0..0', '0..',\n                'one', object(), (1,2,3), [1,2,3], {'one':'two'}\n            ]:\n        # Notice the integre uses 're' (intended to be humorous)\n        integer = ('an integer' if isInteger(obj) else 'NOT an integer')\n        integre = ('an integre' if isIntegre(obj) else 'NOT an integre')\n        # Make strings look like strings in the output\n        if isinstance(obj, str):\n            obj = (\"'%s'\" % (obj,))\n        print(\"%30s is %14s is %14s\" % (obj, integer, integre))\n#!/usr/bin/env python\n\n# Uses exclusively methods of the String object\ndef isInteger(i):\n    i = str(i)\n    return i=='0' or (i if i.find('..') > -1 else i.lstrip('-+').rstrip('0').rstrip('.')).isdigit()\n\n# Uses re module for regex\ndef isIntegre(i):\n    import re\n    if not hasattr(isIntegre, '_re'):\n        print(\"I compile only once. Remove this line when you are confident in that.\")\n        isIntegre._re = re.compile(r\"[-+]?\\d+(\\.0*)?$\")\n    return isIntegre._re.match(str(i)) is not None\n\n# When executed directly run Unit Tests\nif __name__ == '__main__':\n    for obj in [\n                # integers\n                0, 1, -1, 1.0, -1.0,\n                '0', '0.','0.0', '1', '-1', '+1', '1.0', '-1.0', '+1.0',\n                # non-integers\n                1.1, -1.1, '1.1', '-1.1', '+1.1',\n                '1.1.1', '1.1.0', '1.0.1', '1.0.0',\n                '1.0.', '1..0', '1..',\n                '0.0.', '0..0', '0..',\n                'one', object(), (1,2,3), [1,2,3], {'one':'two'}\n            ]:\n        # Notice the integre uses 're' (intended to be humorous)\n        integer = ('an integer' if isInteger(obj) else 'NOT an integer')\n        integre = ('an integre' if isIntegre(obj) else 'NOT an integre')\n        # Make strings look like strings in the output\n        if isinstance(obj, str):\n            obj = (\"'%s'\" % (obj,))\n        print(\"%30s is %14s is %14s\" % (obj, integer, integre))\nAnd for the less adventurous members of the class, here is the output:I compile only once. Remove this line when you are confident in that.\n                             0 is     an integer is     an integre\n                             1 is     an integer is     an integre\n                            -1 is     an integer is     an integre\n                           1.0 is     an integer is     an integre\n                          -1.0 is     an integer is     an integre\n                           '0' is     an integer is     an integre\n                          '0.' is     an integer is     an integre\n                         '0.0' is     an integer is     an integre\n                           '1' is     an integer is     an integre\n                          '-1' is     an integer is     an integre\n                          '+1' is     an integer is     an integre\n                         '1.0' is     an integer is     an integre\n                        '-1.0' is     an integer is     an integre\n                        '+1.0' is     an integer is     an integre\n                           1.1 is NOT an integer is NOT an integre\n                          -1.1 is NOT an integer is NOT an integre\n                         '1.1' is NOT an integer is NOT an integre\n                        '-1.1' is NOT an integer is NOT an integre\n                        '+1.1' is NOT an integer is NOT an integre\n                       '1.1.1' is NOT an integer is NOT an integre\n                       '1.1.0' is NOT an integer is NOT an integre\n                       '1.0.1' is NOT an integer is NOT an integre\n                       '1.0.0' is NOT an integer is NOT an integre\n                        '1.0.' is NOT an integer is NOT an integre\n                        '1..0' is NOT an integer is NOT an integre\n                         '1..' is NOT an integer is NOT an integre\n                        '0.0.' is NOT an integer is NOT an integre\n                        '0..0' is NOT an integer is NOT an integre\n                         '0..' is NOT an integer is NOT an integre\n                         'one' is NOT an integer is NOT an integre\n<object object at 0x103b7d0a0> is NOT an integer is NOT an integre\n                     (1, 2, 3) is NOT an integer is NOT an integre\n                     [1, 2, 3] is NOT an integer is NOT an integre\n                {'one': 'two'} is NOT an integer is NOT an integre\nI compile only once. Remove this line when you are confident in that.\n                             0 is     an integer is     an integre\n                             1 is     an integer is     an integre\n                            -1 is     an integer is     an integre\n                           1.0 is     an integer is     an integre\n                          -1.0 is     an integer is     an integre\n                           '0' is     an integer is     an integre\n                          '0.' is     an integer is     an integre\n                         '0.0' is     an integer is     an integre\n                           '1' is     an integer is     an integre\n                          '-1' is     an integer is     an integre\n                          '+1' is     an integer is     an integre\n                         '1.0' is     an integer is     an integre\n                        '-1.0' is     an integer is     an integre\n                        '+1.0' is     an integer is     an integre\n                           1.1 is NOT an integer is NOT an integre\n                          -1.1 is NOT an integer is NOT an integre\n                         '1.1' is NOT an integer is NOT an integre\n                        '-1.1' is NOT an integer is NOT an integre\n                        '+1.1' is NOT an integer is NOT an integre\n                       '1.1.1' is NOT an integer is NOT an integre\n                       '1.1.0' is NOT an integer is NOT an integre\n                       '1.0.1' is NOT an integer is NOT an integre\n                       '1.0.0' is NOT an integer is NOT an integre\n                        '1.0.' is NOT an integer is NOT an integre\n                        '1..0' is NOT an integer is NOT an integre\n                         '1..' is NOT an integer is NOT an integre\n                        '0.0.' is NOT an integer is NOT an integre\n                        '0..0' is NOT an integer is NOT an integre\n                         '0..' is NOT an integer is NOT an integre\n                         'one' is NOT an integer is NOT an integre\n<object object at 0x103b7d0a0> is NOT an integer is NOT an integre\n                     (1, 2, 3) is NOT an integer is NOT an integre\n                     [1, 2, 3] is NOT an integer is NOT an integre\n                {'one': 'two'} is NOT an integer is NOT an integre\n",
                ">>> \"+7\".lstrip(\"-+\").isdigit()\nTrue\n>>> \"-7\".lstrip(\"-+\").isdigit()\nTrue\n>>> \"7\".lstrip(\"-+\").isdigit()\nTrue\n>>> \"13.4\".lstrip(\"-+\").isdigit()\nFalse\n>>> \"+7\".lstrip(\"-+\").isdigit()\nTrue\n>>> \"-7\".lstrip(\"-+\").isdigit()\nTrue\n>>> \"7\".lstrip(\"-+\").isdigit()\nTrue\n>>> \"13.4\".lstrip(\"-+\").isdigit()\nFalse\nSo your function would be:def is_int(val):\n   return val.lstrip(\"-+\").isdigit()\ndef is_int(val):\n   return val.lstrip(\"-+\").isdigit()\n",
                "I do this all the time b/c I have a mild but admittedly irrational aversion to using the try/except pattern. I use this:all([xi in '1234567890' for xi in x])\nall([xi in '1234567890' for xi in x])\nIt doesn't accommodate negative numbers, so you could strip out all minus signs on the left side, and then check if the result comprises digits from 0-9:all([xi in '1234567890' for xi in x.lstrip('-')])\nall([xi in '1234567890' for xi in x.lstrip('-')])\nYou could also pass x to str() if you're not sure the input is a string:all([xi in '1234567890' for xi in str(x).lstrip('-')])\nall([xi in '1234567890' for xi in str(x).lstrip('-')])\nThere are some (edge?) cases where this falls apart:\nIt doesn't work for various scientific and/or exponential notations (e.g. 1.2E3, 10^3, etc.) - both will return False. I don't think other answers accommodated this either, and even Python 3.8 has inconsistent opinions, since type(1E2) gives <class 'float'> whereas type(10^2) gives <class 'int'>.\nAn empty string input gives True.\nA leading plus sign (e.g. \"+7\") gives False.\nMultiple minus signs are ignored so long as they're leading characters. This behavior is similar to the python interpreter* in that type(---1) returns <class int>. However, it isn't completely consistent with the interpreter in that int('---1') gives an error, but my solution returns True with the same input.\nIt doesn't work for various scientific and/or exponential notations (e.g. 1.2E3, 10^3, etc.) - both will return False. I don't think other answers accommodated this either, and even Python 3.8 has inconsistent opinions, since type(1E2) gives <class 'float'> whereas type(10^2) gives <class 'int'>.type(1E2)<class 'float'>type(10^2)<class 'int'>An empty string input gives True.A leading plus sign (e.g. \"+7\") gives False.Multiple minus signs are ignored so long as they're leading characters. This behavior is similar to the python interpreter* in that type(---1) returns <class int>. However, it isn't completely consistent with the interpreter in that int('---1') gives an error, but my solution returns True with the same input.type(---1)<class int>int('---1')TrueSo it won't work for every possible input, but if you can exclude those, it's an OK one-line check that returns False if x is not an integer and True if x is an integer. But if you really want behavior that exactly models the int() built-in, you're better off using try/except.everyFalseTrueexactlyint()I don't know if it's pythonic, but it's one line, and it's relatively clear what the code does.*I don't mean to say that the interpreter ignores leading minus signs, just that any number of leading minus signs does not change that the result is an integer. int(--1) is actually interpreted as -(-1), or 1. int(---1) is interpreted as -(-(-1)), or -1. So an even number of leading minus signs gives a positive integer, and an odd number of minus signs gives a negative integer, but the result is always an integer.int(--1)-(-1)int(---1)-(-(-1))",
                "Greg Hewgill's approach was missing a few components: the leading \"^\" to only match the start of the string, and compiling the re beforehand. But this approach will allow you to avoid a try: exept:import re\nINT_RE = re.compile(r\"^[-]?\\d+$\")\ndef RepresentsInt(s):\n    return INT_RE.match(str(s)) is not None\nimport re\nINT_RE = re.compile(r\"^[-]?\\d+$\")\ndef RepresentsInt(s):\n    return INT_RE.match(str(s)) is not None\nI would be interested why you are trying to avoid try: except?",
                "I thinks.startswith('-') and s[1:].isdigit()\ns.startswith('-') and s[1:].isdigit()\nwould be better to rewrite to:s.replace('-', '').isdigit()\ns.replace('-', '').isdigit()\nbecause s[1:] also creates a new stringBut much better solution iss.lstrip('+-').isdigit()\ns.lstrip('+-').isdigit()\n",
                "The easiest way, which I usedef is_int(item: str) -> bool:\n    return item.lstrip('-+').isdigit()\ndef is_int(item: str) -> bool:\n    return item.lstrip('-+').isdigit()\n",
                "Can use the below method to check.def check_if_string_is_int(string1):\n    for character in string1:\n        if not character.isdigit():\n            return \"Not a number\"\n    else:\n        return \"Is a number\"\ndef check_if_string_is_int(string1):\n    for character in string1:\n        if not character.isdigit():\n            return \"Not a number\"\n    else:\n        return \"Is a number\"\n",
                "I really liked Shavais' post, but I added one more test case ( & the built in isdigit() function):def isInt_loop(v):\n    v = str(v).strip()\n    # swapping '0123456789' for '9876543210' makes nominal difference (might have because '1' is toward the beginning of the string)\n    numbers = '0123456789'\n    for i in v:\n        if i not in numbers:\n            return False\n    return True\n\ndef isInt_Digit(v):\n    v = str(v).strip()\n    return v.isdigit()\ndef isInt_loop(v):\n    v = str(v).strip()\n    # swapping '0123456789' for '9876543210' makes nominal difference (might have because '1' is toward the beginning of the string)\n    numbers = '0123456789'\n    for i in v:\n        if i not in numbers:\n            return False\n    return True\n\ndef isInt_Digit(v):\n    v = str(v).strip()\n    return v.isdigit()\nand it significantly consistently beats the times of the rest:timings..\nisInt_try:   0.4628\nisInt_str:   0.3556\nisInt_re:    0.4889\nisInt_re2:   0.2726\nisInt_loop:   0.1842\nisInt_Digit:   0.1577\ntimings..\nisInt_try:   0.4628\nisInt_str:   0.3556\nisInt_re:    0.4889\nisInt_re2:   0.2726\nisInt_loop:   0.1842\nisInt_Digit:   0.1577\nusing normal 2.7 python:$ python --version\nPython 2.7.10\n$ python --version\nPython 2.7.10\nBoth the two test cases I added (isInt_loop and isInt_digit) pass the exact same test cases (they both only accept unsigned integers), but I thought that people could be more clever with modifying the string implementation (isInt_loop) opposed to the built in isdigit() function, so I included it, even though there's a slight difference in execution time. (and both methods beat everything else by a lot, but don't handle the extra stuff: \"./+/-\"   )Also, I did find it interesting to note that the regex (isInt_re2 method) beat the string comparison in the same test that was performed by Shavais in 2012 (currently 2018). Maybe the regex libraries have been improved?",
                "This is probably the most straightforward and pythonic way to approach it in my opinion. I didn't see this solution and it's basically the same as the regex one, but without the regex. def is_int(test):\n    import string\n    return not (set(test) - set(string.digits))\ndef is_int(test):\n    import string\n    return not (set(test) - set(string.digits))\n",
                "Here is a function that parses without raising errors. It handles obvious cases returns None on failure (handles up to 2000 '-/+' signs by default on CPython!):None#!/usr/bin/env python\n\ndef get_int(number):\n    splits = number.split('.')\n    if len(splits) > 2:\n        # too many splits\n        return None\n    if len(splits) == 2 and splits[1]:\n        # handle decimal part recursively :-)\n        if get_int(splits[1]) != 0:\n            return None\n\n    int_part = splits[0].lstrip(\"+\")\n    if int_part.startswith('-'):\n        # handle minus sign recursively :-)\n        return get_int(int_part[1:]) * -1\n    # successful 'and' returns last truth-y value (cast is always valid)\n    return int_part.isdigit() and int(int_part)\n#!/usr/bin/env python\n\ndef get_int(number):\n    splits = number.split('.')\n    if len(splits) > 2:\n        # too many splits\n        return None\n    if len(splits) == 2 and splits[1]:\n        # handle decimal part recursively :-)\n        if get_int(splits[1]) != 0:\n            return None\n\n    int_part = splits[0].lstrip(\"+\")\n    if int_part.startswith('-'):\n        # handle minus sign recursively :-)\n        return get_int(int_part[1:]) * -1\n    # successful 'and' returns last truth-y value (cast is always valid)\n    return int_part.isdigit() and int(int_part)\nSome tests:tests = [\"0\", \"0.0\", \"0.1\", \"1\", \"1.1\", \"1.0\", \"-1\", \"-1.1\", \"-1.0\", \"-0\", \"--0\", \"---3\", '.3', '--3.', \"+13\", \"+-1.00\", \"--+123\", \"-0.000\"]\n\nfor t in tests:\n    print \"get_int(%s) = %s\" % (t, get_int(str(t)))\ntests = [\"0\", \"0.0\", \"0.1\", \"1\", \"1.1\", \"1.0\", \"-1\", \"-1.1\", \"-1.0\", \"-0\", \"--0\", \"---3\", '.3', '--3.', \"+13\", \"+-1.00\", \"--+123\", \"-0.000\"]\n\nfor t in tests:\n    print \"get_int(%s) = %s\" % (t, get_int(str(t)))\nResults:get_int(0) = 0\nget_int(0.0) = 0\nget_int(0.1) = None\nget_int(1) = 1\nget_int(1.1) = None\nget_int(1.0) = 1\nget_int(-1) = -1\nget_int(-1.1) = None\nget_int(-1.0) = -1\nget_int(-0) = 0\nget_int(--0) = 0\nget_int(---3) = -3\nget_int(.3) = None\nget_int(--3.) = 3\nget_int(+13) = 13\nget_int(+-1.00) = -1\nget_int(--+123) = 123\nget_int(-0.000) = 0\nget_int(0) = 0\nget_int(0.0) = 0\nget_int(0.1) = None\nget_int(1) = 1\nget_int(1.1) = None\nget_int(1.0) = 1\nget_int(-1) = -1\nget_int(-1.1) = None\nget_int(-1.0) = -1\nget_int(-0) = 0\nget_int(--0) = 0\nget_int(---3) = -3\nget_int(.3) = None\nget_int(--3.) = 3\nget_int(+13) = 13\nget_int(+-1.00) = -1\nget_int(--+123) = 123\nget_int(-0.000) = 0\nFor your needs you can use:def int_predicate(number):\n     return get_int(number) is not None\ndef int_predicate(number):\n     return get_int(number) is not None\n",
                "If you want to accept lower-ascii digits only, here are tests to do so:Python 3.7+: (u.isdecimal() and u.isascii())Python 3.7+: (u.isdecimal() and u.isascii())(u.isdecimal() and u.isascii())Python <= 3.6: (u.isdecimal() and u == str(int(u)))Python <= 3.6: (u.isdecimal() and u == str(int(u)))(u.isdecimal() and u == str(int(u)))Other answers suggest using .isdigit() or .isdecimal() but these both include some upper-unicode characters such as '\u0662' (u'\\u0662'):.isdigit().isdecimal()both include some upper-unicode characters'\u0662'u'\\u0662'u = u'\\u0662'     # '\u0662'\nu.isdigit()       # True\nu.isdecimal()     # True\nu.isascii()       # False (Python 3.7+ only)\nu == str(int(u))  # False\nu = u'\\u0662'     # '\u0662'\nu.isdigit()       # True\nu.isdecimal()     # True\nu.isascii()       # False (Python 3.7+ only)\nu == str(int(u))  # False\n",
                "Preconditions:\nwe are talking about integers (not decimals/floats);\nbehavior of built-in int() is a standard for us (sometimes it's strange: \"-00\" is correct input for it)\nwe are talking about integers (not decimals/floats);behavior of built-in int() is a standard for us (sometimes it's strange: \"-00\" is correct input for it)int()Short answer:Short answer:Use the following code. It is simple, correct (while many variants in this thread aren't) and nearly twice outperforms both try/except and regex variants.simplecorrecttwice outperformstry/exceptregexdef is_int_str(string):\n    return (\n        string.startswith(('-', '+')) and string[1:].isdigit()\n    ) or string.isdigit()\ndef is_int_str(string):\n    return (\n        string.startswith(('-', '+')) and string[1:].isdigit()\n    ) or string.isdigit()\nTL;DR answer:I've tested 3 main variants (1) try/except, (2) re.match() and (3) string operations (see above). The third variant is about twice faster then both try/except and re.match(). BTW: regex variant is the slowest! See test script below.try/exceptre.match()import re\nimport time\n\n\ndef test(func, test_suite):\n    for test_case in test_suite:\n        actual_result = func(*test_case[0])\n        expected_result = test_case[1]\n        assert (\n            actual_result == expected_result\n        ), f'Expected: {expected_result} but actual: {actual_result}'\n\n\ndef perf(func, test_suite):\n    start = time.time()\n\n    for _ in range(0, 1_000_000):\n        test(func, test_suite)\n\n    return time.time() - start\n\n\ndef is_int_str_1(string):\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False\n\n\ndef is_int_str_2(string):\n    return re.match(r'^[\\-+]?\\d+$', string) is not None\n\n\ndef is_int_str_3(string):\n    return (\n        string.startswith(('-', '+')) and string[1:].isdigit()\n    ) or string.isdigit()\n\n\n# Behavior of built-in int() function is a standard for the following tests\ntest_suite = [\n    [['1'], True],  # func('1') -> True\n    [['-1'], True],\n    [['+1'], True],\n    [['--1'], False],\n    [['++1'], False],\n    [['001'], True],  # because int() can read it\n    [['-00'], True],  # because of quite strange behavior of int()\n    [['-'], False],\n    [['abracadabra'], False],\n    [['57938759283475928347592347598357098458405834957984755200000000'], True],\n]\n\ntime_span_1 = perf(is_int_str_1, test_suite)\ntime_span_2 = perf(is_int_str_2, test_suite)\ntime_span_3 = perf(is_int_str_3, test_suite)\n\nprint(f'{is_int_str_1.__name__}: {time_span_1} seconds')\nprint(f'{is_int_str_2.__name__}: {time_span_2} seconds')\nprint(f'{is_int_str_3.__name__}: {time_span_3} seconds')\n\nimport re\nimport time\n\n\ndef test(func, test_suite):\n    for test_case in test_suite:\n        actual_result = func(*test_case[0])\n        expected_result = test_case[1]\n        assert (\n            actual_result == expected_result\n        ), f'Expected: {expected_result} but actual: {actual_result}'\n\n\ndef perf(func, test_suite):\n    start = time.time()\n\n    for _ in range(0, 1_000_000):\n        test(func, test_suite)\n\n    return time.time() - start\n\n\ndef is_int_str_1(string):\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False\n\n\ndef is_int_str_2(string):\n    return re.match(r'^[\\-+]?\\d+$', string) is not None\n\n\ndef is_int_str_3(string):\n    return (\n        string.startswith(('-', '+')) and string[1:].isdigit()\n    ) or string.isdigit()\n\n\n# Behavior of built-in int() function is a standard for the following tests\ntest_suite = [\n    [['1'], True],  # func('1') -> True\n    [['-1'], True],\n    [['+1'], True],\n    [['--1'], False],\n    [['++1'], False],\n    [['001'], True],  # because int() can read it\n    [['-00'], True],  # because of quite strange behavior of int()\n    [['-'], False],\n    [['abracadabra'], False],\n    [['57938759283475928347592347598357098458405834957984755200000000'], True],\n]\n\ntime_span_1 = perf(is_int_str_1, test_suite)\ntime_span_2 = perf(is_int_str_2, test_suite)\ntime_span_3 = perf(is_int_str_3, test_suite)\n\nprint(f'{is_int_str_1.__name__}: {time_span_1} seconds')\nprint(f'{is_int_str_2.__name__}: {time_span_2} seconds')\nprint(f'{is_int_str_3.__name__}: {time_span_3} seconds')\n\nOutput was:is_int_str_1: 4.314162969589233 seconds\nis_int_str_2: 5.7216269969940186 seconds\nis_int_str_3: 2.5828163623809814 seconds\nis_int_str_1: 4.314162969589233 seconds\nis_int_str_2: 5.7216269969940186 seconds\nis_int_str_3: 2.5828163623809814 seconds\n",
                "I have one possibility that doesn't use int at all, and should not raise an exception unless the string does not represent a numberfloat(number)==float(number)//1\nfloat(number)==float(number)//1\nIt should work for any kind of string that float accepts, positive, negative, engineering notation...",
                "I suggest the following:import ast\n\ndef is_int(s):\n    return isinstance(ast.literal_eval(s), int)\nimport ast\n\ndef is_int(s):\n    return isinstance(ast.literal_eval(s), int)\nFrom the docs:docs\nSafely evaluate an expression node or a string containing a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and None.\nSafely evaluate an expression node or a string containing a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and None.I should note that this will raise a ValueError exception when called against anything that does not constitute a Python literal. Since the question asked for a solution without try/except, I have a Kobayashi-Maru type solution for that:ValueErrorfrom ast import literal_eval\nfrom contextlib import suppress\n\ndef is_int(s):\n    with suppress(ValueError):\n        return isinstance(literal_eval(s), int)\n    return False\nfrom ast import literal_eval\nfrom contextlib import suppress\n\ndef is_int(s):\n    with suppress(ValueError):\n        return isinstance(literal_eval(s), int)\n    return False\n\u00af\\_(\u30c4)_/\u00af",
                "Cast value to string after checking is integer, then check string first character value is - or + and rest of string isdigit. Finally just check isdigit. \ntest = ['1', '12015', '1..2', 'a2kk78', '1.5', 2, 1.24, '-8.5', '+88751.71', '-1', '+7']-+isdigitisdigittest = ['1', '12015', '1..2', 'a2kk78', '1.5', 2, 1.24, '-8.5', '+88751.71', '-1', '+7']Checkfor k,v in enumerate(test): \n    print(k, v, 'test: ', True if isinstance(v, int) is not False else True if str(v)[0] in ['-', '+'] and str(v)[1:].isdigit() else str(v).isdigit())\nfor k,v in enumerate(test): \n    print(k, v, 'test: ', True if isinstance(v, int) is not False else True if str(v)[0] in ['-', '+'] and str(v)[1:].isdigit() else str(v).isdigit())\nResult0 1 test:  True\n1 12015 test:  True\n2 1..2 test:  False\n3 a2kk78 test:  False\n4 1.5 test:  False\n5 2 test:  True\n6 1.24 test:  False\n7 -8.5 test:  False\n8 +88751.71 test:  False\n9 -1 test:  True\n10 +7 test:  True\n0 1 test:  True\n1 12015 test:  True\n2 1..2 test:  False\n3 a2kk78 test:  False\n4 1.5 test:  False\n5 2 test:  True\n6 1.24 test:  False\n7 -8.5 test:  False\n8 +88751.71 test:  False\n9 -1 test:  True\n10 +7 test:  True\n",
                "As I understand you want to check string convertability in int. To do that you can:\nReplace '-' to nothing, cos '-' not digit and '-7' can also be converted in int.\nCheck is it digit.\nReplace '-' to nothing, cos '-' not digit and '-7' can also be converted in int.Check is it digit.\ndef is_string_convertable_to_int(value: str) -> bool:\n    return value.replace('-', '').isdigit()\ndef is_string_convertable_to_int(value: str) -> bool:\n    return value.replace('-', '').isdigit()\nP.S. You can easy modify this def for checking string convertability in float, just add replace('.', '') and check one '.' existance using value.count('.') = 1.",
                "I guess the question is related with speed since the try/except has a time penalty:\u00a0test dataFirst, I created a list of 200 strings, 100 failing strings and 100 numeric strings.from random import shuffle\nnumbers = [u'+1'] * 100\nnonumbers = [u'1abc'] * 100\ntestlist = numbers + nonumbers\nshuffle(testlist)\ntestlist = np.array(testlist)\nfrom random import shuffle\nnumbers = [u'+1'] * 100\nnonumbers = [u'1abc'] * 100\ntestlist = numbers + nonumbers\nshuffle(testlist)\ntestlist = np.array(testlist)\n\u00a0numpy solution (only works with arrays and unicode)np.core.defchararray.isnumeric can also work with unicode strings np.core.defchararray.isnumeric(u'+12') but it returns and array. So, it's a good solution if you have to do thousands of conversions and have missing data or non numeric data.np.core.defchararray.isnumeric(u'+12')import numpy as np\n%timeit np.core.defchararray.isnumeric(testlist)\n10000 loops, best of 3: 27.9 \u00b5s per loop # 200 numbers per loop\nimport numpy as np\n%timeit np.core.defchararray.isnumeric(testlist)\n10000 loops, best of 3: 27.9 \u00b5s per loop # 200 numbers per loop\ntry/exceptdef check_num(s):\n  try:\n    int(s)\n    return True\n  except:\n    return False\n\ndef check_list(l):\n  return [check_num(e) for e in l]\n\n%timeit check_list(testlist)\n1000 loops, best of 3: 217 \u00b5s per loop # 200 numbers per loop\ndef check_num(s):\n  try:\n    int(s)\n    return True\n  except:\n    return False\n\ndef check_list(l):\n  return [check_num(e) for e in l]\n\n%timeit check_list(testlist)\n1000 loops, best of 3: 217 \u00b5s per loop # 200 numbers per loop\nSeems that numpy solution is much faster. ",
                "Uh.. Try this: def int_check(a):\n    if int(a) == a:\n        return True\n    else:\n        return False\ndef int_check(a):\n    if int(a) == a:\n        return True\n    else:\n        return False\nThis works if you don't put a string that's not a number.And also (I forgot to put the number check part. ), there is a function checking if the string is a number or not. It is str.isdigit(). Here's an example: a = 2\na.isdigit()\na = 2\na.isdigit()\nIf you call a.isdigit(), it will return True. "
            ]
        },
        {
            "tag": "string",
            "patterns": [
                "Convert Int to String in Swift",
                "Convert Int to String in Swift"
            ],
            "responses": [
                "Converting Int to String:IntStringlet x : Int = 42\nvar myString = String(x)\nlet x : Int = 42\nvar myString = String(x)\nAnd the other way around - converting String to Int:StringIntlet myString : String = \"42\"\nlet x: Int? = myString.toInt()\n\nif (x != nil) {\n    // Successfully converted String to Int\n}\nlet myString : String = \"42\"\nlet x: Int? = myString.toInt()\n\nif (x != nil) {\n    // Successfully converted String to Int\n}\nOr if you're using Swift 2 or 3:let x: Int? = Int(myString)\nlet x: Int? = Int(myString)\n",
                "Check the Below Answer:let x : Int = 45\nvar stringValue = \"\\(x)\"\nprint(stringValue)\nlet x : Int = 45\nvar stringValue = \"\\(x)\"\nprint(stringValue)\n",
                "Here are 4 methods:var x = 34\nvar s = String(x)\nvar ss = \"\\(x)\"\nvar sss = toString(x)\nvar ssss = x.description\nvar x = 34\nvar s = String(x)\nvar ss = \"\\(x)\"\nvar sss = toString(x)\nvar ssss = x.description\nI can imagine that some people will have an issue with ss.  But if you were looking to build a string containing other content then why not.",
                "In Swift 3.0:In Swift 3.0var value: Int = 10\nvar string = String(describing: value)\nvar value: Int = 10\nvar string = String(describing: value)\n",
                "Swift 4:Swift 4let x:Int = 45\nlet str:String = String(describing: x)\nlet x:Int = 45\nlet str:String = String(describing: x)\nDeveloper.Apple.com > String > init(describing:)Developer.Apple.com > String > init(describing:)\nThe String(describing:) initializer is the preferred way to convert an instance of any type to a string. \nThe String(describing:) initializer is the preferred way to convert an instance of any type to a string. Custom String ConvertibleCustom String Convertible",
                "Just for completeness, you can also use:let x = 10.description\nlet x = 10.description\nor any other value that supports a description.",
                "Swift 4:Swift 4:Trying to show the value in label without Optional() word.Optional()here x is a Int value using.let str:String = String(x ?? 0)\nlet str:String = String(x ?? 0)\n",
                "To save yourself time and hassle in the future you can make an Int extension.  Typically I create a shared code file where I put extensions, enums, and other fun stuff.  Here is what the extension code looks like:extension Int\n{\n    func toString() -> String\n    {\n        var myString = String(self)\n        return myString\n    }\n}\nextension Int\n{\n    func toString() -> String\n    {\n        var myString = String(self)\n        return myString\n    }\n}\nThen later when you want to convert an int to a string you can just do something like:var myNumber = 0\nvar myNumberAsString = myNumber.toString()\nvar myNumber = 0\nvar myNumberAsString = myNumber.toString()\n",
                "in swift 3.0 this is how we can convert Int to String and String to Intswift 3.0IntStringStringInt//convert Integer to String in Swift 3.0\n\nlet theIntegerValue :Int = 123  // this can be var also\nlet theStringValue :String = String(theIntegerValue)\n\n\n//convert String to Integere in Swift 3.0\n\n\nlet stringValue : String = \"123\"\nlet integerValue : Int = Int(stringValue)!\n//convert Integer to String in Swift 3.0\n\nlet theIntegerValue :Int = 123  // this can be var also\nlet theStringValue :String = String(theIntegerValue)\n\n\n//convert String to Integere in Swift 3.0\n\n\nlet stringValue : String = \"123\"\nlet integerValue : Int = Int(stringValue)!\n",
                "for whatever reason the accepted answer did not work for me. I went with this approach:var myInt:Int = 10\nvar myString:String = toString(myInt)\nvar myInt:Int = 10\nvar myString:String = toString(myInt)\n",
                "Multiple ways to do this :var str1:String=\"\\(23)\"\nvar str2:String=String(format:\"%d\",234)\nvar str1:String=\"\\(23)\"\nvar str2:String=String(format:\"%d\",234)\n",
                "Swift 2:var num1 = 4\nvar numString = \"56\"\nvar sum2 = String(num1) + numString\nvar sum3 = Int(numString)\nvar num1 = 4\nvar numString = \"56\"\nvar sum2 = String(num1) + numString\nvar sum3 = Int(numString)\n",
                "let intAsString = 45.description     // \"45\"\nlet stringAsInt = Int(\"45\")          // 45\nlet intAsString = 45.description     // \"45\"\nlet stringAsInt = Int(\"45\")          // 45\n",
                "Swift String performanceSwift String performanceA little bit about performance\nUI Testing Bundle on iPhone 7(real device) with iOS 14UI Testing Bundlelet i = 0\nlt result1 = String(i) //0.56s 5890kB\nlt result2 = \"\\(i)\" //0.624s 5900kB\nlt result3 = i.description //0.758s 5890kB\nlet i = 0\nlt result1 = String(i) //0.56s 5890kB\nlt result2 = \"\\(i)\" //0.624s 5900kB\nlt result3 = i.description //0.758s 5890kB\nimport XCTest\n\nclass ConvertIntToStringTests: XCTestCase {\n    let count = 1_000_000\n    \n    func measureFunction(_ block: () -> Void) {\n        let metrics: [XCTMetric] = [\n            XCTClockMetric(),\n            XCTMemoryMetric()\n        ]\n        let measureOptions = XCTMeasureOptions.default\n        measureOptions.iterationCount = 5\n        \n        measure(metrics: metrics, options: measureOptions) {\n            block()\n        }\n    }\n\n    func testIntToStringConstructor() {\n        var result = \"\"\n        measureFunction {\n            for i in 0...count {\n                result += String(i)\n            }\n        }\n    }\n    \n    func testIntToStringInterpolation() {\n        var result = \"\"\n        measureFunction {\n            for i in 0...count {\n                result += \"\\(i)\"\n            }\n        }\n    }\n    \n    func testIntToStringDescription() {\n        var result = \"\"\n        measureFunction {\n            for i in 0...count {\n                result += i.description\n            }\n        }\n    }\n}\nimport XCTest\n\nclass ConvertIntToStringTests: XCTestCase {\n    let count = 1_000_000\n    \n    func measureFunction(_ block: () -> Void) {\n        let metrics: [XCTMetric] = [\n            XCTClockMetric(),\n            XCTMemoryMetric()\n        ]\n        let measureOptions = XCTMeasureOptions.default\n        measureOptions.iterationCount = 5\n        \n        measure(metrics: metrics, options: measureOptions) {\n            block()\n        }\n    }\n\n    func testIntToStringConstructor() {\n        var result = \"\"\n        measureFunction {\n            for i in 0...count {\n                result += String(i)\n            }\n        }\n    }\n    \n    func testIntToStringInterpolation() {\n        var result = \"\"\n        measureFunction {\n            for i in 0...count {\n                result += \"\\(i)\"\n            }\n        }\n    }\n    \n    func testIntToStringDescription() {\n        var result = \"\"\n        measureFunction {\n            for i in 0...count {\n                result += i.description\n            }\n        }\n    }\n}\n",
                "iam using this simple approachString to Int: var a = Int()\nvar string1 = String(\"1\")\na = string1.toInt()\n var a = Int()\nvar string1 = String(\"1\")\na = string1.toInt()\nand from Int to String:var a = Int()\na = 1\nvar string1 = String()\n string1= \"\\(a)\"\nvar a = Int()\na = 1\nvar string1 = String()\n string1= \"\\(a)\"\n",
                "Convert Unicode Int to StringFor those who want to convert an Int to a Unicode string, you can do the following:let myInteger: Int = 97\n\n// convert Int to a valid UnicodeScalar\nguard let myUnicodeScalar = UnicodeScalar(myInteger) else {\n    return \"\"\n}\n\n// convert UnicodeScalar to String\nlet myString = String(myUnicodeScalar)\n\n// results\nprint(myString) // a\nlet myInteger: Int = 97\n\n// convert Int to a valid UnicodeScalar\nguard let myUnicodeScalar = UnicodeScalar(myInteger) else {\n    return \"\"\n}\n\n// convert UnicodeScalar to String\nlet myString = String(myUnicodeScalar)\n\n// results\nprint(myString) // a\nOr alternatively:let myInteger: Int = 97\nif let myUnicodeScalar = UnicodeScalar(myInteger) {\n    let myString = String(myUnicodeScalar)\n}\nlet myInteger: Int = 97\nif let myUnicodeScalar = UnicodeScalar(myInteger) {\n    let myString = String(myUnicodeScalar)\n}\n",
                "I prefer using String InterpolationString Interpolationlet x = 45\nlet string = \"\\(x)\"\nlet x = 45\nlet string = \"\\(x)\"\nEach object has some string representation. This makes things simpler. For example if you need to create some String with multiple values. You can also do any math in it or use some conditionsStringlet text = \"\\(count) \\(count > 1 ? \"items\" : \"item\") in the cart. Sum: $\\(sum + shippingPrice)\"\nlet text = \"\\(count) \\(count > 1 ? \"items\" : \"item\") in the cart. Sum: $\\(sum + shippingPrice)\"\n",
                "exampleLabel.text = String(yourInt)exampleLabel.text = String(yourInt)",
                "To convert String into IntTo convert String into Intvar numberA = Int(\"10\")\n\nPrint(numberA) // It will print 10\nvar numberA = Int(\"10\")\n\nPrint(numberA) // It will print 10\nTo covert Int into StringTo covert Int into Stringvar numberA = 10\nvar numberA = 10\n1st way)print(\"numberA is \\(numberA)\") // It will print 10\nprint(\"numberA is \\(numberA)\") // It will print 10\n2nd way)var strSomeNumber = String(numberA)\nvar strSomeNumber = String(numberA)\nor var strSomeNumber = \"\\(numberA)\"\nvar strSomeNumber = \"\\(numberA)\"\n",
                "let a =123456888\nvar str = String(a)\nlet a =123456888\nvar str = String(a)\nORvar str = a as! String\nvar str = a as! String\n",
                "In swift 3.0, you may change integer to string as given below let a:String = String(stringInterpolationSegment: 15)\nlet a:String = String(stringInterpolationSegment: 15)\nAnother way islet number: Int = 15\nlet _numberInStringFormate: String = String(number)\nlet number: Int = 15\nlet _numberInStringFormate: String = String(number)\n//or any integer number in place of 15",
                "If you like swift extension, you can add following codeextension Int\n{\n    var string:String {\n        get {\n            return String(self)\n        }\n    }\n}\nextension Int\n{\n    var string:String {\n        get {\n            return String(self)\n        }\n    }\n}\nthen, you can get string by the method you just addedvar x = 1234\nvar s = x.string\nvar x = 1234\nvar s = x.string\n",
                "let Str = \"12\"\nlet num: Int = 0\nnum = Int (str)\nlet Str = \"12\"\nlet num: Int = 0\nnum = Int (str)\n"
            ]
        },
        {
            "tag": "mysql",
            "patterns": [
                "What is the size of column of int(11) in mysql in bytes?",
                "What is the size of column of int(11) in mysql in bytes?"
            ],
            "responses": [
                "An INT will always be 4 bytes no matter what length is specified.INT\nTINYINT = 1 byte (8 bit)\nSMALLINT = 2 bytes (16 bit)\nMEDIUMINT = 3 bytes (24 bit)\nINT = 4 bytes (32 bit)\nBIGINT = 8 bytes (64 bit).\nTINYINT = 1 byte (8 bit)TINYINTSMALLINT = 2 bytes (16 bit)SMALLINTMEDIUMINT = 3 bytes (24 bit)MEDIUMINTINT = 4 bytes (32 bit)INTBIGINT = 8 bytes (64 bit).BIGINTThe length just specifies how many characters to pad when selecting data with the mysql command line client. 12345 stored as int(3) will still show as 12345, but if it was stored as int(10) it would still display as 12345, but you would have the option to pad the first five digits. For example, if you added ZEROFILL it would display as 0000012345.int(3)int(10)ZEROFILL... and the maximum value will be 2147483647 (Signed) or 4294967295 (Unsigned)",
                "INT(x) will make difference only in term of display, that is to show  the number in x digits, and not restricted to 11. You pair it using ZEROFILL, which will prepend the zeros until it matches your length.INT(x)xonly in term of displayxZEROFILLSo, for any number of x in INT(x)xINT(x)\nif the stored value has less digits than x, ZEROFILL will prepend zeros.\nif the stored value has less digits than x, ZEROFILL will prepend zeros.has less digitsxZEROFILL\nINT(5) ZEROFILL with the stored value of 32 will show 00032\nINT(5) with the stored value of 32 will show 32\nINT with the stored value of 32 will show 32\nINT(5) ZEROFILL with the stored value of 32 will show 00032\nINT(5) with the stored value of 32 will show 32\nINT with the stored value of 32 will show 32INT(5) ZEROFILL00032INT(5)32INT32\nif the stored value has more digits than x, it will be shown as it is.\nif the stored value has more digits than x, it will be shown as it is.has more digitsx\nINT(3) ZEROFILL with the stored value of 250000 will show 250000\nINT(3) with the stored value of 250000 will show 250000\nINT with the stored value of 250000 will show 250000\nINT(3) ZEROFILL with the stored value of 250000 will show 250000\nINT(3) with the stored value of 250000 will show 250000\nINT with the stored value of 250000 will show 250000INT(3) ZEROFILL250000INT(3)250000INT250000The actual value stored in database is not affected, the size is still the same, and any calculation will behave normally.This also applies to BIGINT, MEDIUMINT, SMALLINT, and TINYINT.BIGINTMEDIUMINTSMALLINTTINYINT",
                "According to here, int(11) will take 4 bytes of space that is 32 bits of space with  2^(31) = 2147483648 max value and -2147483648min value. One bit is for sign.hereint(11)2^(31) = 2147483648-2147483648",
                "As others have said, the minumum/maximum values the column can store and how much storage it takes in bytes is only defined by the type, not the length. A lot of these answers are saying that the (11) part only affects the display width which isn't exactly true, but mostly.(11)A definition of int(2) with no zerofill specified will:int(2)no zerofill specified\nstill accept a value of 100\nstill display a value of 100 when output (not 0 or 00)\nthe display width will be the width of the largest value being output from the select query.\nstill accept a value of 100100still display a value of 100 when output (not 0 or 00)display100000the display width will be the width of the largest value being output from the select query.display widthThe only thing the (2) will do is if zerofill is also specified:(2)if zerofill is also specified\na value of 1 will be shown 01. \nWhen displaying values, the column will always have a width of the maximum possible value the column could take which is 10 digits for an integer, instead of the miniumum width required to display the largest value that column needs to show for in that specific select query, which could be much smaller.\nThe column can still take, and show a value exceeding the length, but these values will not be prefixed with 0s.\na value of 1 will be shown 01. 101When displaying values, the column will always have a width of the maximum possible value the column could take which is 10 digits for an integer, instead of the miniumum width required to display the largest value that column needs to show for in that specific select query, which could be much smaller.width of the maximum possible value the column could takeThe column can still take, and show a value exceeding the length, but these values will not be prefixed with 0s.The best way to see all the nuances is to run:CREATE TABLE `mytable` (\n    `id` int(11) NOT NULL AUTO_INCREMENT,\n    `int1` int(10) NOT NULL,\n    `int2` int(3) NOT NULL,\n    `zf1` int(10) ZEROFILL NOT NULL,\n    `zf2` int(3) ZEROFILL NOT NULL,\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `mytable` \n(`int1`, `int2`, `zf1`, `zf2`) \nVALUES\n(10000, 10000, 10000, 10000),\n(100, 100, 100, 100);\n\nselect * from mytable;\nCREATE TABLE `mytable` (\n    `id` int(11) NOT NULL AUTO_INCREMENT,\n    `int1` int(10) NOT NULL,\n    `int2` int(3) NOT NULL,\n    `zf1` int(10) ZEROFILL NOT NULL,\n    `zf2` int(3) ZEROFILL NOT NULL,\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `mytable` \n(`int1`, `int2`, `zf1`, `zf2`) \nVALUES\n(10000, 10000, 10000, 10000),\n(100, 100, 100, 100);\n\nselect * from mytable;\nwhich will output:+----+-------+-------+------------+-------+\n| id | int1  | int2  | zf1        | zf2   |\n+----+-------+-------+------------+-------+\n|  1 | 10000 | 10000 | 0000010000 | 10000 |\n|  2 |   100 |   100 | 0000000100 |   100 |\n+----+-------+-------+------------+-------+\n+----+-------+-------+------------+-------+\n| id | int1  | int2  | zf1        | zf2   |\n+----+-------+-------+------------+-------+\n|  1 | 10000 | 10000 | 0000010000 | 10000 |\n|  2 |   100 |   100 | 0000000100 |   100 |\n+----+-------+-------+------------+-------+\nThis answer is tested against MySQL 5.7.12 for Linux and may or may not vary for other implementations.",
                "\nWhat is the size of column of int(11) in mysql in bytes?  \nWhat is the size of column of int(11) in mysql in bytes?  (11) - this attribute of int data type has nothing to do with size of column. It is just the display width of the integer data type. From 11.1.4.5. Numeric Type Attributes:  (11)int11.1.4.5. Numeric Type Attributes\nMySQL supports an extension for optionally specifying the display\n  width of integer data types in parentheses following the base keyword\n  for the type. For example, INT(4) specifies an INT with a display\n  width of four digits.\nMySQL supports an extension for optionally specifying the display\n  width of integer data types in parentheses following the base keyword\n  for the type. For example, INT(4) specifies an INT with a display\n  width of four digits.",
                "A good explanation for this can be found here\nTo summarize : The number N in int(N) is often confused by the maximum size allowed for the column, as it does in the case of varchar(N).  But this is not the case with Integer data types- the number N in the parentheses is not the maximum size for the column, but simply a parameter to tell MySQL what width to display the column at when the table's data is being viewed via the MySQL console (when you're using the ZEROFILL attribute).\n\nThe number in brackets will tell MySQL how many zeros to pad incoming integers with. For example: If you're using ZEROFILL on a column that is set to INT(5) and the number 78 is inserted, MySQL will pad that value with zeros until the number satisfies the number in brackets. i.e. 78 will become 00078 and 127 will become 00127. To sum it up: The number in brackets is used for display purposes.\nIn a way, the number in brackets is kind of usless unless you're using the ZEROFILL attribute.\nSo the size for the int would remain same i.e., -2147483648 to 2147483648 for signed and  0 to 4294967295 for unsigned (~ 2.15 billions and 4.2 billions, which is one of the reasons why developers remain unaware of the story behind the Number N in parentheses, as it hardly affects the database unless it contains over 2 billions of rows), and in terms of bytes it would be 4 bytes.herethe number N in the parentheses is not the maximum size for the column, but simply a parameter to tell MySQL what width to display the column at when the table's data is being viewed via the MySQL console (when you're using the ZEROFILL attribute).-2147483648 to 2147483648 for signed0 to 4294967295 for unsigned4 bytesFor more information on Integer Types size/range, refer to MySQL ManualMySQL Manual",
                "In MySQL integer int(11) has size is 4 bytes which equals 32 bit.int(11)Signed value is : -2^(32-1) to 0 to 2^(32-1)-1\n            =    -2147483648 to 0 to 21474836472^(32-1) to 0 to 2^(32-1)-1-2147483648 to 0 to 2147483647Unsigned values is : 0 to 2^32-1\n                  =  0 to 42949672950 to 2^32-10 to 4294967295",
                "Though this answer is unlikely to be seen, I think the following clarification is worth making: \nthe (n) behind an integer data type in MySQL is specifying the display width\nthe display width does NOT limit the length of the number returned from a query\nthe display width DOES limit the number of zeroes filled for a zero filled column so the total number matches the display width (so long as the actual number does not exceed the display width, in which case the number is shown as is)\nthe display width is also meant as a useful tool for developers to know what length the value should be padded to\nthe (n) behind an integer data type in MySQL is specifying the display widththe display width does NOT limit the length of the number returned from a querythe display width DOES limit the number of zeroes filled for a zero filled column so the total number matches the display width (so long as the actual number does not exceed the display width, in which case the number is shown as is)the display width is also meant as a useful tool for developers to know what length the value should be padded toA BIT OF DETAIL\nthe display width is, apparently, intended to provide some metadata about how many zeros to display in a zero filled number.\nIt does NOT actually limit the length of a number returned from a query if that number goes above the display width specified.\nTo know what length/width is actually allowed for an integer data type in MySQL see the list & link: (types: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT);\nSo having said the above, you can expect the display width to have no affect on the results from a standard query, unless the columns are specified as ZEROFILL columns \nOR \nin the case the data is being pulled into an application & that application is collecting the display width to use for some other sort of padding.A BIT OF DETAILtypes: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINTPrimary Reference: https://blogs.oracle.com/jsmyth/entry/what_does_the_11_meanhttps://blogs.oracle.com/jsmyth/entry/what_does_the_11_mean",
                "according to this book:book\nMySQL lets you specify a \u201cwidth\u201d for integer types, such as INT(11).\n  This is meaningless for most applications: it does not restrict the\n  legal range of values, but simply specifies the number of characters\n  MySQL\u2019s interactive tools will reserve for display purposes. For\n  storage and computational purposes, INT(1) is identical to INT(20).\nMySQL lets you specify a \u201cwidth\u201d for integer types, such as INT(11).\n  This is meaningless for most applications: it does not restrict the\n  legal range of values, but simply specifies the number of characters\n  MySQL\u2019s interactive tools will reserve for display purposes. For\n  storage and computational purposes, INT(1) is identical to INT(20).",
                "I think max value of int(11) is 4294967295",
                "4294967295 is the answer, because int(11) shows maximum of 11 digits IMO"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "\"is\" operator behaves unexpectedly with integers",
                "the is operator is unexpectedly interacting with integers",
                "the operator behaves unexpectedly with integers",
                "this operator behaves unexpectedly with integers",
                "the is operator behaves unexpectedly with integers"
            ],
            "responses": [
                "Take a look at this:>>> a = 256\n>>> b = 256\n>>> id(a)\n9987148\n>>> id(b)\n9987148\n>>> a = 257\n>>> b = 257\n>>> id(a)\n11662816\n>>> id(b)\n11662828\n>>> a = 256\n>>> b = 256\n>>> id(a)\n9987148\n>>> id(b)\n9987148\n>>> a = 257\n>>> b = 257\n>>> id(a)\n11662816\n>>> id(b)\n11662828\nHere's what I found in the documentation for \"Plain Integer Objects\":\"Plain Integer Objects\"\nThe current implementation keeps an array of integer objects for all integers between -5 and 256. When you create an int in that range you actually just get back a reference to the existing object.\nThe current implementation keeps an array of integer objects for all integers between -5 and 256. When you create an int in that range you actually just get back a reference to the existing object.-5256",
                "\nPython's \u201cis\u201d operator behaves unexpectedly with integers?\nPython's \u201cis\u201d operator behaves unexpectedly with integers?In summary - let me emphasize: Do not use is to compare integers.Do not use is to compare integers.Do not use is to compare integers.isThis isn't behavior you should have any expectations about.Instead, use == and != to compare for equality and inequality, respectively. For example:==!=>>> a = 1000\n>>> a == 1000       # Test integers like this,\nTrue\n>>> a != 5000       # or this!\nTrue\n>>> a is 1000       # Don't do this! - Don't use `is` to test integers!!\nFalse\n>>> a = 1000\n>>> a == 1000       # Test integers like this,\nTrue\n>>> a != 5000       # or this!\nTrue\n>>> a is 1000       # Don't do this! - Don't use `is` to test integers!!\nFalse\nExplanationTo know this, you need to know the following.First, what does is do? It is a comparison operator. From the documentation:isdocumentation\nThe operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. x is not y yields the\n  inverse truth value.\nThe operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. x is not y yields the\n  inverse truth value.isis notx is yx is not yAnd so the following are equivalent. >>> a is b\n>>> id(a) == id(b)\n>>> a is b\n>>> id(a) == id(b)\nFrom the documentation:documentation\nid\n  Return the \u201cidentity\u201d of an object. This is an integer (or long\n  integer) which is guaranteed to be unique and constant for this object\n  during its lifetime. Two objects with non-overlapping lifetimes may\n  have the same id() value.\nid\n  Return the \u201cidentity\u201d of an object. This is an integer (or long\n  integer) which is guaranteed to be unique and constant for this object\n  during its lifetime. Two objects with non-overlapping lifetimes may\n  have the same id() value.ididid()Note that the fact that the id of an object in CPython (the reference implementation of Python) is the location in memory is an implementation detail. Other implementations of Python (such as Jython or IronPython) could easily have a different implementation for id.idSo what is the use-case for is?  PEP8 describes:isPEP8 describes\nComparisons to singletons like None should always be done with is or\n  is not, never the equality operators.\nComparisons to singletons like None should always be done with is or\n  is not, never the equality operators.Noneisis notThe QuestionYou ask, and state, the following question (with code):\nWhy does the following behave unexpectedly in Python?\n>>> a = 256\n>>> b = 256\n>>> a is b\nTrue           # This is an expected result\n\nWhy does the following behave unexpectedly in Python?Why does the following behave unexpectedly in Python?>>> a = 256\n>>> b = 256\n>>> a is b\nTrue           # This is an expected result\n>>> a = 256\n>>> b = 256\n>>> a is b\nTrue           # This is an expected result\nIt is not an expected result. Why is it expected? It only means that the integers valued at 256 referenced by both a and b are the same instance of integer. Integers are immutable in Python, thus they cannot change. This should have no impact on any code. It should not be expected. It is merely an implementation detail. not256abBut perhaps we should be glad that there is not a new separate instance in memory every time we state a value equals 256. \n>>> a = 257\n>>> b = 257\n>>> a is b\nFalse          # What happened here? Why is this False?\n\n>>> a = 257\n>>> b = 257\n>>> a is b\nFalse          # What happened here? Why is this False?\n>>> a = 257\n>>> b = 257\n>>> a is b\nFalse          # What happened here? Why is this False?\nLooks like we now have two separate instances of integers with the value of 257 in memory. Since integers are immutable, this wastes memory. Let's hope we're not wasting a lot of it. We're probably not. But this behavior is not guaranteed.257\n>>> 257 is 257\nTrue           # Yet the literal numbers compare properly\n\n>>> 257 is 257\nTrue           # Yet the literal numbers compare properly\n>>> 257 is 257\nTrue           # Yet the literal numbers compare properly\nWell, this looks like your particular implementation of Python is trying to be smart and not creating redundantly valued integers in memory unless it has to. You seem to indicate you are using the referent implementation of Python, which is CPython. Good for CPython. It might be even better if CPython could do this globally, if it could do so cheaply (as there would a cost in the lookup), perhaps another implementation might. But as for impact on code, you should not care if an integer is a particular instance of an integer. You should only care what the value of that instance is, and you would use the normal comparison operators for that, i.e. ==.==What is doesisis checks that the id of two objects are the same. In CPython, the id is the location in memory, but it could be some other uniquely identifying number in another implementation. To restate this with code:isidid>>> a is b\n>>> a is b\nis the same as>>> id(a) == id(b)\n>>> id(a) == id(b)\nWhy would we want to use is then?isThis can be a very fast check relative to say, checking if two very long strings are equal in value. But since it applies to the uniqueness of the object, we thus have limited use-cases for it. In fact, we mostly want to use it to check for None, which is a singleton (a sole instance existing in one place in memory). We might create other singletons if there is potential to conflate them, which we might check with is, but these are relatively rare. Here's an example (will work in Python 2 and 3) e.g.NoneisSENTINEL_SINGLETON = object() # this will only be created one time.\n\ndef foo(keyword_argument=None):\n    if keyword_argument is None:\n        print('no argument given to foo')\n    bar()\n    bar(keyword_argument)\n    bar('baz')\n\ndef bar(keyword_argument=SENTINEL_SINGLETON):\n    # SENTINEL_SINGLETON tells us if we were not passed anything\n    # as None is a legitimate potential argument we could get.\n    if keyword_argument is SENTINEL_SINGLETON:\n        print('no argument given to bar')\n    else:\n        print('argument to bar: {0}'.format(keyword_argument))\n\nfoo()\nSENTINEL_SINGLETON = object() # this will only be created one time.\n\ndef foo(keyword_argument=None):\n    if keyword_argument is None:\n        print('no argument given to foo')\n    bar()\n    bar(keyword_argument)\n    bar('baz')\n\ndef bar(keyword_argument=SENTINEL_SINGLETON):\n    # SENTINEL_SINGLETON tells us if we were not passed anything\n    # as None is a legitimate potential argument we could get.\n    if keyword_argument is SENTINEL_SINGLETON:\n        print('no argument given to bar')\n    else:\n        print('argument to bar: {0}'.format(keyword_argument))\n\nfoo()\nWhich prints:no argument given to foo\nno argument given to bar\nargument to bar: None\nargument to bar: baz\nno argument given to foo\nno argument given to bar\nargument to bar: None\nargument to bar: baz\nAnd so we see, with is and a sentinel, we are able to differentiate between when bar is called with no arguments and when it is called with None. These are the primary use-cases for is - do not use it to test for equality of integers, strings, tuples, or other things like these.isbarNoneisnot",
                "I'm late but, you want some source with your answer? I'll try and word this in an introductory manner so more folks can follow along.I'm late but, you want some source with your answer?A good thing about CPython is that you can actually see the source for this. I'm going to use links for the 3.5 release, but finding the corresponding 2.x ones is trivial.3.52.xIn CPython, the C-API function that handles creating a new int object is PyLong_FromLong(long v). The description for this function is:C-APIintPyLong_FromLong(long v)PyLong_FromLong(long v)\nThe current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)\nThe current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object(My italics)Don't know about you but I see this and think: Let's find that array!Let's find that array!If you haven't fiddled with the C code implementing CPython you should; everything is pretty organized and readable. For our case, we need to look in the Objects subdirectory of the main source code directory tree.you shouldObjects subdirectoryObjectsmain source code directory treePyLong_FromLong deals with long objects so it shouldn't be hard to deduce that we need to peek inside longobject.c. After looking inside you might think things are chaotic; they are, but fear not, the function we're looking for is chilling at line 230 waiting for us to check it out. It's a smallish function so the main body (excluding declarations) is easily pasted here:PyLong_FromLonglonglongobject.clongobject.cline 230PyObject *\nPyLong_FromLong(long ival)\n{\n    // omitting declarations\n\n    CHECK_SMALL_INT(ival);\n\n    if (ival < 0) {\n        /* negate: cant write this as abs_ival = -ival since that\n           invokes undefined behaviour when ival is LONG_MIN */\n        abs_ival = 0U-(unsigned long)ival;\n        sign = -1;\n    }\n    else {\n        abs_ival = (unsigned long)ival;\n    }\n\n    /* Fast path for single-digit ints */\n    if (!(abs_ival >> PyLong_SHIFT)) {\n        v = _PyLong_New(1);\n        if (v) {\n            Py_SIZE(v) = sign;\n            v->ob_digit[0] = Py_SAFE_DOWNCAST(\n                abs_ival, unsigned long, digit);\n        }\n        return (PyObject*)v; \n}\nPyObject *\nPyLong_FromLong(long ival)\n{\n    // omitting declarations\n\n    CHECK_SMALL_INT(ival);\n\n    if (ival < 0) {\n        /* negate: cant write this as abs_ival = -ival since that\n           invokes undefined behaviour when ival is LONG_MIN */\n        abs_ival = 0U-(unsigned long)ival;\n        sign = -1;\n    }\n    else {\n        abs_ival = (unsigned long)ival;\n    }\n\n    /* Fast path for single-digit ints */\n    if (!(abs_ival >> PyLong_SHIFT)) {\n        v = _PyLong_New(1);\n        if (v) {\n            Py_SIZE(v) = sign;\n            v->ob_digit[0] = Py_SAFE_DOWNCAST(\n                abs_ival, unsigned long, digit);\n        }\n        return (PyObject*)v; \n}\nNow, we're no C master-code-haxxorz but we're also not dumb, we can see that CHECK_SMALL_INT(ival); peeking at us all seductively; we can understand it has something to do with this. Let's check it out:master-code-haxxorzCHECK_SMALL_INT(ival);Let's check it out:#define CHECK_SMALL_INT(ival) \\\n    do if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) { \\\n        return get_small_int((sdigit)ival); \\\n    } while(0)\n#define CHECK_SMALL_INT(ival) \\\n    do if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) { \\\n        return get_small_int((sdigit)ival); \\\n    } while(0)\nSo it's a macro that calls function get_small_int if the value ival satisfies the condition:get_small_intivalif (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS)\nif (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS)\nSo what are NSMALLNEGINTS and NSMALLPOSINTS? Macros! Here they are:NSMALLNEGINTSNSMALLPOSINTSHere they areHere they are#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif\nSo our condition is if (-5 <= ival && ival < 257) call get_small_int.if (-5 <= ival && ival < 257)get_small_intNext let's look at get_small_int in all its glory (well, we'll just look at its body because that's where the interesting things are):get_small_int in all its gloryget_small_intPyObject *v;\nassert(-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS);\nv = (PyObject *)&small_ints[ival + NSMALLNEGINTS];\nPy_INCREF(v);\nPyObject *v;\nassert(-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS);\nv = (PyObject *)&small_ints[ival + NSMALLNEGINTS];\nPy_INCREF(v);\nOkay, declare a PyObject, assert that the previous condition holds and execute the assignment:PyObjectv = (PyObject *)&small_ints[ival + NSMALLNEGINTS];\nv = (PyObject *)&small_ints[ival + NSMALLNEGINTS];\nsmall_ints looks a lot like that array we've been searching for, and it is! We could've just read the damn documentation and we would've know all along!:small_intsWe could've just read the damn documentation and we would've know all along!We could've just read the damn documentation and we would've know all along!/* Small integers are preallocated in this array so that they\n   can be shared.\n   The integers that are preallocated are those in the range\n   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).\n*/\nstatic PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];\n/* Small integers are preallocated in this array so that they\n   can be shared.\n   The integers that are preallocated are those in the range\n   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).\n*/\nstatic PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];\nSo yup, this is our guy. When you want to create a new int in the range [NSMALLNEGINTS, NSMALLPOSINTS) you'll just get back a reference to an already existing object that has been preallocated.int[NSMALLNEGINTS, NSMALLPOSINTS)Since the reference refers to the same object, issuing id() directly or checking for identity with is on it will return exactly the same thing.id()isBut, when are they allocated??During initialization in _PyLong_Init Python will gladly enter in a for loop to do this for you:During initialization in _PyLong_Init_PyLong_Initfor (ival = -NSMALLNEGINTS; ival <  NSMALLPOSINTS; ival++, v++) {\nfor (ival = -NSMALLNEGINTS; ival <  NSMALLPOSINTS; ival++, v++) {\nCheck out the source to read the loop body!I hope my explanation has made you C things clearly now (pun obviously intented).CBut, 257 is 257? What's up?257 is 257This is actually easier to explain, and I have attempted to do so already; it's due to the fact that Python will execute this interactive statement as a single block:and I have attempted to do so already>>> 257 is 257\n>>> 257 is 257\nDuring complilation of this statement, CPython will see that you have two matching literals and will use the same PyLongObject representing 257. You can see this if you do the compilation yourself and examine its contents:PyLongObject257>>> codeObj = compile(\"257 is 257\", \"blah!\", \"exec\")\n>>> codeObj.co_consts\n(257, None)\n>>> codeObj = compile(\"257 is 257\", \"blah!\", \"exec\")\n>>> codeObj.co_consts\n(257, None)\nWhen CPython does the operation, it's now just going to load the exact same object:>>> import dis\n>>> dis.dis(codeObj)\n  1           0 LOAD_CONST               0 (257)   # dis\n              3 LOAD_CONST               0 (257)   # dis again\n              6 COMPARE_OP               8 (is)\n>>> import dis\n>>> dis.dis(codeObj)\n  1           0 LOAD_CONST               0 (257)   # dis\n              3 LOAD_CONST               0 (257)   # dis again\n              6 COMPARE_OP               8 (is)\nSo is will return True.isTrue",
                "It depends on whether you're looking to see if 2 things are equal, or the same object. is checks to see if they are the same object, not just equal. The small ints are probably pointing to the same memory location for space efficiency isIn [29]: a = 3\nIn [30]: b = 3\nIn [31]: id(a)\nOut[31]: 500729144\nIn [32]: id(b)\nOut[32]: 500729144\nIn [29]: a = 3\nIn [30]: b = 3\nIn [31]: id(a)\nOut[31]: 500729144\nIn [32]: id(b)\nOut[32]: 500729144\nYou should use == to compare equality of arbitrary objects. You can specify the behavior with the __eq__, and __ne__ attributes.==__eq____ne__",
                "As you can check in source file intobject.c, Python caches small integers for efficiency. Every time you create a reference to a small integer, you are referring the cached small integer, not a new object. 257 is not an small integer, so it is calculated as a different object.source file intobject.cintobject.cIt is better to use == for that purpose.==",
                "I think your hypotheses is correct. Experiment with id (identity of object):idIn [1]: id(255)\nOut[1]: 146349024\n\nIn [2]: id(255)\nOut[2]: 146349024\n\nIn [3]: id(257)\nOut[3]: 146802752\n\nIn [4]: id(257)\nOut[4]: 148993740\n\nIn [5]: a=255\n\nIn [6]: b=255\n\nIn [7]: c=257\n\nIn [8]: d=257\n\nIn [9]: id(a), id(b), id(c), id(d)\nOut[9]: (146349024, 146349024, 146783024, 146804020)\nIn [1]: id(255)\nOut[1]: 146349024\n\nIn [2]: id(255)\nOut[2]: 146349024\n\nIn [3]: id(257)\nOut[3]: 146802752\n\nIn [4]: id(257)\nOut[4]: 148993740\n\nIn [5]: a=255\n\nIn [6]: b=255\n\nIn [7]: c=257\n\nIn [8]: d=257\n\nIn [9]: id(a), id(b), id(c), id(d)\nOut[9]: (146349024, 146349024, 146783024, 146804020)\nIt appears that numbers <= 255 are treated as literals and anything above is treated differently!<= 255",
                "There's another issue that isn't pointed out in any of the existing answers. Python is allowed to merge any two immutable values, and pre-created small int values are not the only way this can happen. A Python implementation is never guaranteed to do this, but they all do it for more than just small ints.guaranteedFor one thing, there are some other pre-created values, such as the empty tuple, str, and bytes, and some short strings (in CPython 3.6, it's the 256 single-character Latin-1 strings). For example:tuplestrbytes>>> a = ()\n>>> b = ()\n>>> a is b\nTrue\n>>> a = ()\n>>> b = ()\n>>> a is b\nTrue\nBut also, even non-pre-created values can be identical. Consider these examples:>>> c = 257\n>>> d = 257\n>>> c is d\nFalse\n>>> e, f = 258, 258\n>>> e is f\nTrue\n>>> c = 257\n>>> d = 257\n>>> c is d\nFalse\n>>> e, f = 258, 258\n>>> e is f\nTrue\nAnd this isn't limited to int values:int>>> g, h = 42.23e100, 42.23e100\n>>> g is h\nTrue\n>>> g, h = 42.23e100, 42.23e100\n>>> g is h\nTrue\nObviously, CPython doesn't come with a pre-created float value for 42.23e100. So, what's going on here?float42.23e100The CPython compiler will merge constant values of some known-immutable types like int, float, str, bytes,  in the same compilation unit. For a module, the whole module is a compilation unit, but at the interactive interpreter, each statement is a separate compilation unit. Since c and d are defined in separate statements, their values aren't merged. Since e and f are defined in the same statement, their values are merged.intfloatstrbytescdefYou can see what's going on by disassembling the bytecode. Try defining a function that does e, f = 128, 128 and then calling dis.dis on it, and you'll see that there's a single constant value (128, 128)e, f = 128, 128dis.dis(128, 128)>>> def f(): i, j = 258, 258\n>>> dis.dis(f)\n  1           0 LOAD_CONST               2 ((128, 128))\n              2 UNPACK_SEQUENCE          2\n              4 STORE_FAST               0 (i)\n              6 STORE_FAST               1 (j)\n              8 LOAD_CONST               0 (None)\n             10 RETURN_VALUE\n>>> f.__code__.co_consts\n(None, 128, (128, 128))\n>>> id(f.__code__.co_consts[1], f.__code__.co_consts[2][0], f.__code__.co_consts[2][1])\n4305296480, 4305296480, 4305296480\n>>> def f(): i, j = 258, 258\n>>> dis.dis(f)\n  1           0 LOAD_CONST               2 ((128, 128))\n              2 UNPACK_SEQUENCE          2\n              4 STORE_FAST               0 (i)\n              6 STORE_FAST               1 (j)\n              8 LOAD_CONST               0 (None)\n             10 RETURN_VALUE\n>>> f.__code__.co_consts\n(None, 128, (128, 128))\n>>> id(f.__code__.co_consts[1], f.__code__.co_consts[2][0], f.__code__.co_consts[2][1])\n4305296480, 4305296480, 4305296480\nYou may notice that the compiler has stored 128 as a constant even though it's not actually used by the bytecode, which gives you an idea of how little optimization CPython's compiler does. Which means that (non-empty) tuples actually don't end up merged:128>>> k, l = (1, 2), (1, 2)\n>>> k is l\nFalse\n>>> k, l = (1, 2), (1, 2)\n>>> k is l\nFalse\nPut that in a function, dis it, and look at the co_consts\u2014there's a 1 and a 2, two (1, 2) tuples that share the same 1 and 2 but are not identical, and a ((1, 2), (1, 2)) tuple that has the two distinct equal tuples.disco_consts12(1, 2)12((1, 2), (1, 2))There's one more optimization that CPython does: string interning. Unlike compiler constant folding, this isn't restricted to source code literals:>>> m = 'abc'\n>>> n = 'abc'\n>>> m is n\nTrue\n>>> m = 'abc'\n>>> n = 'abc'\n>>> m is n\nTrue\nOn the other hand, it is limited to the str type, and to strings of internal storage kind \"ascii compact\", \"compact\", or \"legacy ready\", and in many cases only \"ascii compact\" will get interned.strinternal storage kind \"ascii compact\", \"compact\", or \"legacy ready\"At any rate, the rules for what values must be, might be, or cannot be distinct vary from implementation to implementation, and between versions of the same implementation, and maybe even between runs of the same code on the same copy of the same implementation.It can be worth learning the rules for one specific Python for the fun of it. But it's not worth relying on them in your code. The only safe rule is:\nDo not write code that assumes two equal but separately-created immutable values are identical (don't use x is y, use x == y)\nDo not write code that assumes two equal but separately-created immutable values are distinct (don't use x is not y, use x != y)\nDo not write code that assumes two equal but separately-created immutable values are identical (don't use x is y, use x == y)x is yx == yDo not write code that assumes two equal but separately-created immutable values are distinct (don't use x is not y, use x != y)x is not yx != yOr, in other words, only use is to test for the documented singletons (like None) or that are only created in one place in the code (like the _sentinel = object() idiom).isNone_sentinel = object()",
                "For immutable value objects, like ints, strings or datetimes, object identity is not especially useful. It's better to think about equality. Identity is essentially an implementation detail for value objects - since they're immutable, there's no effective difference between having multiple refs to the same object or multiple objects.",
                "is is the identity equality operator (functioning like id(a) == id(b)); it's just that two equal numbers aren't necessarily the same object. For performance reasons some small integers happen to be memoized so they will tend to be the same (this can be done since they are immutable).isisid(a) == id(b)memoizedPHP's === operator, on the other hand, is described as checking equality and type: x == y and type(x) == type(y) as per Paulo Freitas' comment. This will suffice for common numbers, but differ from is for classes that define __eq__ in an absurd manner:PHP's===x == y and type(x) == type(y)is__eq__class Unequal:\n    def __eq__(self, other):\n        return False\nclass Unequal:\n    def __eq__(self, other):\n        return False\nPHP apparently allows the same thing for \"built-in\" classes (which I take to mean implemented at C level, not in PHP). A slightly less absurd use might be a timer object, which has a different value every time it's used as a number. Quite why you'd want to emulate Visual Basic's Now instead of showing that it is an evaluation with time.time() I don't know.Nowtime.time()Greg Hewgill (OP) made one clarifying comment \"My goal is to compare object identity, rather than equality of value. Except for numbers, where I want to treat object identity the same as equality of value.\"This would have yet another answer, as we have to categorize things as numbers or not, to select whether we compare with == or is. CPython defines the number protocol, including PyNumber_Check, but this is not accessible from Python itself.==isCPythonnumber protocolWe could try to use isinstance with all the number types we know of, but this would inevitably be incomplete. The types module contains a StringTypes list but no NumberTypes. Since Python 2.6, the built in number classes have a base class numbers.Number, but it has the same problem:isinstancenumbers.Numbernumbers.Numberimport numpy, numbers\nassert not issubclass(numpy.int16,numbers.Number)\nassert issubclass(int,numbers.Number)\nimport numpy, numbers\nassert not issubclass(numpy.int16,numbers.Number)\nassert issubclass(int,numbers.Number)\nBy the way, NumPy will produce separate instances of low numbers.NumPyI don't actually know an answer to this variant of the question. I suppose one could theoretically use ctypes to call PyNumber_Check, but even that function has been debated, and it's certainly not portable. We'll just have to be less particular about what we test for now.PyNumber_Checkhas been debatedIn the end, this issue stems from Python not originally having a type tree with predicates like Scheme's number?, or Haskell's type class Num. is checks object identity, not value equality. PHP has a colorful history as well, where === apparently behaves as is only on objects in PHP5, but not PHP4. Such are the growing pains of moving across languages (including versions of one).Scheme'snumber?Haskell'stype classNumis===isin PHP5, but not PHP4",
                "It also happens with strings:>>> s = b = 'somestr'\n>>> s == b, s is b, id(s), id(b)\n(True, True, 4555519392, 4555519392)\n>>> s = b = 'somestr'\n>>> s == b, s is b, id(s), id(b)\n(True, True, 4555519392, 4555519392)\nNow everything seems fine.>>> s = 'somestr'\n>>> b = 'somestr'\n>>> s == b, s is b, id(s), id(b)\n(True, True, 4555519392, 4555519392)\n>>> s = 'somestr'\n>>> b = 'somestr'\n>>> s == b, s is b, id(s), id(b)\n(True, True, 4555519392, 4555519392)\nThat's expected too.>>> s1 = b1 = 'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'\n>>> s1 == b1, s1 is b1, id(s1), id(b1)\n(True, True, 4555308080, 4555308080)\n\n>>> s1 = 'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'\n>>> b1 = 'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'\n>>> s1 == b1, s1 is b1, id(s1), id(b1)\n(True, False, 4555308176, 4555308272)\n>>> s1 = b1 = 'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'\n>>> s1 == b1, s1 is b1, id(s1), id(b1)\n(True, True, 4555308080, 4555308080)\n\n>>> s1 = 'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'\n>>> b1 = 'somestrdaasd ad ad asd as dasddsg,dlfg ,;dflg, dfg a'\n>>> s1 == b1, s1 is b1, id(s1), id(b1)\n(True, False, 4555308176, 4555308272)\nNow that's unexpected.",
                "What\u2019s New In Python 3.8: Changes in Python behavior:What\u2019s New In Python 3.8: Changes in Python behavior\nThe compiler now produces a SyntaxWarning when identity checks (is and\n  is not) are used with certain types of literals (e.g. strings, ints).\n  These can often work by accident in CPython, but are not guaranteed by\n  the language spec. The warning advises users to use equality tests (==\n  and !=) instead.\nThe compiler now produces a SyntaxWarning when identity checks (is and\n  is not) are used with certain types of literals (e.g. strings, ints).\n  These can often work by accident in CPython, but are not guaranteed by\n  the language spec. The warning advises users to use equality tests (==\n  and !=) instead.SyntaxWarningisis not==!="
            ]
        },
        {
            "tag": "php",
            "patterns": [
                "Converting an integer to a string in PHP",
                "converting an integer in a string in php",
                "the conversion of an integer to a string in php",
                "converting an integer to a string in php"
            ],
            "responses": [
                "You can use the strval() function to convert a number to a string.strval()strval()From a maintenance perspective its obvious what you are trying to do rather than some of the other more esoteric answers.  Of course, it depends on your context.$var = 5;\n\n// Inline variable parsing\necho \"I'd like {$var} waffles\"; // = I'd like 5 waffles\n\n// String concatenation \necho \"I'd like \".$var.\" waffles\"; // I'd like 5 waffles\n\n// The two examples above have the same end value...\n// ... And so do the two below\n\n// Explicit cast \n$items = (string)$var; // $items === \"5\";\n\n// Function call\n$items = strval($var); // $items === \"5\";\n$var = 5;\n\n// Inline variable parsing\necho \"I'd like {$var} waffles\"; // = I'd like 5 waffles\n\n// String concatenation \necho \"I'd like \".$var.\" waffles\"; // I'd like 5 waffles\n\n// The two examples above have the same end value...\n// ... And so do the two below\n\n// Explicit cast \n$items = (string)$var; // $items === \"5\";\n\n// Function call\n$items = strval($var); // $items === \"5\";\n",
                "There's many ways to do this.Two examples: $str = (string) $int;\n $str = \"$int\";     \n $str = (string) $int;\n $str = \"$int\";     \nSee the PHP Manual on Types Juggling for more.Types Juggling",
                "$foo = 5;\n\n$foo = $foo . \"\";\n$foo = 5;\n\n$foo = $foo . \"\";\nNow $foo is a string.$fooBut, you may want to get used to casting. As casting is the proper way to accomplish something of that sort:$foo = 5;\n$foo = (string)$foo;\n$foo = 5;\n$foo = (string)$foo;\nAnother way is to encapsulate in quotes:$foo = 5;\n$foo = \"$foo\"\n$foo = 5;\n$foo = \"$foo\"\n",
                "There are a number of ways to \"convert\" an integer to a string in PHP.The traditional computer science way would be to cast the variable as a string:$int = 5;\n$int_as_string = (string) $int;\necho $int . ' is a '. gettype($int) . \"\\n\";\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\n$int = 5;\n$int_as_string = (string) $int;\necho $int . ' is a '. gettype($int) . \"\\n\";\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\nYou could also take advantage of PHP's implicit type conversion and string interpolation:$int = 5;\necho $int . ' is a '. gettype($int) . \"\\n\";\n\n$int_as_string = \"$int\";\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\n\n$string_int = $int.'';\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\n$int = 5;\necho $int . ' is a '. gettype($int) . \"\\n\";\n\n$int_as_string = \"$int\";\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\n\n$string_int = $int.'';\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\nFinally, similar to the above, any function that accepts and returns a string could be used to convert and integer. Consider the following:$int = 5;\necho $int . ' is a '. gettype($int) . \"\\n\";\n\n$int_as_string = trim($int);\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\n$int = 5;\necho $int . ' is a '. gettype($int) . \"\\n\";\n\n$int_as_string = trim($int);\necho $int_as_string . ' is a ' . gettype($int_as_string) . \"\\n\";\nI wouldn't recommend the final option, but I've seen code in the wild that relied on this behavior, so thought I'd pass it along.",
                "Use:$intValue = 1;\n$string = sprintf('%d', $intValue);\n$intValue = 1;\n$string = sprintf('%d', $intValue);\nOr it could be:$string = (string)$intValue;\n$string = (string)$intValue;\nOr:settype($intValue, 'string');\nsettype($intValue, 'string');\n",
                "\nWarning: the below answer is based on the wrong premise. Casting 0 number to string always returns string \"0\", making the code provided redundant.\nWarning: the below answer is based on the wrong premise. Casting 0 number to string always returns string \"0\", making the code provided redundant.Warning:All these answers are great, but they all return you an empty string if the value is zero.Try the following:    $v = 0;\n\n    $s = (string)$v ? (string)$v : \"0\";\n    $v = 0;\n\n    $s = (string)$v ? (string)$v : \"0\";\n",
                "There are many possible conversion ways:$input => 123\nsprintf('%d',$input) => 123\n(string)$input => 123\nstrval($input) => 123\nsettype($input, \"string\") => 123\n$input => 123\nsprintf('%d',$input) => 123\n(string)$input => 123\nstrval($input) => 123\nsettype($input, \"string\") => 123\n",
                "You can either use the period operator and concatenate a string to it (and it will be type casted to a string):$integer = 93;\n$stringedInt = $integer . \"\";\n$integer = 93;\n$stringedInt = $integer . \"\";\nOr, more correctly, you can just type cast the integer to a string:$integer = 93;\n$stringedInt = (string) $integer;\n$integer = 93;\n$stringedInt = (string) $integer;\n",
                "As the answers here demonstrates nicely, yes, there are several ways. However, in PHP you rarely actually need to do that. The \"dogmatic way\" to write PHP is to rely on the language's loose typing system, which will transparently coerce the type as needed. For integer values, this is usually without trouble. You should be very careful with floating point values, though.",
                "I would say it depends on the context. strval() or the casting operator (string) could be used. However, in most cases PHP will decide what's good for you if, for example, you use it with echo or printf...strvalOne small note: die() needs a string and won't show any int :)",
                "$amount = 2351.25;\n$str_amount = \"2351.25\";\n\n$strCorrectAmount = \"$amount\";\necho gettype($strCorrectAmount);    //string\n$amount = 2351.25;\n$str_amount = \"2351.25\";\n\n$strCorrectAmount = \"$amount\";\necho gettype($strCorrectAmount);    //string\nSo the echo will be return string.string",
                "My situation :echo strval(\"12\"); => 12\necho strval(\"0\"); => \"0\"\necho strval(\"12\"); => 12\necho strval(\"0\"); => \"0\"\nI'm working ...$a = \"12\";\n$b = \"0\";\necho $a * 1; => 12\necho $b * 1; => 0\n\n$a = \"12\";\n$b = \"0\";\necho $a * 1; => 12\necho $b * 1; => 0\n\n",
                "I tried all the methods above yet I got \"array to string conversion\" error when I embedded the value in another string. If you have the same problem with me try the implode() function.\nexample:implode()$integer = 0;    \n$id = implode($integer);    \n$text = \"Your user ID is: \".$id ;\n$integer = 0;    \n$id = implode($integer);    \n$text = \"Your user ID is: \".$id ;\n",
                "You can simply use the following:$intVal = 5;\n$strVal = trim($intVal);\n$intVal = 5;\n$strVal = trim($intVal);\n",
                "$integer = 93;\n$stringedInt = $integer.'';\n$integer = 93;\n$stringedInt = $integer.'';\nis faster than $integer = 93;\n$stringedInt = $integer.\"\";\n$integer = 93;\n$stringedInt = $integer.\"\";\n"
            ]
        },
        {
            "tag": "c#",
            "patterns": [
                "Convert int to string?"
            ],
            "responses": [
                "string myString = myInt.ToString();\nstring myString = myInt.ToString();\n",
                "string a = i.ToString();\nstring b = Convert.ToString(i);\nstring c = string.Format(\"{0}\", i);\nstring d = $\"{i}\";\nstring e = \"\" + i;\nstring f = string.Empty + i;\nstring g = new StringBuilder().Append(i).ToString();\nstring a = i.ToString();\nstring b = Convert.ToString(i);\nstring c = string.Format(\"{0}\", i);\nstring d = $\"{i}\";\nstring e = \"\" + i;\nstring f = string.Empty + i;\nstring g = new StringBuilder().Append(i).ToString();\n",
                "Just in case you want the binary representation and you're still drunk from last night's party:private static string ByteToString(int value)\n{\n    StringBuilder builder = new StringBuilder(sizeof(byte) * 8);\n    BitArray[] bitArrays = BitConverter.GetBytes(value).Reverse().Select(b => new BitArray(new []{b})).ToArray();\n    foreach (bool bit in bitArrays.SelectMany(bitArray => bitArray.Cast<bool>().Reverse()))\n    {\n        builder.Append(bit ? '1' : '0');\n    }\n    return builder.ToString();\n}\nprivate static string ByteToString(int value)\n{\n    StringBuilder builder = new StringBuilder(sizeof(byte) * 8);\n    BitArray[] bitArrays = BitConverter.GetBytes(value).Reverse().Select(b => new BitArray(new []{b})).ToArray();\n    foreach (bool bit in bitArrays.SelectMany(bitArray => bitArray.Cast<bool>().Reverse()))\n    {\n        builder.Append(bit ? '1' : '0');\n    }\n    return builder.ToString();\n}\nNote: Something about not handling endianness very nicely...If you don't mind sacrificing a bit of memory for speed, you can use below to generate an array with pre-calculated string values:static void OutputIntegerStringRepresentations()\n{\n    Console.WriteLine(\"private static string[] integerAsDecimal = new [] {\");\n    for (int i = int.MinValue; i < int.MaxValue; i++)\n    {\n        Console.WriteLine(\"\\t\\\"{0}\\\",\", i);\n    }\n    Console.WriteLine(\"\\t\\\"{0}\\\"\", int.MaxValue);\n    Console.WriteLine(\"}\");\n}\nstatic void OutputIntegerStringRepresentations()\n{\n    Console.WriteLine(\"private static string[] integerAsDecimal = new [] {\");\n    for (int i = int.MinValue; i < int.MaxValue; i++)\n    {\n        Console.WriteLine(\"\\t\\\"{0}\\\",\", i);\n    }\n    Console.WriteLine(\"\\t\\\"{0}\\\"\", int.MaxValue);\n    Console.WriteLine(\"}\");\n}\n",
                "int num = 10;\nstring str = Convert.ToString(num);\nint num = 10;\nstring str = Convert.ToString(num);\n",
                "The ToString method of any object is supposed to return a string representation of that object.int var1 = 2;\n\nstring var2 = var1.ToString();\nint var1 = 2;\n\nstring var2 = var1.ToString();\n",
                "Further on to @Xavier's response, here's a page that does speed comparisons between several different ways to do the conversion from 100 iterations up to 21,474,836 iterations.here's a page that does speed comparisonsIt seems pretty much a tie between:int someInt = 0;\nsomeInt.ToString(); //this was fastest half the time\n//and\nConvert.ToString(someInt); //this was the fastest the other half the time\nint someInt = 0;\nsomeInt.ToString(); //this was fastest half the time\n//and\nConvert.ToString(someInt); //this was the fastest the other half the time\n",
                "string str = intVar.ToString();\nstring str = intVar.ToString();\nIn some conditions, you do not have to use ToString()ToString()string str = \"hi \" + intVar;\nstring str = \"hi \" + intVar;\n",
                "or:string s = Convert.ToString(num);\nstring s = Convert.ToString(num);\n",
                "using System.ComponentModel;\n\nTypeConverter converter = TypeDescriptor.GetConverter(typeof(int));\nstring s = (string)converter.ConvertTo(i, typeof(string));\nusing System.ComponentModel;\n\nTypeConverter converter = TypeDescriptor.GetConverter(typeof(int));\nstring s = (string)converter.ConvertTo(i, typeof(string));\n",
                "None of the answers mentioned that the ToString() method can be applied to integer expressionsToString() methodToString()integer expressionsDebug.Assert((1000*1000).ToString()==\"1000000\");\nDebug.Assert((1000*1000).ToString()==\"1000000\");\neven to integer literalsinteger literalsDebug.Assert(256.ToString(\"X\")==\"100\");\nDebug.Assert(256.ToString(\"X\")==\"100\");\nAlthough integer literals like this are often considered to be bad coding style (magic numbers) there may be cases where this feature is useful...magic numbersmagic numbers",
                "string s = \"\" + 2;\nstring s = \"\" + 2;\nand you can do nice things like: string s = 2 + 2 + \"you\" \nstring s = 2 + 2 + \"you\" \nThe result will be:\n\"4 you\"\n\"4 you\"",
                "if you're getting from a datasetstring newbranchcode = (Convert.ToInt32(ds.Tables[0].Rows[0][\"MAX(BRANCH_CODE)\"]) ).ToString();\nstring newbranchcode = (Convert.ToInt32(ds.Tables[0].Rows[0][\"MAX(BRANCH_CODE)\"]) ).ToString();\n"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "Java - Convert integer to string [duplicate]",
                "Java - Convert integer to string [duplicate]"
            ],
            "responses": [
                "There are multiple ways:\nString.valueOf(number) (my preference)\n\"\" + number (I don't know how the compiler handles it, perhaps it is as efficient as the above)\nInteger.toString(number)\nString.valueOf(number) (my preference)String.valueOf(number)\"\" + number (I don't know how the compiler handles it, perhaps it is as efficient as the above)\"\" + numberInteger.toString(number)Integer.toString(number)",
                "Integer class has static method toString() - you can use it:int i = 1234;\nString str = Integer.toString(i);\nint i = 1234;\nString str = Integer.toString(i);\n\nReturns a String object representing the specified integer. The argument is converted to signed decimal representation and returned as a string, exactly as if the argument and radix 10 were given as arguments to the toString(int, int) method.\nReturns a String object representing the specified integer. The argument is converted to signed decimal representation and returned as a string, exactly as if the argument and radix 10 were given as arguments to the toString(int, int) method.",
                "Always use either String.valueOf(number) or Integer.toString(number).String.valueOf(number)Integer.toString(number)Using \"\" + number is an overhead and does the following:StringBuilder sb = new StringBuilder();\nsb.append(\"\");\nsb.append(number);\nreturn sb.toString();\nStringBuilder sb = new StringBuilder();\nsb.append(\"\");\nsb.append(number);\nreturn sb.toString();\n",
                "This will do. Pretty trustworthy. : )    \"\"+number;\n    \"\"+number;\nJust to clarify, this works and acceptable to use unless you are looking for micro optimization.",
                "The way I know how to convert an integer into a string is by using the following code:Integer.toString(int);\nInteger.toString(int);\nand String.valueOf(int);\nString.valueOf(int);\nIf you had an integer i, and a string s, then the following would apply:int i;\nString s = Integer.toString(i); or\nString s = String.valueOf(i);\nint i;\nString s = Integer.toString(i); or\nString s = String.valueOf(i);\nIf you wanted to convert a string \"s\" into an integer \"i\", then the following would work:i = Integer.valueOf(s).intValue();\ni = Integer.valueOf(s).intValue();\n",
                "This is the method which i used to convert the integer to string.Correct me if i did wrong./**\n * @param a\n * @return\n */\nprivate String convertToString(int a) {\n\n    int c;\n    char m;\n    StringBuilder ans = new StringBuilder();\n    // convert the String to int\n    while (a > 0) {\n        c = a % 10;\n        a = a / 10;\n        m = (char) ('0' + c);\n        ans.append(m);\n    }\n    return ans.reverse().toString();\n}\n/**\n * @param a\n * @return\n */\nprivate String convertToString(int a) {\n\n    int c;\n    char m;\n    StringBuilder ans = new StringBuilder();\n    // convert the String to int\n    while (a > 0) {\n        c = a % 10;\n        a = a / 10;\n        m = (char) ('0' + c);\n        ans.append(m);\n    }\n    return ans.reverse().toString();\n}\n"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "Different between parseInt() and valueOf() in java?"
            ],
            "responses": [
                "Well, the API for Integer.valueOf(String) does indeed say that the String is interpreted exactly as if it were given to Integer.parseInt(String). However, valueOf(String) returns a new Integer() object whereas parseInt(String) returns a primitive int. Integer.valueOf(String)Integer.valueOf(String)StringInteger.parseInt(String)Integer.parseInt(String)valueOf(String)newnewInteger()parseInt(String)intIf you want to enjoy the potential caching benefits of Integer.valueOf(int), you could also use this eyesore:Integer.valueOf(int)Integer.valueOf(int)Integer k = Integer.valueOf(Integer.parseInt(\"123\"))\nInteger k = Integer.valueOf(Integer.parseInt(\"123\"))\nNow, if what you want is the object and not the primitive, then using valueOf(String) may be more attractive than making a new object out of parseInt(String) because the former is consistently present across Integer, Long, Double, etc.valueOf(String)parseInt(String)IntegerLongDouble",
                "From this forum:this forum\nparseInt() returns primitive integer\n  type (int), whereby valueOf returns\n  java.lang.Integer, which is the object\n  representative of the integer. There\n  are circumstances where you might want\n  an Integer object, instead of\n  primitive type.\nOf course, another obvious difference\n  is that intValue is an instance method\n  whereby parseInt is a static method.\nparseInt() returns primitive integer\n  type (int), whereby valueOf returns\n  java.lang.Integer, which is the object\n  representative of the integer. There\n  are circumstances where you might want\n  an Integer object, instead of\n  primitive type.parseInt()parseInt()intvalueOfvalueOfjava.lang.IntegerOf course, another obvious difference\n  is that intValue is an instance method\n  whereby parseInt is a static method.intValueparseInt",
                "Integer.valueOf(s)\nInteger.valueOf(s)\nis similar tonew Integer(Integer.parseInt(s))\nnew Integer(Integer.parseInt(s))\nThe difference is valueOf() returns an Integer, and parseInt() returns an int (a primitive type). Also note that valueOf() can return a cached Integer instance, which can cause confusing results where the result of == tests seem intermittently correct.  Before autoboxing there could be a difference in convenience, after java 1.5 it doesn't really matter.valueOf()IntegerparseInt()intvalueOf()Integer==autoboxingMoreover, Integer.parseInt(s) can take primitive datatype as well.Integer.parseInt(s)",
                "Look at Java sources: valueOf is using parseInt :valueOfparseInt/**\n * Parses the specified string as a signed decimal integer value.\n *\n * @param string\n *            the string representation of an integer value.\n * @return an {@code Integer} instance containing the integer value\n *         represented by {@code string}.\n * @throws NumberFormatException\n *             if {@code string} cannot be parsed as an integer value.\n * @see #parseInt(String)\n */\npublic static Integer valueOf(String string) throws NumberFormatException {\n    return valueOf(parseInt(string));\n}\n/**\n * Parses the specified string as a signed decimal integer value.\n *\n * @param string\n *            the string representation of an integer value.\n * @return an {@code Integer} instance containing the integer value\n *         represented by {@code string}.\n * @throws NumberFormatException\n *             if {@code string} cannot be parsed as an integer value.\n * @see #parseInt(String)\n */\npublic static Integer valueOf(String string) throws NumberFormatException {\n    return valueOf(parseInt(string));\n}\nparseInt returns int (not Integer)parseIntintInteger/**\n * Parses the specified string as a signed decimal integer value. The ASCII\n * character \\u002d ('-') is recognized as the minus sign.\n *\n * @param string\n *            the string representation of an integer value.\n * @return the primitive integer value represented by {@code string}.\n * @throws NumberFormatException\n *             if {@code string} cannot be parsed as an integer value.\n */\npublic static int parseInt(String string) throws NumberFormatException {\n    return parseInt(string, 10);\n}\n/**\n * Parses the specified string as a signed decimal integer value. The ASCII\n * character \\u002d ('-') is recognized as the minus sign.\n *\n * @param string\n *            the string representation of an integer value.\n * @return the primitive integer value represented by {@code string}.\n * @throws NumberFormatException\n *             if {@code string} cannot be parsed as an integer value.\n */\npublic static int parseInt(String string) throws NumberFormatException {\n    return parseInt(string, 10);\n}\n",
                "Integer.parseInt can just return int as native type.Integer.valueOf may actually need to allocate an Integer object, unless that integer happens to be one of the preallocated ones. This costs more.If you need just native type, use parseInt. If you need an object, use valueOf.Also, because of this potential allocation, autoboxing isn't actually good thing in every way. It can slow down things.",
                "\nvalueOf - converts to Wrapper class\nparseInt - converts to primitive type\nvalueOf - converts to Wrapper classvalueOfparseInt - converts to primitive typeparseIntInteger.parseInt accept only String and return primitive integer type (int).   public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n   public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\nIteger.valueOf accept int and String. \nIf value is String, valueOf convert it to the the simple int using parseInt and return new Integer if input is less than -128 or greater than 127. \nIf input is in range (-128 - 127) it always return the Integer objects from an internal IntegerCache. Integer class maintains an inner static IntegerCache class which acts as the cache and holds integer objects from -128 to 127 and that\u2019s why when we try to get integer object for 127 (for example) we always get the same object.Iteger.valueOf(200) will give new Integer from 200. It's like new Integer(200)\nIteger.valueOf(127) is the same as Integer = 127;Iteger.valueOf(200)new Integer(200)Iteger.valueOf(127)Integer = 127If you wont to convert String to the Integer use Iteger.valueOf. Iteger.valueOfIf you wont to convert String to the simple int use Integer.parseInt. It works faster.Integer.parseInt  public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n  public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n  }\n\n  private static class IntegerCache {\n      static final int low = -128;\n      static final int high;\n      static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n  }\n  public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n  public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n  }\n\n  private static class IntegerCache {\n      static final int low = -128;\n      static final int high;\n      static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n  }\nAnd comparing Integer.valueOf(127) == Integer.valueOf(127) return trueInteger a = 127; // Compiler converts this line to Integer a = Integer.valueOf(127);\nInteger b = 127; // Compiler converts this line to Integer b = Integer.valueOf(127);\na == b; // return true \nInteger a = 127; // Compiler converts this line to Integer a = Integer.valueOf(127);\nInteger b = 127; // Compiler converts this line to Integer b = Integer.valueOf(127);\na == b; // return true \nBecause it takes the Integer objects with the same references from the cache.But Integer.valueOf(128) == Integer.valueOf(128) is false, because 128 is out of IntegerCache range and it return new Integer, so objects will have different references.",
                "The parse* variations return primitive types and the valueOf versions return Objects. I believe the valueOf versions will also use an internal reference pool to return the SAME object for a given value, not just another instance with the same internal value.",
                "If you check the Integer class you will find that valueof call parseInt method. The big difference is caching when you call valueof API . It cache if the value is between -128 to 127 Please find below the link for more informationhttp://docs.oracle.com/javase/7/docs/api/java/lang/Integer.htmlhttp://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html",
                "Because you might be using jdk1.5+ and there it is auto converting to int. So in your code its first returning Integer and then auto converted to int.your code is same as int abc = new Integer(123);\nint abc = new Integer(123);\n",
                "public static Integer valueOf(String s)\nThe argument is interpreted as representing a signed decimal integer, exactly as if the argument were given to the parseInt(java.lang.String) method. \nThe result is an Integer object that represents the integer value specified by the string.\nIn other words, this method returns an Integer object equal to the value of:\nnew Integer(Integer.parseInt(s))\nThe argument is interpreted as representing a signed decimal integer, exactly as if the argument were given to the parseInt(java.lang.String) method. The result is an Integer object that represents the integer value specified by the string.The result is an Integer object that represents the integer value specified by the string.In other words, this method returns an Integer object equal to the value of:\nnew Integer(Integer.parseInt(s))In other words, this method returns an Integer object equal to the value of:\nnew Integer(Integer.parseInt(s))",
                "\nIn case of ValueOf -> it is creating an Integer object. not a primitive type and not a static method.\nIn case of ParseInt.ParseFloat -> it return respective primitive type. and is a static method. \nIn case of ValueOf -> it is creating an Integer object. not a primitive type and not a static method.In case of ParseInt.ParseFloat -> it return respective primitive type. and is a static method. We should use any one depending upon our need. In case of ValueOf as it is instantiating an object. it will consume more resources if we only need value of some text then we should use parseInt,parseFloat etc. "
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "Way to get number of digits in an int?"
            ],
            "responses": [
                "Your String-based solution is perfectly OK, there is nothing \"un-neat\" about it. You have to realize that mathematically, numbers don't have a length, nor do they have digits. Length and digits are both properties of a physical representation of a number in a specific base, i.e. a String.physical representationA logarithm-based solution does (some of) the same things the String-based one does internally, and probably does so (insignificantly) faster because it only produces the length and ignores the digits. But I wouldn't actually consider it clearer in intent - and that's the most important factor.",
                "The logarithm is your friend:int n = 1000;\nint length = (int)(Math.log10(n)+1);\nint n = 1000;\nint length = (int)(Math.log10(n)+1);\nNB: only valid for n > 0.",
                "The fastest approach: divide and conquer.Assuming your range is 0 to MAX_INT, then you have 1 to 10 digits. You can approach this interval using divide and conquer, with up to 4 comparisons per each input. First, you divide [1..10] into [1..5] and [6..10] with one comparison, and then each length 5 interval you divide using one comparison into one length 3 and one length 2 interval. The length 2 interval requires one more comparison (total 3 comparisons), the length 3 interval can be divided into length 1 interval (solution) and a length 2 interval. So, you need 3 or 4 comparisons.No divisions, no floating point operations, no expensive logarithms, only integer comparisons.Code (long but fast):if (n < 100000) {\n    // 5 or less\n    if (n < 100){\n        // 1 or 2\n        if (n < 10)\n            return 1;\n        else\n            return 2;\n    } else {\n        // 3 or 4 or 5\n        if (n < 1000)\n            return 3;\n        else {\n            // 4 or 5\n            if (n < 10000)\n                return 4;\n            else\n                return 5;\n        }\n    }\n} else {\n    // 6 or more\n    if (n < 10000000) {\n        // 6 or 7\n        if (n < 1000000)\n            return 6;\n        else\n            return 7;\n    } else {\n        // 8 to 10\n        if (n < 100000000)\n            return 8;\n        else {\n            // 9 or 10\n            if (n < 1000000000)\n                return 9;\n            else\n                return 10;\n        }\n    }\n}\nif (n < 100000) {\n    // 5 or less\n    if (n < 100){\n        // 1 or 2\n        if (n < 10)\n            return 1;\n        else\n            return 2;\n    } else {\n        // 3 or 4 or 5\n        if (n < 1000)\n            return 3;\n        else {\n            // 4 or 5\n            if (n < 10000)\n                return 4;\n            else\n                return 5;\n        }\n    }\n} else {\n    // 6 or more\n    if (n < 10000000) {\n        // 6 or 7\n        if (n < 1000000)\n            return 6;\n        else\n            return 7;\n    } else {\n        // 8 to 10\n        if (n < 100000000)\n            return 8;\n        else {\n            // 9 or 10\n            if (n < 1000000000)\n                return 9;\n            else\n                return 10;\n        }\n    }\n}\nBenchmark (after JVM warm-up) - see code below to see how the benchmark was run:\nbaseline method (with String.length):\n2145ms\nlog10 method: 711ms = 3.02 times\nas fast as baseline\nrepeated divide: 2797ms = 0.77 times\nas fast as baseline\ndivide-and-conquer: 74ms = 28.99\ntimes as fast as baseline\nbaseline method (with String.length):\n2145mslog10 method: 711ms = 3.02 times\nas fast as baselinerepeated divide: 2797ms = 0.77 times\nas fast as baselinedivide-and-conquer: 74ms = 28.99\ntimes as fast as baselineFull code:public static void main(String[] args) throws Exception {\n    \n    // validate methods:\n    for (int i = 0; i < 1000; i++)\n        if (method1(i) != method2(i))\n            System.out.println(i);\n    for (int i = 0; i < 1000; i++)\n        if (method1(i) != method3(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method3(i));\n    for (int i = 333; i < 2000000000; i += 1000)\n        if (method1(i) != method3(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method3(i));\n    for (int i = 0; i < 1000; i++)\n        if (method1(i) != method4(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method4(i));\n    for (int i = 333; i < 2000000000; i += 1000)\n        if (method1(i) != method4(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method4(i));\n    \n    // work-up the JVM - make sure everything will be run in hot-spot mode\n    allMethod1();\n    allMethod2();\n    allMethod3();\n    allMethod4();\n    \n    // run benchmark\n    Chronometer c;\n    \n    c = new Chronometer(true);\n    allMethod1();\n    c.stop();\n    long baseline = c.getValue();\n    System.out.println(c);\n    \n    c = new Chronometer(true);\n    allMethod2();\n    c.stop();\n    System.out.println(c + \" = \" + StringTools.formatDouble((double)baseline / c.getValue() , \"0.00\") + \" times as fast as baseline\");\n    \n    c = new Chronometer(true);\n    allMethod3();\n    c.stop();\n    System.out.println(c + \" = \" + StringTools.formatDouble((double)baseline / c.getValue() , \"0.00\") + \" times as fast as baseline\");\n    \n    c = new Chronometer(true);\n    allMethod4();\n    c.stop();\n    System.out.println(c + \" = \" + StringTools.formatDouble((double)baseline / c.getValue() , \"0.00\") + \" times as fast as baseline\");\n}\n\n\nprivate static int method1(int n) {\n    return Integer.toString(n).length();\n}\n\nprivate static int method2(int n) {\n    if (n == 0)\n        return 1;\n    return (int)(Math.log10(n) + 1);\n}\n\nprivate static int method3(int n) {\n    if (n == 0)\n        return 1;\n    int l;\n    for (l = 0 ; n > 0 ;++l)\n        n /= 10;\n    return l;\n}\n\nprivate static int method4(int n) {\n    if (n < 100000) {\n        // 5 or less\n        if (n < 100) {\n            // 1 or 2\n            if (n < 10)\n                return 1;\n            else\n                return 2;\n        } else {\n            // 3 or 4 or 5\n            if (n < 1000)\n                return 3;\n            else {\n                // 4 or 5\n                if (n < 10000)\n                    return 4;\n                else\n                    return 5;\n            }\n        }\n    } else {\n        // 6 or more\n        if (n < 10000000) {\n            // 6 or 7\n            if (n < 1000000)\n                return 6;\n            else\n                return 7;\n        } else {\n            // 8 to 10\n            if (n < 100000000)\n                return 8;\n            else {\n                // 9 or 10\n                if (n < 1000000000)\n                    return 9;\n                else\n                    return 10;\n            }\n        }\n    }\n}\n\n\nprivate static int allMethod1() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method1(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method1(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method1(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method1(i);\n    \n    return x;\n}\n\nprivate static int allMethod2() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method2(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method2(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method2(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method2(i);\n    \n    return x;\n}\n\nprivate static int allMethod3() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method3(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method3(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method3(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method3(i);\n    \n    return x;\n}\n\nprivate static int allMethod4() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method4(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method4(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method4(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method4(i);\n    \n    return x;\n}\npublic static void main(String[] args) throws Exception {\n    \n    // validate methods:\n    for (int i = 0; i < 1000; i++)\n        if (method1(i) != method2(i))\n            System.out.println(i);\n    for (int i = 0; i < 1000; i++)\n        if (method1(i) != method3(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method3(i));\n    for (int i = 333; i < 2000000000; i += 1000)\n        if (method1(i) != method3(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method3(i));\n    for (int i = 0; i < 1000; i++)\n        if (method1(i) != method4(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method4(i));\n    for (int i = 333; i < 2000000000; i += 1000)\n        if (method1(i) != method4(i))\n            System.out.println(i + \" \" + method1(i) + \" \" + method4(i));\n    \n    // work-up the JVM - make sure everything will be run in hot-spot mode\n    allMethod1();\n    allMethod2();\n    allMethod3();\n    allMethod4();\n    \n    // run benchmark\n    Chronometer c;\n    \n    c = new Chronometer(true);\n    allMethod1();\n    c.stop();\n    long baseline = c.getValue();\n    System.out.println(c);\n    \n    c = new Chronometer(true);\n    allMethod2();\n    c.stop();\n    System.out.println(c + \" = \" + StringTools.formatDouble((double)baseline / c.getValue() , \"0.00\") + \" times as fast as baseline\");\n    \n    c = new Chronometer(true);\n    allMethod3();\n    c.stop();\n    System.out.println(c + \" = \" + StringTools.formatDouble((double)baseline / c.getValue() , \"0.00\") + \" times as fast as baseline\");\n    \n    c = new Chronometer(true);\n    allMethod4();\n    c.stop();\n    System.out.println(c + \" = \" + StringTools.formatDouble((double)baseline / c.getValue() , \"0.00\") + \" times as fast as baseline\");\n}\n\n\nprivate static int method1(int n) {\n    return Integer.toString(n).length();\n}\n\nprivate static int method2(int n) {\n    if (n == 0)\n        return 1;\n    return (int)(Math.log10(n) + 1);\n}\n\nprivate static int method3(int n) {\n    if (n == 0)\n        return 1;\n    int l;\n    for (l = 0 ; n > 0 ;++l)\n        n /= 10;\n    return l;\n}\n\nprivate static int method4(int n) {\n    if (n < 100000) {\n        // 5 or less\n        if (n < 100) {\n            // 1 or 2\n            if (n < 10)\n                return 1;\n            else\n                return 2;\n        } else {\n            // 3 or 4 or 5\n            if (n < 1000)\n                return 3;\n            else {\n                // 4 or 5\n                if (n < 10000)\n                    return 4;\n                else\n                    return 5;\n            }\n        }\n    } else {\n        // 6 or more\n        if (n < 10000000) {\n            // 6 or 7\n            if (n < 1000000)\n                return 6;\n            else\n                return 7;\n        } else {\n            // 8 to 10\n            if (n < 100000000)\n                return 8;\n            else {\n                // 9 or 10\n                if (n < 1000000000)\n                    return 9;\n                else\n                    return 10;\n            }\n        }\n    }\n}\n\n\nprivate static int allMethod1() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method1(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method1(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method1(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method1(i);\n    \n    return x;\n}\n\nprivate static int allMethod2() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method2(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method2(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method2(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method2(i);\n    \n    return x;\n}\n\nprivate static int allMethod3() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method3(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method3(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method3(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method3(i);\n    \n    return x;\n}\n\nprivate static int allMethod4() {\n    int x = 0;\n    for (int i = 0; i < 1000; i++)\n        x = method4(i);\n    for (int i = 1000; i < 100000; i += 10)\n        x = method4(i);\n    for (int i = 100000; i < 1000000; i += 100)\n        x = method4(i);\n    for (int i = 1000000; i < 2000000000; i += 200)\n        x = method4(i);\n    \n    return x;\n}\nAgain, benchmark:\nbaseline method (with String.length): 2145ms\nlog10 method: 711ms = 3.02 times as fast as baseline\nrepeated divide: 2797ms = 0.77 times as fast as baseline\ndivide-and-conquer: 74ms = 28.99 times as fast as baseline\nbaseline method (with String.length): 2145mslog10 method: 711ms = 3.02 times as fast as baselinerepeated divide: 2797ms = 0.77 times as fast as baselinedivide-and-conquer: 74ms = 28.99 times as fast as baselineEditAfter I wrote the benchmark, I took a sneak peak into Integer.toString from Java 6, and I found that it uses:final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                  99999999, 999999999, Integer.MAX_VALUE };\n\n// Requires positive x\nstatic int stringSize(int x) {\n    for (int i=0; ; i++)\n        if (x <= sizeTable[i])\n            return i+1;\n}\nfinal static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                  99999999, 999999999, Integer.MAX_VALUE };\n\n// Requires positive x\nstatic int stringSize(int x) {\n    for (int i=0; ; i++)\n        if (x <= sizeTable[i])\n            return i+1;\n}\nI benchmarked it against my divide-and-conquer solution:\ndivide-and-conquer: 104ms\nJava 6 solution - iterate and compare: 406ms\ndivide-and-conquer: 104msJava 6 solution - iterate and compare: 406msMine is about 4x as fast as the Java 6 solution.",
                "Two comments on your benchmark: Java is a complex environment, what with just-in-time compiling and garbage collection and so forth, so to get a fair comparison, whenever I run a benchmark, I always: (a) enclose the two tests in a loop that runs them in sequence 5 or 10 times. Quite often the runtime on the second pass through the loop is quite different from the first. And (b) After each \"approach\", I do a System.gc() to try to trigger a garbage collection. Otherwise, the first approach might generate a bunch of objects, but not quite enough to force a garbage collection, then the second approach creates a few objects, the heap is exhausted, and garbage collection runs. Then the second approach is \"charged\" for picking up the garbage left by the first approach. Very unfair!That said, neither of the above made a significant difference in this example.With or without those modifications, I got very different results than you did. When I ran this, yes, the toString approach gave run times of 6400 to 6600 millis, while the log approach topok 20,000 to 20,400 millis. Instead of being slightly faster, the log approach was 3 times slower for me.Note that the two approaches involve very different costs, so this isn't totally shocking: The toString approach will create a lot of temporary objects that have to be cleaned up, while the log approach takes more intense computation. So maybe the difference is that on a machine with less memory, toString requires more garbage collection rounds, while on a machine with a slower processor, the extra computation of log would be more painful.I also tried a third approach. I wrote this little function:static int numlength(int n)\n{\n    if (n == 0) return 1;\n    int l;\n    n=Math.abs(n);\n    for (l=0;n>0;++l)\n        n/=10;\n    return l;           \n}\nstatic int numlength(int n)\n{\n    if (n == 0) return 1;\n    int l;\n    n=Math.abs(n);\n    for (l=0;n>0;++l)\n        n/=10;\n    return l;           \n}\nThat ran in 1600 to 1900 millis -- less than 1/3 of the toString approach, and 1/10 the log approach on my machine.If you had a broad range of numbers, you could speed it up further by starting out dividing by 1,000 or 1,000,000 to reduce the number of times through the loop. I haven't played with that.",
                "Can't leave a comment yet, so I'll post as a separate answer. The logarithm-based solution doesn't calculate the correct number of digits for very big long integers, for example:long n = 99999999999999999L;\n\n// correct answer: 17\nint numberOfDigits = String.valueOf(n).length();\n\n// incorrect answer: 18\nint wrongNumberOfDigits = (int) (Math.log10(n) + 1); \nlong n = 99999999999999999L;\n\n// correct answer: 17\nint numberOfDigits = String.valueOf(n).length();\n\n// incorrect answer: 18\nint wrongNumberOfDigits = (int) (Math.log10(n) + 1); \nLogarithm-based solution calculates incorrect number of digits in large integersLogarithm-based solution calculates incorrect number of digits in large integers",
                "Using JavaUsing Javaint nDigits = Math.floor(Math.log10(Math.abs(the_integer))) + 1;\nint nDigits = Math.floor(Math.log10(Math.abs(the_integer))) + 1;\nuse import java.lang.Math.*; in the beginningimport java.lang.Math.*;Using CUsing Cint nDigits = floor(log10(abs(the_integer))) + 1;\nint nDigits = floor(log10(abs(the_integer))) + 1;\nuse inclue math.h in the beginninginclue math.h",
                "Since the number of digits in base 10 of an integer is just 1 + truncate(log10(number)), you can do:1 + truncate(log10(number))public class Test {\n\n    public static void main(String[] args) {\n\n        final int number = 1234;\n        final int digits = 1 + (int)Math.floor(Math.log10(number));\n\n        System.out.println(digits);\n    }\n}\npublic class Test {\n\n    public static void main(String[] args) {\n\n        final int number = 1234;\n        final int digits = 1 + (int)Math.floor(Math.log10(number));\n\n        System.out.println(digits);\n    }\n}\nEdited because my last edit fixed the code example, but not the description.Edited",
                "Another string approach. Short and sweet - for any integer n.nint length = (\"\" + n).length();\nint length = (\"\" + n).length();\n",
                "Marian's solution adapted for long type numbers (up to 9,223,372,036,854,775,807), in case someone want's to Copy&Paste it.\nIn the program I wrote this for numbers up to 10000 were much more probable, so I made a specific branch for them. Anyway it won't make a significative difference.longpublic static int numberOfDigits (long n) {     \n    // Guessing 4 digit numbers will be more probable.\n    // They are set in the first branch.\n    if (n < 10000L) { // from 1 to 4\n        if (n < 100L) { // 1 or 2\n            if (n < 10L) {\n                return 1;\n            } else {\n                return 2;\n            }\n        } else { // 3 or 4\n            if (n < 1000L) {\n                return 3;\n            } else {\n                return 4;\n            }\n        }           \n    } else  { // from 5 a 20 (albeit longs can't have more than 18 or 19)\n        if (n < 1000000000000L) { // from 5 to 12\n            if (n < 100000000L) { // from 5 to 8\n                if (n < 1000000L) { // 5 or 6\n                    if (n < 100000L) {\n                        return 5;\n                    } else {\n                        return 6;\n                    }\n                } else { // 7 u 8\n                    if (n < 10000000L) {\n                        return 7;\n                    } else {\n                        return 8;\n                    }\n                }\n            } else { // from 9 to 12\n                if (n < 10000000000L) { // 9 or 10\n                    if (n < 1000000000L) {\n                        return 9;\n                    } else {\n                        return 10;\n                    }\n                } else { // 11 or 12\n                    if (n < 100000000000L) {\n                        return 11;\n                    } else {\n                        return 12;\n                    }\n                }\n            }\n        } else { // from 13 to ... (18 or 20)\n            if (n < 10000000000000000L) { // from 13 to 16\n                if (n < 100000000000000L) { // 13 or 14\n                    if (n < 10000000000000L) { \n                        return 13;\n                    } else {\n                        return 14;\n                    }\n                } else { // 15 or 16\n                    if (n < 1000000000000000L) {\n                        return 15;\n                    } else {\n                        return 16;\n                    }\n                }\n            } else { // from 17 to ...\u00bf20?\n                if (n < 1000000000000000000L) { // 17 or 18\n                    if (n < 100000000000000000L) {\n                        return 17;\n                    } else {\n                        return 18;\n                    }\n                } else { // 19? Can it be?\n                    // 10000000000000000000L is'nt a valid long.\n                    return 19;\n                }\n            }\n        }\n    }\n}\npublic static int numberOfDigits (long n) {     \n    // Guessing 4 digit numbers will be more probable.\n    // They are set in the first branch.\n    if (n < 10000L) { // from 1 to 4\n        if (n < 100L) { // 1 or 2\n            if (n < 10L) {\n                return 1;\n            } else {\n                return 2;\n            }\n        } else { // 3 or 4\n            if (n < 1000L) {\n                return 3;\n            } else {\n                return 4;\n            }\n        }           \n    } else  { // from 5 a 20 (albeit longs can't have more than 18 or 19)\n        if (n < 1000000000000L) { // from 5 to 12\n            if (n < 100000000L) { // from 5 to 8\n                if (n < 1000000L) { // 5 or 6\n                    if (n < 100000L) {\n                        return 5;\n                    } else {\n                        return 6;\n                    }\n                } else { // 7 u 8\n                    if (n < 10000000L) {\n                        return 7;\n                    } else {\n                        return 8;\n                    }\n                }\n            } else { // from 9 to 12\n                if (n < 10000000000L) { // 9 or 10\n                    if (n < 1000000000L) {\n                        return 9;\n                    } else {\n                        return 10;\n                    }\n                } else { // 11 or 12\n                    if (n < 100000000000L) {\n                        return 11;\n                    } else {\n                        return 12;\n                    }\n                }\n            }\n        } else { // from 13 to ... (18 or 20)\n            if (n < 10000000000000000L) { // from 13 to 16\n                if (n < 100000000000000L) { // 13 or 14\n                    if (n < 10000000000000L) { \n                        return 13;\n                    } else {\n                        return 14;\n                    }\n                } else { // 15 or 16\n                    if (n < 1000000000000000L) {\n                        return 15;\n                    } else {\n                        return 16;\n                    }\n                }\n            } else { // from 17 to ...\u00bf20?\n                if (n < 1000000000000000000L) { // 17 or 18\n                    if (n < 100000000000000000L) {\n                        return 17;\n                    } else {\n                        return 18;\n                    }\n                } else { // 19? Can it be?\n                    // 10000000000000000000L is'nt a valid long.\n                    return 19;\n                }\n            }\n        }\n    }\n}\n",
                "How about plain old Mathematics? Divide by 10 until you reach 0.public static int getSize(long number) {\n        int count = 0;\n        while (number > 0) {\n            count += 1;\n            number = (number / 10);\n        }\n        return count;\n    }\npublic static int getSize(long number) {\n        int count = 0;\n        while (number > 0) {\n            count += 1;\n            number = (number / 10);\n        }\n        return count;\n    }\n",
                "I see people using String libraries or even using the Integer class. Nothing wrong with that but the algorithm for getting the number of digits is not that complicated. I am using a long in this example but it works just as fine with an int.  private static int getLength(long num) {\n\n    int count = 1;\n\n    while (num >= 10) {\n        num = num / 10;\n        count++;\n    }\n\n    return count;\n}\n private static int getLength(long num) {\n\n    int count = 1;\n\n    while (num >= 10) {\n        num = num / 10;\n        count++;\n    }\n\n    return count;\n}\n",
                "Can I try? ;)based on Dirk's solutionfinal int digits = number==0?1:(1 + (int)Math.floor(Math.log10(Math.abs(number))));\nfinal int digits = number==0?1:(1 + (int)Math.floor(Math.log10(Math.abs(number))));\n",
                "Marian's Solution, now with Ternary: public int len(int n){\n        return (n<100000)?((n<100)?((n<10)?1:2):(n<1000)?3:((n<10000)?4:5)):((n<10000000)?((n<1000000)?6:7):((n<100000000)?8:((n<1000000000)?9:10)));\n    }\n public int len(int n){\n        return (n<100000)?((n<100)?((n<10)?1:2):(n<1000)?3:((n<10000)?4:5)):((n<10000000)?((n<1000000)?6:7):((n<100000000)?8:((n<1000000000)?9:10)));\n    }\nBecause we can.BecauseBecause",
                "no String API, no utils, no type conversion, just pure java iteration ->public static int getNumberOfDigits(int input) {\n    int numOfDigits = 1;\n    int base = 1;\n    while (input >= base * 10) {\n        base = base * 10;\n        numOfDigits++;\n    }\n    return numOfDigits;\n }\npublic static int getNumberOfDigits(int input) {\n    int numOfDigits = 1;\n    int base = 1;\n    while (input >= base * 10) {\n        base = base * 10;\n        numOfDigits++;\n    }\n    return numOfDigits;\n }\nYou can go long for bigger values if you please.",
                "Curious, I tried to benchmark it ... import org.junit.Test;\nimport static org.junit.Assert.*;\n\n\npublic class TestStack1306727 {\n\n    @Test\n    public void bench(){\n        int number=1000;\n        int a= String.valueOf(number).length();\n        int b= 1 + (int)Math.floor(Math.log10(number));\n\n        assertEquals(a,b);\n        int i=0;\n        int s=0;\n        long startTime = System.currentTimeMillis();\n        for(i=0, s=0; i< 100000000; i++){\n            a= String.valueOf(number).length();\n            s+=a;\n        }\n        long stopTime = System.currentTimeMillis();\n        long runTime = stopTime - startTime;\n        System.out.println(\"Run time 1: \" + runTime);\n        System.out.println(\"s: \"+s);\n        startTime = System.currentTimeMillis();\n        for(i=0,s=0; i< 100000000; i++){\n            b= number==0?1:(1 + (int)Math.floor(Math.log10(Math.abs(number))));\n            s+=b;\n        }\n        stopTime = System.currentTimeMillis();\n        runTime = stopTime - startTime;\n        System.out.println(\"Run time 2: \" + runTime);\n        System.out.println(\"s: \"+s);\n        assertEquals(a,b);\n\n\n    }\n}\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n\npublic class TestStack1306727 {\n\n    @Test\n    public void bench(){\n        int number=1000;\n        int a= String.valueOf(number).length();\n        int b= 1 + (int)Math.floor(Math.log10(number));\n\n        assertEquals(a,b);\n        int i=0;\n        int s=0;\n        long startTime = System.currentTimeMillis();\n        for(i=0, s=0; i< 100000000; i++){\n            a= String.valueOf(number).length();\n            s+=a;\n        }\n        long stopTime = System.currentTimeMillis();\n        long runTime = stopTime - startTime;\n        System.out.println(\"Run time 1: \" + runTime);\n        System.out.println(\"s: \"+s);\n        startTime = System.currentTimeMillis();\n        for(i=0,s=0; i< 100000000; i++){\n            b= number==0?1:(1 + (int)Math.floor(Math.log10(Math.abs(number))));\n            s+=b;\n        }\n        stopTime = System.currentTimeMillis();\n        runTime = stopTime - startTime;\n        System.out.println(\"Run time 2: \" + runTime);\n        System.out.println(\"s: \"+s);\n        assertEquals(a,b);\n\n\n    }\n}\nthe results are :\nRun time 1: 6765\ns: 400000000\nRun time 2: 6000\ns: 400000000\nNow I am left to wonder if my benchmark actually means something but I do get consistent results (variations within a ms) over multiple runs of the benchmark itself ... :) It looks like it's useless to try and optimize this... edit: following ptomli's comment, I replaced 'number' by 'i' in the code above and got the following results over 5 runs of the bench : \nRun time 1: 11500\ns: 788888890\nRun time 2: 8547\ns: 788888890\n\nRun time 1: 11485\ns: 788888890\nRun time 2: 8547\ns: 788888890\n\nRun time 1: 11469\ns: 788888890\nRun time 2: 8547\ns: 788888890\n\nRun time 1: 11500\ns: 788888890\nRun time 2: 8547\ns: 788888890\n\nRun time 1: 11484\ns: 788888890\nRun time 2: 8547\ns: 788888890\n",
                "With design (based on problem).  This is an alternate of divide-and-conquer.  We'll first define an enum (considering it's only for an unsigned int).public enum IntegerLength {\n    One((byte)1,10),\n    Two((byte)2,100),\n    Three((byte)3,1000),\n    Four((byte)4,10000),\n    Five((byte)5,100000),\n    Six((byte)6,1000000),\n    Seven((byte)7,10000000),\n    Eight((byte)8,100000000),\n    Nine((byte)9,1000000000);\n\n    byte length;\n    int value;\n\n    IntegerLength(byte len,int value) {\n        this.length = len;\n        this.value = value;\n    }\n\n    public byte getLenght() {\n        return length;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\npublic enum IntegerLength {\n    One((byte)1,10),\n    Two((byte)2,100),\n    Three((byte)3,1000),\n    Four((byte)4,10000),\n    Five((byte)5,100000),\n    Six((byte)6,1000000),\n    Seven((byte)7,10000000),\n    Eight((byte)8,100000000),\n    Nine((byte)9,1000000000);\n\n    byte length;\n    int value;\n\n    IntegerLength(byte len,int value) {\n        this.length = len;\n        this.value = value;\n    }\n\n    public byte getLenght() {\n        return length;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\nNow we'll define a class that goes through the values of the enum and compare and return the appropriate length.public class IntegerLenght {\n    public static byte calculateIntLenght(int num) {    \n        for(IntegerLength v : IntegerLength.values()) {\n            if(num < v.getValue()){\n                return v.getLenght();\n            }\n        }\n        return 0;\n    }\n}\npublic class IntegerLenght {\n    public static byte calculateIntLenght(int num) {    \n        for(IntegerLength v : IntegerLength.values()) {\n            if(num < v.getValue()){\n                return v.getLenght();\n            }\n        }\n        return 0;\n    }\n}\nThe run time of this solution is the same as the divide-and-conquer approach.",
                "What about this recursive method?    private static int length = 0;\n\n    public static int length(int n) {\n    length++;\n    if((n / 10) < 10) {\n        length++;\n    } else {\n        length(n / 10);\n    }\n    return length;\n}\n    private static int length = 0;\n\n    public static int length(int n) {\n    length++;\n    if((n / 10) < 10) {\n        length++;\n    } else {\n        length(n / 10);\n    }\n    return length;\n}\n",
                "simple solution:public class long_length {\n    long x,l=1,n;\n    for (n=10;n<x;n*=10){\n        if (x/n!=0){\n            l++;\n        }\n    }\n    System.out.print(l);\n}\npublic class long_length {\n    long x,l=1,n;\n    for (n=10;n<x;n*=10){\n        if (x/n!=0){\n            l++;\n        }\n    }\n    System.out.print(l);\n}\n",
                "A really simple solution:public int numLength(int n) {\n  for (int length = 1; n % Math.pow(10, length) != n; length++) {}\n  return length;\n}\npublic int numLength(int n) {\n  for (int length = 1; n % Math.pow(10, length) != n; length++) {}\n  return length;\n}\n",
                "Or instead the length you can check if the number is larger or smaller then the desired number.    public void createCard(int cardNumber, int cardStatus, int customerId) throws SQLException {\n    if(cardDao.checkIfCardExists(cardNumber) == false) {\n        if(cardDao.createCard(cardNumber, cardStatus, customerId) == true) {\n            System.out.println(\"Card created successfully\");\n        } else {\n\n        }\n    } else {\n        System.out.println(\"Card already exists, try with another Card Number\");\n        do {\n            System.out.println(\"Enter your new Card Number: \");\n            scan = new Scanner(System.in);\n            int inputCardNumber = scan.nextInt();\n            cardNumber = inputCardNumber;\n        } while(cardNumber < 95000000);\n        cardDao.createCard(cardNumber, cardStatus, customerId);\n    }\n}\n    public void createCard(int cardNumber, int cardStatus, int customerId) throws SQLException {\n    if(cardDao.checkIfCardExists(cardNumber) == false) {\n        if(cardDao.createCard(cardNumber, cardStatus, customerId) == true) {\n            System.out.println(\"Card created successfully\");\n        } else {\n\n        }\n    } else {\n        System.out.println(\"Card already exists, try with another Card Number\");\n        do {\n            System.out.println(\"Enter your new Card Number: \");\n            scan = new Scanner(System.in);\n            int inputCardNumber = scan.nextInt();\n            cardNumber = inputCardNumber;\n        } while(cardNumber < 95000000);\n        cardDao.createCard(cardNumber, cardStatus, customerId);\n    }\n}\n}",
                "I haven't seen a multiplication-based solution yet. Logarithm, divison, and string-based solutions will become rather unwieldy against millions of test cases, so here's one for ints:ints/**\n * Returns the number of digits needed to represents an {@code int} value in \n * the given radix, disregarding any sign.\n */\npublic static int len(int n, int radix) {\n    radixCheck(radix); \n    // if you want to establish some limitation other than radix > 2\n    n = Math.abs(n);\n\n    int len = 1;\n    long min = radix - 1;\n\n    while (n > min) {\n        n -= min;\n        min *= radix;\n        len++;\n    }\n\n    return len;\n}\n/**\n * Returns the number of digits needed to represents an {@code int} value in \n * the given radix, disregarding any sign.\n */\npublic static int len(int n, int radix) {\n    radixCheck(radix); \n    // if you want to establish some limitation other than radix > 2\n    n = Math.abs(n);\n\n    int len = 1;\n    long min = radix - 1;\n\n    while (n > min) {\n        n -= min;\n        min *= radix;\n        len++;\n    }\n\n    return len;\n}\nIn base 10, this works because n is essentially being compared to 9, 99, 999... as min is 9, 90, 900... and n is being subtracted by 9, 90, 900... Unfortunately, this is not portable to long just by replacing every instance of int due to overflow. On the other hand, it just so happens it will work for bases 2 and 10 (but badly fails for most of the other bases). You'll need a lookup table for the overflow points (or a division test... ew)longintwill/**\n * For radices 2 &le r &le Character.MAX_VALUE (36)\n */\nprivate static long[] overflowpt = {-1, -1, 4611686018427387904L,\n    8105110306037952534L, 3458764513820540928L, 5960464477539062500L,\n    3948651115268014080L, 3351275184499704042L, 8070450532247928832L,\n    1200757082375992968L, 9000000000000000000L, 5054470284992937710L,\n    2033726847845400576L, 7984999310198158092L, 2022385242251558912L,\n    6130514465332031250L, 1080863910568919040L, 2694045224950414864L,\n    6371827248895377408L, 756953702320627062L, 1556480000000000000L,\n    3089447554782389220L, 5939011215544737792L, 482121737504447062L,\n    839967991029301248L, 1430511474609375000L, 2385723916542054400L,\n    3902460517721977146L, 6269893157408735232L, 341614273439763212L,\n    513726300000000000L, 762254306892144930L, 1116892707587883008L,\n    1617347408439258144L, 2316231840055068672L, 3282671350683593750L,\n    4606759634479349760L};\n\npublic static int len(long n, int radix) {\n    radixCheck(radix);\n    n = abs(n);\n\n    int len = 1;\n    long min = radix - 1;\n    while (n > min) {\n        len++;\n        if (min == overflowpt[radix]) break;\n        n -= min;\n        min *= radix;\n\n    }\n\n    return len;\n}\n/**\n * For radices 2 &le r &le Character.MAX_VALUE (36)\n */\nprivate static long[] overflowpt = {-1, -1, 4611686018427387904L,\n    8105110306037952534L, 3458764513820540928L, 5960464477539062500L,\n    3948651115268014080L, 3351275184499704042L, 8070450532247928832L,\n    1200757082375992968L, 9000000000000000000L, 5054470284992937710L,\n    2033726847845400576L, 7984999310198158092L, 2022385242251558912L,\n    6130514465332031250L, 1080863910568919040L, 2694045224950414864L,\n    6371827248895377408L, 756953702320627062L, 1556480000000000000L,\n    3089447554782389220L, 5939011215544737792L, 482121737504447062L,\n    839967991029301248L, 1430511474609375000L, 2385723916542054400L,\n    3902460517721977146L, 6269893157408735232L, 341614273439763212L,\n    513726300000000000L, 762254306892144930L, 1116892707587883008L,\n    1617347408439258144L, 2316231840055068672L, 3282671350683593750L,\n    4606759634479349760L};\n\npublic static int len(long n, int radix) {\n    radixCheck(radix);\n    n = abs(n);\n\n    int len = 1;\n    long min = radix - 1;\n    while (n > min) {\n        len++;\n        if (min == overflowpt[radix]) break;\n        n -= min;\n        min *= radix;\n\n    }\n\n    return len;\n}\n",
                "One wants to do this mostly because he/she wants to \"present\" it, which mostly mean it finally needs to be \"toString-ed\" (or transformed in another way) explicitly or implicitly anyway; before it can be presented (printed for example). If that is the case then just try to make the necessary \"toString\" explicit and count the bits.One wants to do this mostly because he/she wants to \"present\" it, which mostly mean it finally needs to be \"toString-ed\" (or transformed in another way) explicitly or implicitly anyway; before it can be presented (printed for example). If that is the case then just try to make the necessary \"toString\" explicit and count the bits.",
                "We can achieve this using a recursive loop    public static int digitCount(int numberInput, int i) {\n        while (numberInput > 0) {\n        i++;\n        numberInput = numberInput / 10;\n        digitCount(numberInput, i);\n        }\n        return i;\n    }\n\n    public static void printString() {\n        int numberInput = 1234567;\n        int digitCount = digitCount(numberInput, 0);\n\n        System.out.println(\"Count of digit in [\"+numberInput+\"] is [\"+digitCount+\"]\");\n    }\n    public static int digitCount(int numberInput, int i) {\n        while (numberInput > 0) {\n        i++;\n        numberInput = numberInput / 10;\n        digitCount(numberInput, i);\n        }\n        return i;\n    }\n\n    public static void printString() {\n        int numberInput = 1234567;\n        int digitCount = digitCount(numberInput, 0);\n\n        System.out.println(\"Count of digit in [\"+numberInput+\"] is [\"+digitCount+\"]\");\n    }\n",
                "I wrote this function after looking Integer.java source code.Integer.javaprivate static int stringSize(int x) {\n    final int[] sizeTable = {9, 99, 999, 9_999, 99_999, 999_999, 9_999_999,\n            99_999_999, 999_999_999, Integer.MAX_VALUE};\n    for (int i = 0; ; ++i) {\n        if (x <= sizeTable[i]) {\n            return i + 1;\n        }\n    }\n}\nprivate static int stringSize(int x) {\n    final int[] sizeTable = {9, 99, 999, 9_999, 99_999, 999_999, 9_999_999,\n            99_999_999, 999_999_999, Integer.MAX_VALUE};\n    for (int i = 0; ; ++i) {\n        if (x <= sizeTable[i]) {\n            return i + 1;\n        }\n    }\n}\n",
                "One of the efficient ways to count the number of digits in an int variable would be to define a method digitsCounter with a required number of conditional statements.\nThe approach is simple, we will be checking for each range in which a n digit number can lie:\n0 : 9 are Single digit numbers\n10 : 99 are Double digit numbers\n100 : 999 are Triple digit numbers and so on...intdigitsCountern0 : 9Single10 : 99Double100 : 999Triple    static int digitsCounter(int N)\n    {   // N = Math.abs(N); // if `N` is -ve\n        if (0 <= N && N <= 9) return 1;\n        if (10 <= N && N <= 99) return 2;\n        if (100 <= N && N <= 999) return 3;\n        if (1000 <= N && N <= 9999) return 4;\n        if (10000 <= N && N <= 99999) return 5;\n        if (100000 <= N && N <= 999999) return 6;\n        if (1000000 <= N && N <= 9999999) return 7;\n        if (10000000 <= N && N <= 99999999) return 8;\n        if (100000000 <= N && N <= 999999999) return 9;\n        return 10;\n    }\n    static int digitsCounter(int N)\n    {   // N = Math.abs(N); // if `N` is -ve\n        if (0 <= N && N <= 9) return 1;\n        if (10 <= N && N <= 99) return 2;\n        if (100 <= N && N <= 999) return 3;\n        if (1000 <= N && N <= 9999) return 4;\n        if (10000 <= N && N <= 99999) return 5;\n        if (100000 <= N && N <= 999999) return 6;\n        if (1000000 <= N && N <= 9999999) return 7;\n        if (10000000 <= N && N <= 99999999) return 8;\n        if (100000000 <= N && N <= 999999999) return 9;\n        return 10;\n    }\n\nA cleaner way to do this is to remove the check for the lower limits as it won't be required if we proceed in a sequential manner.\n    static int digitsCounter(int N)\n    {\n        N = N < 0 ? -N : N;\n        if (N <= 9) return 1;\n        if (N <= 99) return 2;\n        if (N <= 999) return 3;\n        if (N <= 9999) return 4;\n        if (N <= 99999) return 5;\n        if (N <= 999999) return 6;\n        if (N <= 9999999) return 7;\n        if (N <= 99999999) return 8;\n        if (N <= 999999999) return 9;\n        return 10; // Max possible digits in an 'int'\n    }\n\nA cleaner way to do this is to remove the check for the lower limits as it won't be required if we proceed in a sequential manner.    static int digitsCounter(int N)\n    {\n        N = N < 0 ? -N : N;\n        if (N <= 9) return 1;\n        if (N <= 99) return 2;\n        if (N <= 999) return 3;\n        if (N <= 9999) return 4;\n        if (N <= 99999) return 5;\n        if (N <= 999999) return 6;\n        if (N <= 9999999) return 7;\n        if (N <= 99999999) return 8;\n        if (N <= 999999999) return 9;\n        return 10; // Max possible digits in an 'int'\n    }\n    static int digitsCounter(int N)\n    {\n        N = N < 0 ? -N : N;\n        if (N <= 9) return 1;\n        if (N <= 99) return 2;\n        if (N <= 999) return 3;\n        if (N <= 9999) return 4;\n        if (N <= 99999) return 5;\n        if (N <= 999999) return 6;\n        if (N <= 9999999) return 7;\n        if (N <= 99999999) return 8;\n        if (N <= 999999999) return 9;\n        return 10; // Max possible digits in an 'int'\n    }\n",
                "Ideally, an integer divided by 10 multiple times will return the number of digits as long as the integer is not zero. As such a simple method to do so can be created as below.public static int getNumberOfDigits(int number) {\n    int numberOfDigits = 0;                \n    while(number != 0) {\n        number /= 10;\n        numberOfDigits++;\n    }\n    \n    return numberOfDigits;\n}\npublic static int getNumberOfDigits(int number) {\n    int numberOfDigits = 0;                \n    while(number != 0) {\n        number /= 10;\n        numberOfDigits++;\n    }\n    \n    return numberOfDigits;\n}\n",
                "It depends on what you mean by \"neat\".  I think the following code is fairly neat, and it runs fast.It is based on Marian's answer, extended to work with all long values and rendered using the ? : operator.Marian'sanswerlong? :private static long[] DIGITS = { 1l,\n                                 10l,\n                                 100l,\n                                 1000l,\n                                 10000l,\n                                 100000l,\n                                 1000000l,\n                                 10000000l,\n                                 100000000l,\n                                 1000000000l,\n                                 10000000000l,\n                                 100000000000l,\n                                 1000000000000l,\n                                 10000000000000l,\n                                 100000000000000l,\n                                 1000000000000000l,\n                                 10000000000000000l,\n                                 100000000000000000l,\n                                 1000000000000000000l };\n\npublic static int numberOfDigits(final long n)\n{\n    return n == Long.MIN_VALUE ? 19 : n < 0l ? numberOfDigits(-n) :\n            n < DIGITS[8] ? // 1-8\n              n < DIGITS[4] ? // 1-4\n                n < DIGITS[2] ? // 1-2\n                  n < DIGITS[1] ? 1 : 2 : // 1-2\n                        n < DIGITS[3] ? 3 : 4 : // 3-4\n                      n < DIGITS[6] ? // 5-8\n                        n < DIGITS[5] ? 5 : 6 : // 5-6\n                      n < DIGITS[7] ? 7 : 8 : // 7-8\n            n < DIGITS[16] ? // 9-16\n              n < DIGITS[12] ? // 9-12\n                n < DIGITS[10] ? // 9-10\n                  n < DIGITS[9] ? 9 : 10 : // 9-10\n                        n < DIGITS[11] ? 11 : 12 : // 11-12\n                      n < DIGITS[14] ? // 13-16\n                        n < DIGITS[13] ? 13 : 14 : // 13-14\n                      n < DIGITS[15] ? 15 : 16 : // 15-16\n            n < DIGITS[17] ? 17 :  // 17-19\n            n < DIGITS[18] ? 18 :\n            19;\n}\nprivate static long[] DIGITS = { 1l,\n                                 10l,\n                                 100l,\n                                 1000l,\n                                 10000l,\n                                 100000l,\n                                 1000000l,\n                                 10000000l,\n                                 100000000l,\n                                 1000000000l,\n                                 10000000000l,\n                                 100000000000l,\n                                 1000000000000l,\n                                 10000000000000l,\n                                 100000000000000l,\n                                 1000000000000000l,\n                                 10000000000000000l,\n                                 100000000000000000l,\n                                 1000000000000000000l };\n\npublic static int numberOfDigits(final long n)\n{\n    return n == Long.MIN_VALUE ? 19 : n < 0l ? numberOfDigits(-n) :\n            n < DIGITS[8] ? // 1-8\n              n < DIGITS[4] ? // 1-4\n                n < DIGITS[2] ? // 1-2\n                  n < DIGITS[1] ? 1 : 2 : // 1-2\n                        n < DIGITS[3] ? 3 : 4 : // 3-4\n                      n < DIGITS[6] ? // 5-8\n                        n < DIGITS[5] ? 5 : 6 : // 5-6\n                      n < DIGITS[7] ? 7 : 8 : // 7-8\n            n < DIGITS[16] ? // 9-16\n              n < DIGITS[12] ? // 9-12\n                n < DIGITS[10] ? // 9-10\n                  n < DIGITS[9] ? 9 : 10 : // 9-10\n                        n < DIGITS[11] ? 11 : 12 : // 11-12\n                      n < DIGITS[14] ? // 13-16\n                        n < DIGITS[13] ? 13 : 14 : // 13-14\n                      n < DIGITS[15] ? 15 : 16 : // 15-16\n            n < DIGITS[17] ? 17 :  // 17-19\n            n < DIGITS[18] ? 18 :\n            19;\n}\n",
                "Here is what such solution looks from the JDK developers. This is JDK 17 (class Long):Long/**\n * Returns the string representation size for a given long value.\n *\n * @param x long value\n * @return string size\n *\n * @implNote There are other ways to compute this: e.g. binary search,\n * but values are biased heavily towards zero, and therefore linear search\n * wins. The iteration results are also routinely inlined in the generated\n * code after loop unrolling.\n */\nstatic int stringSize(long x) {\n    int d = 1;\n    if (x >= 0) {\n        d = 0;\n        x = -x;\n    }\n    long p = -10;\n    for (int i = 1; i < 19; i++) {\n        if (x > p)\n            return i + d;\n        p = 10 * p;\n    }\n    return 19 + d;\n}\n/**\n * Returns the string representation size for a given long value.\n *\n * @param x long value\n * @return string size\n *\n * @implNote There are other ways to compute this: e.g. binary search,\n * but values are biased heavily towards zero, and therefore linear search\n * wins. The iteration results are also routinely inlined in the generated\n * code after loop unrolling.\n */\nstatic int stringSize(long x) {\n    int d = 1;\n    if (x >= 0) {\n        d = 0;\n        x = -x;\n    }\n    long p = -10;\n    for (int i = 1; i < 19; i++) {\n        if (x > p)\n            return i + d;\n        p = 10 * p;\n    }\n    return 19 + d;\n}\nNote that the method takes into account a minus sign, if necessary.Unfortunately the method is not exposed.In terms of performance you can see from the comments that the JDK developer has at least given this some thought compared to alternatives. I would guess that\na divide-and-conquer method skewed toward lower numbers would perform slightly\nbetter, because the CPU can do integer comparisons a bit faster than integer\nmultiplications. But the difference may so small that it is not measurable.In any case, I wish this method had been exposed in the JDK so that people would not start rolling their own method.",
                "Here's a really simple method I made that works for any number: public static int numberLength(int userNumber) {\n\n    int numberCounter = 10;\n    boolean condition = true;\n    int digitLength = 1;\n\n    while (condition) {\n        int numberRatio = userNumber / numberCounter;\n        if (numberRatio < 1) {\n            condition = false;\n        } else {\n            digitLength++;\n            numberCounter *= 10;\n        }\n    }\n\n    return digitLength; \n}\npublic static int numberLength(int userNumber) {\n\n    int numberCounter = 10;\n    boolean condition = true;\n    int digitLength = 1;\n\n    while (condition) {\n        int numberRatio = userNumber / numberCounter;\n        if (numberRatio < 1) {\n            condition = false;\n        } else {\n            digitLength++;\n            numberCounter *= 10;\n        }\n    }\n\n    return digitLength; \n}\nThe way it works is with the number counter variable is that 10 = 1 digit space. For example .1 = 1 tenth => 1 digit space. Therefore if you have int number = 103342; you'll get 6, because that's the equivalent of .000001 spaces back. Also, does anyone have a better variable name for numberCounter? I can't think of anything better. int number = 103342;numberCounterEdit: Just thought of a better explanation. Essentially what this while loop is doing is making it so you divide your number by 10, until it's less than one. Essentially, when you divide something by 10 you're moving it back one number space, so you simply divide it by 10 until you reach <1 for the amount of digits in your number. Here's another version that can count the amount of numbers in a decimal: public static int repeatingLength(double decimalNumber) {\n\n    int numberCounter = 1;\n    boolean condition = true;\n    int digitLength = 1;\n\n    while (condition) {\n        double numberRatio = decimalNumber * numberCounter;\n\n        if ((numberRatio - Math.round(numberRatio)) < 0.0000001) {\n            condition = false;\n        } else {\n            digitLength++;\n            numberCounter *= 10;\n        }\n    }\n    return digitLength - 1;\n}\npublic static int repeatingLength(double decimalNumber) {\n\n    int numberCounter = 1;\n    boolean condition = true;\n    int digitLength = 1;\n\n    while (condition) {\n        double numberRatio = decimalNumber * numberCounter;\n\n        if ((numberRatio - Math.round(numberRatio)) < 0.0000001) {\n            condition = false;\n        } else {\n            digitLength++;\n            numberCounter *= 10;\n        }\n    }\n    return digitLength - 1;\n}\n"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "How do I convert all strings in a list of lists to integers?",
                "how do i convert the entire string to the integer in a list?",
                "how do i convert a string in a list to integer?",
                "how can i convert all strings in a list to integers?",
                "how can you convert all strings in a list of lists to integers?",
                "how do i convert strings in a list of lists to integers?",
                "how do i convert a string in a list of lists to integers?",
                "how do i convert all strings in a list of lists to integers?"
            ],
            "responses": [
                "int() is the Python standard built-in function to convert a string into an integer value. You call it with a string containing a number as the argument, and it returns the number converted to an integer:int()int()>>> int(\"1\") + 1\n2\n>>> int(\"1\") + 1\n2\nIf you know the structure of your list, T1 (that it simply contains lists, only one level), you could do this in Python 3:T2 = [list(map(int, x)) for x in T1]\nT2 = [list(map(int, x)) for x in T1]\nIn Python 2:T2 = [map(int, x) for x in T1]\nT2 = [map(int, x) for x in T1]\n",
                "You can do this with a list comprehension:T2 = [[int(column) for column in row] for row in T1]\nT2 = [[int(column) for column in row] for row in T1]\nThe inner list comprehension ([int(column) for column in row]) builds a list of ints from a sequence of int-able objects, like decimal strings, in row. The outer list comprehension ([... for row in T1])) builds a list of the results of the inner list comprehension applied to each item in T1.[int(column) for column in row]listintintrow[... for row in T1])T1The code snippet will fail if any of the rows contain objects that can't be converted by int. You'll need a smarter function if you want to process rows containing non-decimal strings.intIf you know the structure of the rows, you can replace the inner list comprehension with a call to a function of the row. Eg.T2 = [parse_a_row_of_T1(row) for row in T1]\nT2 = [parse_a_row_of_T1(row) for row in T1]\n",
                "Using only list comprehensions:[[int(y) for y in x] for x in T1]\n[[int(y) for y in x] for x in T1]\n",
                "Instead of putting int( ), put float( ) which will let you use decimals along with integers.int( )float( )",
                "I would agree with everyone\u2019s answers so far but the problem is that if you do not have all integers, they will crash.If you wanted to exclude non-integers thenT1 = (('13', '17', '18', '21', '32'),\n      ('07', '11', '13', '14', '28'),\n      ('01', '05', '06', '08', '15', '16'))\nnew_list = list(list(int(a) for a in b) for b in T1 if a.isdigit())\nT1 = (('13', '17', '18', '21', '32'),\n      ('07', '11', '13', '14', '28'),\n      ('01', '05', '06', '08', '15', '16'))\nnew_list = list(list(int(a) for a in b) for b in T1 if a.isdigit())\nThis yields only actual digits.  The reason I don't use direct list comprehensions is because list comprehension leaks their internal variables.",
                "Try this.x = \"1\"\nx = \"1\"\nx is a string because it has quotes around it, but it has a number in it.x = int(x)\nx = int(x)\nSince x has the number 1 in it, I can turn it in to a integer.To see if a string is a number, you can do this.def is_number(var):\n    try:\n        if var == int(var):\n            return True\n    except Exception:\n        return False\n\nx = \"1\"\n\ny = \"test\"\n\nx_test = is_number(x)\n\nprint(x_test)\ndef is_number(var):\n    try:\n        if var == int(var):\n            return True\n    except Exception:\n        return False\n\nx = \"1\"\n\ny = \"test\"\n\nx_test = is_number(x)\n\nprint(x_test)\nIt should print to IDLE True because x is a number.y_test = is_number(y)\n\nprint(y_test)\ny_test = is_number(y)\n\nprint(y_test)\nIt should print to IDLE False because y in not a number.",
                "T3=[]\n\nfor i in range(0,len(T1)):\n    T3.append([])\n    for j in range(0,len(T1[i])):\n        b=int(T1[i][j])\n        T3[i].append(b)\n\nprint T3\nT3=[]\n\nfor i in range(0,len(T1)):\n    T3.append([])\n    for j in range(0,len(T1[i])):\n        b=int(T1[i][j])\n        T3[i].append(b)\n\nprint T3\n",
                "Using list comprehensions:t2 = [map(int, list(l)) for l in t1]\nt2 = [map(int, list(l)) for l in t1]\n",
                "See this functiondef parse_int(s):\n    try:\n        res = int(eval(str(s)))\n        if type(res) == int:\n            return res\n    except:\n        return\ndef parse_int(s):\n    try:\n        res = int(eval(str(s)))\n        if type(res) == int:\n            return res\n    except:\n        return\nThenval = parse_int('10')  # Return 10\nval = parse_int('0')  # Return 0\nval = parse_int('10.5')  # Return 10\nval = parse_int('0.0')  # Return 0\nval = parse_int('Ten')  # Return None\nval = parse_int('10')  # Return 10\nval = parse_int('0')  # Return 0\nval = parse_int('10.5')  # Return 10\nval = parse_int('0.0')  # Return 0\nval = parse_int('Ten')  # Return None\nYou can also checkif val == None:  # True if input value can not be converted\n    pass  # Note: Don't use 'if not val:'\nif val == None:  # True if input value can not be converted\n    pass  # Note: Don't use 'if not val:'\n",
                "Yet another functional solution for Python 2:from functools import partial\n\nmap(partial(map, int), T1)\nfrom functools import partial\n\nmap(partial(map, int), T1)\nPython 3 will be a little bit messy though:list(map(list, map(partial(map, int), T1)))\nlist(map(list, map(partial(map, int), T1)))\nwe can fix this with a wrapperdef oldmap(f, iterable):\n    return list(map(f, iterable))\n\noldmap(partial(oldmap, int), T1)\ndef oldmap(f, iterable):\n    return list(map(f, iterable))\n\noldmap(partial(oldmap, int), T1)\n",
                "In Python 3.5.1 things like these work:c = input('Enter number:')\nprint (int(float(c)))\nprint (round(float(c)))\nc = input('Enter number:')\nprint (int(float(c)))\nprint (round(float(c)))\nandEnter number:  4.7\n4\n5\nEnter number:  4.7\n4\n5\n",
                "If it's only a tuple of tuples, something like rows=[map(int, row) for row in rows] will do the trick. (There's a list comprehension and a call to map(f, lst), which is equal to [f(a) for a in lst], in there.)rows=[map(int, row) for row in rows]Eval is not what you want to do, in case there's something like __import__(\"os\").unlink(\"importantsystemfile\") in your database for some reason.\nAlways validate your input (if with nothing else, the exception int() will raise if you have bad input).not__import__(\"os\").unlink(\"importantsystemfile\")",
                "Python has built in function int(string) and optional parameter base.if your string contains an Integer value, it will convert that to the corresponding Integer value.\nHowever if you have decimnal number as string you'll need float() to convert it.Usage:a = '22'\nb = int(a)\na = '22'\nb = int(a)\nandif a = '22.22'\nb = int(a) '''will give error, invalid literal for int().'''\nb = float(a) '''will convert the string.'''\nif a = '22.22'\nb = int(a) '''will give error, invalid literal for int().'''\nb = float(a) '''will convert the string.'''\n",
                "I want to share an available option that doesn't seem to be mentioned here yet:rumpy.random.permutation(x)\nrumpy.random.permutation(x)\nWill generate a random permutation of array x. Not exactly what you asked for, but it is a potential solution to similar questions.exactly",
                "You can do something like this:T1 = (('13', '17', '18', '21', '32'),  \n     ('07', '11', '13', '14', '28'),  \n     ('01', '05', '06', '08', '15', '16'))  \nnew_list = list(list(int(a) for a in b if a.isdigit()) for b in T1)  \nprint(new_list)  \nT1 = (('13', '17', '18', '21', '32'),  \n     ('07', '11', '13', '14', '28'),  \n     ('01', '05', '06', '08', '15', '16'))  \nnew_list = list(list(int(a) for a in b if a.isdigit()) for b in T1)  \nprint(new_list)  \n"
            ]
        },
        {
            "tag": "javascript",
            "patterns": [
                "Check if a number has a decimal place/is a whole number",
                "check if a number has a decimal place or is a whole number"
            ],
            "responses": [
                "Using modulus will work:modulusnum % 1 != 0\n// 23 % 1 = 0\n// 23.5 % 1 = 0.5\nnum % 1 != 0\n// 23 % 1 = 0\n// 23.5 % 1 = 0.5\nNote that this is based on the numerical value of the number, regardless of format. It treats numerical strings containing whole numbers with a fixed decimal point the same as integers:value'10.0' % 1; // returns 0\n10 % 1; // returns 0\n'10.5' % 1; // returns 0.5\n10.5 % 1; // returns 0.5\n'10.0' % 1; // returns 0\n10 % 1; // returns 0\n'10.5' % 1; // returns 0.5\n10.5 % 1; // returns 0.5\n",
                "Number.isInteger(23);  // true\nNumber.isInteger(1.5); // false\nNumber.isInteger(\"x\"); // false: \nNumber.isInteger(23);  // true\nNumber.isInteger(1.5); // false\nNumber.isInteger(\"x\"); // false: \nNumber.isInteger() is part of the ES6 standard and not supported in IE11.Number.isInteger()It returns false for NaN, Infinity and non-numeric arguments while x % 1 != 0 returns true.NaNInfinityx % 1 != 0",
                "Or you could just use this to find out if it is NOT a decimal:string.indexOf(\".\") == -1;\nstring.indexOf(\".\") == -1;\n",
                "Simple, but effective!Math.floor(number) === number;\nMath.floor(number) === number;\n",
                "The most common solution is to strip the integer portion of the number and compare it to zero like so:function Test()\n{\n     var startVal = 123.456\n     alert( (startVal - Math.floor(startVal)) != 0 )\n}\nfunction Test()\n{\n     var startVal = 123.456\n     alert( (startVal - Math.floor(startVal)) != 0 )\n}\n",
                "Number.isSafeInteger(value);\nNumber.isSafeInteger(value);\nIn JavaScript, isSafeInteger() is a Number method that is used to return a Boolean value indicating whether a value is a safe integer. This means that it is an integer value that can be exactly represented as an IEEE-754 double precision number without rounding.",
                "//How about byte-ing it?Number.prototype.isInt= function(){\n return this== this>> 0;\n}\nNumber.prototype.isInt= function(){\n return this== this>> 0;\n}\nI always feel kind of bad for bit operators in javascript- they hardly get any exercise.",
                "Number.isInteger() is probably the most concise. It returns true if it is an integer, and false if it isn't.Number.isInteger()",
                "number = 20.5\n\nif (number == Math.floor(number)) {\n\nalert(\"Integer\")\n\n} else {\n\nalert(\"Decimal\")\n\n}\nnumber = 20.5\n\nif (number == Math.floor(number)) {\n\nalert(\"Integer\")\n\n} else {\n\nalert(\"Decimal\")\n\n}\nPretty cool and works for things like XX.0 too!\nIt works because Math.floor() chops off any decimal if it has one so if the floor is different from the original number we know it is a decimal! And no string conversions :)",
                "var re=/^-?[0-9]+$/;\nvar num=10;\nre.test(num);\nvar re=/^-?[0-9]+$/;\nvar num=10;\nre.test(num);\n",
                "convert number string to array, split by decimal point. Then, if the array has only one value, that means no decimal in string.if(!number.split(\".\")[1]){\n    //do stuff\n}\nif(!number.split(\".\")[1]){\n    //do stuff\n}\nThis way you can also know what the integer and decimal actually are. a more advanced example would be.number_to_array = string.split(\".\");\ninte = number_to_array[0];\ndece = number_to_array[1]; \n\nif(!dece){\n    //do stuff\n}\nnumber_to_array = string.split(\".\");\ninte = number_to_array[0];\ndece = number_to_array[1]; \n\nif(!dece){\n    //do stuff\n}\n",
                "function isDecimal(n){\n    if(n == \"\")\n        return false;\n\n    var strCheck = \"0123456789\";\n    var i;\n\n    for(i in n){\n        if(strCheck.indexOf(n[i]) == -1)\n            return false;\n    }\n    return true;\n}\nfunction isDecimal(n){\n    if(n == \"\")\n        return false;\n\n    var strCheck = \"0123456789\";\n    var i;\n\n    for(i in n){\n        if(strCheck.indexOf(n[i]) == -1)\n            return false;\n    }\n    return true;\n}\n",
                "parseInt(num) === num\nparseInt(num) === num\nwhen passed a number, parseInt() just returns the number as int:parseInt()parseInt(3.3) === 3.3 // false because 3 !== 3.3\nparseInt(3) === 3     // true\nparseInt(3.3) === 3.3 // false because 3 !== 3.3\nparseInt(3) === 3     // true\n",
                "Use following if value is string (e.g. from <input):<inputMath.floor(value).toString() !== value\nMath.floor(value).toString() !== value\nI add .toString() to floor to make it work also for cases when value == \"1.\" (ends with decimal separator or another string). Also Math.floor always returns some value so .toString() never fails..toString()value == \"1.\"Math.floor.toString()",
                "Here's an excerpt from my guard library (inspired by Effective JavaScript by David Herman):var guard = {\n\n    guard: function(x) {\n        if (!this.test(x)) {\n            throw new TypeError(\"expected \" + this);\n        }\n    }\n\n    // ...\n};\n\n// ...\n\nvar number = Object.create(guard);\nnumber.test = function(x) {\n    return typeof x === \"number\" || x instanceof Number;\n};\nnumber.toString = function() {\n    return \"number\";\n};\n\n\nvar uint32 = Object.create(guard);\nuint32.test = function(x) {\n    return typeof x === \"number\" && x === (x >>> 0);\n};\nuint32.toString = function() {\n    return \"uint32\";\n};\n\n\nvar decimal = Object.create(guard);\ndecimal.test = function(x) {\n    return number.test(x) && !uint32.test(x);\n};\ndecimal.toString = function() {\n    return \"decimal\";\n};\n\n\nuint32.guard(1234);     // fine\nuint32.guard(123.4);    // TypeError: expected uint32\n\ndecimal.guard(1234);    // TypeError: expected decimal\ndecimal.guard(123.4);   // fine\nvar guard = {\n\n    guard: function(x) {\n        if (!this.test(x)) {\n            throw new TypeError(\"expected \" + this);\n        }\n    }\n\n    // ...\n};\n\n// ...\n\nvar number = Object.create(guard);\nnumber.test = function(x) {\n    return typeof x === \"number\" || x instanceof Number;\n};\nnumber.toString = function() {\n    return \"number\";\n};\n\n\nvar uint32 = Object.create(guard);\nuint32.test = function(x) {\n    return typeof x === \"number\" && x === (x >>> 0);\n};\nuint32.toString = function() {\n    return \"uint32\";\n};\n\n\nvar decimal = Object.create(guard);\ndecimal.test = function(x) {\n    return number.test(x) && !uint32.test(x);\n};\ndecimal.toString = function() {\n    return \"decimal\";\n};\n\n\nuint32.guard(1234);     // fine\nuint32.guard(123.4);    // TypeError: expected uint32\n\ndecimal.guard(1234);    // TypeError: expected decimal\ndecimal.guard(123.4);   // fine\n",
                "You can multiply it by 10 and then do a \"modulo\" operation/divison with 10, and check if result of that two operations is zero. Result of that two operations will give you first digit after the decimal point.\nIf result is equal to zero then the number is a whole number.multiply it by 10modulowith 10first digitif ( (int)(number * 10.0) % 10 == 0 ){\n// your code\n}\nif ( (int)(number * 10.0) % 10 == 0 ){\n// your code\n}\n",
                "function isDecimal(num) {\n  return (num !== parseInt(num, 10));\n}\nfunction isDecimal(num) {\n  return (num !== parseInt(num, 10));\n}\n",
                "You can use the bitwise operations that do not change the value (^ 0 or ~~) to discard the decimal part, which can be used for rounding. After rounding the number, it is compared to the original value:^ 0~~function isDecimal(num) {\n  return (num ^ 0) !== num;\n}\n\nconsole.log( isDecimal(1) ); // false\nconsole.log( isDecimal(1.5) ); // true\nconsole.log( isDecimal(-0.5) ); // true\nfunction isDecimal(num) {\n  return (num ^ 0) !== num;\n}\n\nconsole.log( isDecimal(1) ); // false\nconsole.log( isDecimal(1.5) ); // true\nconsole.log( isDecimal(-0.5) ); // true\n",
                "function isWholeNumber(num) {\n  return num === Math.round(num);\n}\nfunction isWholeNumber(num) {\n  return num === Math.round(num);\n}\n",
                "When using counters with decimal steps, checking if number is round will actually fail, as shown below. So it might be safest (although slow) to format the number with 9 (could be more) decimal places, and if it ends with 9 zeros, then it's a whole number.\n\nconst isRound = number => number.toFixed(9).endsWith('000000000');\n\nfor (let counter = 0; counter < 2; counter += 0.1) {\n  console.log({ counter, modulo: counter % 1, formatted: counter.toFixed(9), isRound: isRound(counter) });\n}\n\n\n\n\nconst isRound = number => number.toFixed(9).endsWith('000000000');\n\nfor (let counter = 0; counter < 2; counter += 0.1) {\n  console.log({ counter, modulo: counter % 1, formatted: counter.toFixed(9), isRound: isRound(counter) });\n}\n\n\nconst isRound = number => number.toFixed(9).endsWith('000000000');\n\nfor (let counter = 0; counter < 2; counter += 0.1) {\n  console.log({ counter, modulo: counter % 1, formatted: counter.toFixed(9), isRound: isRound(counter) });\n}\nconst isRound = number => number.toFixed(9).endsWith('000000000');\n\nfor (let counter = 0; counter < 2; counter += 0.1) {\n  console.log({ counter, modulo: counter % 1, formatted: counter.toFixed(9), isRound: isRound(counter) });\n}const isRound = number => number.toFixed(9).endsWith('000000000');\n\nfor (let counter = 0; counter < 2; counter += 0.1) {\n  console.log({ counter, modulo: counter % 1, formatted: counter.toFixed(9), isRound: isRound(counter) });\n}",
                "Perhaps this works for you?It uses regex to check if there is a comma in the number, and if there is not, then it will add the comma and stripe.var myNumber = '50';\nfunction addCommaStripe(text){\n    if(/,/.test(text) == false){\n        return text += ',-';\n    } else {\n        return text;\n    }\n}\nmyNumber = addCommaStripe(myNumber);\nvar myNumber = '50';\nfunction addCommaStripe(text){\n    if(/,/.test(text) == false){\n        return text += ',-';\n    } else {\n        return text;\n    }\n}\nmyNumber = addCommaStripe(myNumber);\n",
                "Function for check number is Decimal or whole numberfunction IsDecimalExist(p_decimalNumber) {\n    var l_boolIsExist = true;\n\n    if (p_decimalNumber % 1 == 0)\n        l_boolIsExist = false;\n\n    return l_boolIsExist;\n}\nfunction IsDecimalExist(p_decimalNumber) {\n    var l_boolIsExist = true;\n\n    if (p_decimalNumber % 1 == 0)\n        l_boolIsExist = false;\n\n    return l_boolIsExist;\n}\n"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "Java int to String - Integer.toString(i) vs new Integer(i).toString()"
            ],
            "responses": [
                "Integer.toString calls the static method in the class Integer. It does not need an instance of Integer.Integer.toStringInteger.toStringIntegerIntegerIntegerIf you call new Integer(i) you create an instance of type Integer, which is a full Java object encapsulating the value of your int. Then you call the toString method on it to ask it to return a string representation of itself.new Integer(i)new Integer(i)IntegertoStringitselfIf all you want is to print an int, you'd use the first one because it's lighter, faster and doesn't use extra memory (aside from the returned string).  intIf you want an object representing an integer value\u2014to put it inside a collection for example\u2014you'd use the second one, since it gives you a full-fledged object to do all sort of things that you cannot do with a bare int.int",
                "new Integer(i).toString() first creates a (redundant) wrapper object around i (which itself may be a wrapper object Integer).new Integer(i).toString()iIntegerInteger.toString(i) is preferred because it doesn't create any unnecessary objects.Integer.toString(i)",
                "Another option is the static String.valueOf method.String.valueOfString.valueOfString.valueOf(i)\nString.valueOf(i)\nIt feels slightly more right than Integer.toString(i) to me. When the type of i changes, for example from int to double, the code will stay correct.feelsInteger.toString(i)intdouble",
                "\nnew Integer(i).toString();\nThis statement creates the object of the Integer and then call its methods toString(i) to return the String representation of Integer's value.\n\nInteger.toString(i);\nIt returns the String object representing the specific int (integer), but here toString(int) is a static method.\n\nnew Integer(i).toString();\nThis statement creates the object of the Integer and then call its methods toString(i) to return the String representation of Integer's value.\nnew Integer(i).toString();new Integer(i).toString();This statement creates the object of the Integer and then call its methods toString(i) to return the String representation of Integer's value.toString(i)return the String representation of Integer's valueInteger.toString(i);\nIt returns the String object representing the specific int (integer), but here toString(int) is a static method.\nInteger.toString(i);Integer.toString(i);It returns the String object representing the specific int (integer), but here toString(int) is a static method.returns the String object representing the specific int (integer)toString(int)staticSummary is in first case it returns the objects string representation, where as in second case it returns the string representation of integer.",
                "I also highly recommend usingint integer = 42;\nString string = integer + \"\";\nint integer = 42;\nString string = integer + \"\";\nSimple and effective.",
                "Although I like fhucho's recommendation of String.valueOf(i)\nString.valueOf(i)\nThe irony is that this method actually calls Integer.toString(i)\nInteger.toString(i)\nThus, use String.valueOf(i) if you like how it reads and you don't need radix, but also knowing that it is less efficient than Integer.toString(i).String.valueOf(i)Integer.toString(i)",
                "In terms of performance measurement, if you are considering the time performance then the Integer.toString(i); is expensive if you are calling less than 100 million times. Else if it is more than 100 million calls then the new Integer(10).toString() will perform better.Integer.toString(i);new Integer(10).toString()Below is the code through u can try to measure the performance,public static void main(String args[]) {\n            int MAX_ITERATION = 10000000;\n        long starttime = System.currentTimeMillis();\n        for (int i = 0; i < MAX_ITERATION; ++i) {\n            String s = Integer.toString(10);\n        }\n        long endtime = System.currentTimeMillis();\n        System.out.println(\"diff1: \" + (endtime-starttime));\n\n        starttime = System.currentTimeMillis();\n        for (int i = 0; i < MAX_ITERATION; ++i) {\n            String s1 = new Integer(10).toString();\n        }\n        endtime = System.currentTimeMillis();\n        System.out.println(\"diff2: \" + (endtime-starttime));\n    }\npublic static void main(String args[]) {\n            int MAX_ITERATION = 10000000;\n        long starttime = System.currentTimeMillis();\n        for (int i = 0; i < MAX_ITERATION; ++i) {\n            String s = Integer.toString(10);\n        }\n        long endtime = System.currentTimeMillis();\n        System.out.println(\"diff1: \" + (endtime-starttime));\n\n        starttime = System.currentTimeMillis();\n        for (int i = 0; i < MAX_ITERATION; ++i) {\n            String s1 = new Integer(10).toString();\n        }\n        endtime = System.currentTimeMillis();\n        System.out.println(\"diff2: \" + (endtime-starttime));\n    }\nIn terms of memory, the \nnew Integer(i).toString();\nnew Integer(i).toString();will take more memory as it will create the object each time, so memory fragmentation will happen.",
                "Better:Integer.valueOf(i).toString()\nInteger.valueOf(i).toString()\n",
                "Simple way is just concatenate \"\" with integer:\"\"int i = 100;\n\nString s = \"\" + i;\nint i = 100;\n\nString s = \"\" + i;\nnow s will have 100 as string value.s100",
                "Here \nInteger.toString calls the static method in the class Integer. It does not require the object to call.Integer.toStringIf you call new Integer(i) you first create an instance of type Integer, which is a full Java object encapsulating the value of your int i. Then you call the toString method on it to ask it to return a string representation of itself.new Integer(i)toString",
                "1.Integer.toString(i)Integer.toString(i)Integer i = new Integer(8);\n    // returns a string representation of the specified integer with radix 8\n String retval = i.toString(516, 8);\nSystem.out.println(\"Value = \" + retval);\nInteger i = new Integer(8);\n    // returns a string representation of the specified integer with radix 8\n String retval = i.toString(516, 8);\nSystem.out.println(\"Value = \" + retval);\n2.new Integer(i).toString()\nnew Integer(i).toString()\n int i = 506;\n\nString str = new Integer(i).toString();\nSystem.out.println(str + \" : \" + new Integer(i).toString().getClass());////506 : class java.lang.String\n int i = 506;\n\nString str = new Integer(i).toString();\nSystem.out.println(str + \" : \" + new Integer(i).toString().getClass());////506 : class java.lang.String\n"
            ]
        },
        {
            "tag": "integer",
            "patterns": [
                "Signed versus Unsigned Integers",
                "Signed versus Unsigned Integers"
            ],
            "responses": [
                "\nUnsigned can hold a larger positive value and no negative value.\nUnsigned can hold a larger positive value and no negative value.Yes.\nUnsigned uses the leading bit as a part of the value, while the signed version uses the left-most-bit to identify if the number is positive or negative.\nUnsigned uses the leading bit as a part of the value, while the signed version uses the left-most-bit to identify if the number is positive or negative.There are different ways of representing signed integers.  The easiest to visualise is to use the leftmost bit as a flag (sign and magnitude), but more common is two's complement.  Both are in use in most modern microprocessors \u2014 floating point uses sign and magnitude, while integer arithmetic uses two's complement.sign and magnitudetwo's complement\nSigned integers can hold both positive and negative numbers.\nSigned integers can hold both positive and negative numbers.Yes.",
                "I'll go into differences at the hardware level, on x86. This is mostly irrelevant unless you're writing a compiler or using assembly language. But it's nice to know.Firstly, x86 has native support for the two's complement representation of signed numbers. You can use other representations but this would require more instructions and generally be a waste of processor time.nativetwo's complementWhat do I mean by \"native support\"? Basically I mean that there are a set of instructions you use for unsigned numbers and another set that you use for signed numbers. Unsigned numbers can sit in the same registers as signed numbers, and indeed you can mix signed and unsigned instructions without worrying the processor. It's up to the compiler (or assembly programmer) to keep track of whether a number is signed or not, and use the appropriate instructions.Firstly, two's complement numbers have the property that addition and subtraction is just the same as for unsigned numbers. It makes no difference whether the numbers are positive or negative. (So you just go ahead and ADD and SUB your numbers without a worry.)ADDSUBThe differences start to show when it comes to comparisons. x86 has a simple way of differentiating them: above/below indicates an unsigned comparison and greater/less than indicates a signed comparison. (E.g. JAE means \"Jump if above or equal\" and is unsigned.)JAEThere are also two sets of multiplication and division instructions to deal with signed and unsigned integers.Lastly: if you want to check for, say, overflow, you would do it differently for signed and for unsigned numbers.",
                "He only asked about signed and unsigned. Don't know why people are adding extra stuff in this. Let me tell you the answer.\nUnsigned: It consists of only non-negative values i.e 0 to 255.\nSigned: It consist of both negative and positive values but in different formats like\n\n0 to +127\n-1 to -128\n\nUnsigned: It consists of only non-negative values i.e 0 to 255.Unsigned: It consists of only non-negative values i.e 0 to 255.Signed: It consist of both negative and positive values but in different formats like\n\n0 to +127\n-1 to -128\nSigned: It consist of both negative and positive values but in different formats like\n0 to +127\n-1 to -128\n0 to +127-1 to -128And this explanation is about the 8-bit number system.",
                "According to what we learned in class, signed integers can represent both positive and negative numbers, while unsigned integers are only non-negative.andonlyFor example, looking at an 8-bit number:8-bitunsigned values 0 to 255 unsigned0255signed values range from -128 to 127 signed-128127",
                "Just a few points for completeness:\nthis answer is discussing only integer representations.  There may be other answers for floating point;\nthe representation of a negative number can vary.  The most common (by far - it's nearly universal today) in use today is two's complement.  Other representations include one's complement (quite rare) and signed magnitude (vanishingly rare - probably only used on museum pieces) which is simply using the high bit as a sign indicator with the remain bits representing the absolute value of the number.\nWhen using two's complement, the variable can represent a larger range (by one) of negative numbers than positive numbers.  This is because zero is included in the 'positive' numbers (since the sign bit is not set for zero), but not the negative numbers. This means that the absolute value of the smallest negative number cannot be represented.\nwhen using one's complement or signed magnitude you can have zero represented as either a positive or negative number (which is one of a couple of reasons these representations aren't typically used).\nthis answer is discussing only integer representations.  There may be other answers for floating point;this answer is discussing only integer representations.  There may be other answers for floating point;the representation of a negative number can vary.  The most common (by far - it's nearly universal today) in use today is two's complement.  Other representations include one's complement (quite rare) and signed magnitude (vanishingly rare - probably only used on museum pieces) which is simply using the high bit as a sign indicator with the remain bits representing the absolute value of the number.the representation of a negative number can vary.  The most common (by far - it's nearly universal today) in use today is two's complement.  Other representations include one's complement (quite rare) and signed magnitude (vanishingly rare - probably only used on museum pieces) which is simply using the high bit as a sign indicator with the remain bits representing the absolute value of the number.two's complementone's complementsigned magnitudeWhen using two's complement, the variable can represent a larger range (by one) of negative numbers than positive numbers.  This is because zero is included in the 'positive' numbers (since the sign bit is not set for zero), but not the negative numbers. This means that the absolute value of the smallest negative number cannot be represented.When using two's complement, the variable can represent a larger range (by one) of negative numbers than positive numbers.  This is because zero is included in the 'positive' numbers (since the sign bit is not set for zero), but not the negative numbers. This means that the absolute value of the smallest negative number cannot be represented.when using one's complement or signed magnitude you can have zero represented as either a positive or negative number (which is one of a couple of reasons these representations aren't typically used).when using one's complement or signed magnitude you can have zero represented as either a positive or negative number (which is one of a couple of reasons these representations aren't typically used).",
                "Everything except for point 2 is correct. There are many different notations for signed ints, some implementations use the first, others use the last and yet others use something completely different. That all depends on the platform you're working with.",
                "Another difference is when you are converting between integers of different sizes.For example, if you are extracting an integer from a byte stream (say 16 bits for simplicity), with unsigned values, you could do:i = ((int) b[j]) << 8 | b[j+1]\ni = ((int) b[j]) << 8 | b[j+1]\n(should probably cast the 2nd byte, but I'm guessing the compiler will do the right thing)(should probably cast the 2nd byte, but I'm guessing the compiler will do the right thing)ndWith signed values you would have to worry about sign extension and do:i = (((int) b[i]) & 0xFF) << 8 | ((int) b[i+1]) & 0xFF\ni = (((int) b[i]) & 0xFF) << 8 | ((int) b[i+1]) & 0xFF\n",
                "Over and above what others have said, in C, you cannot overflow an unsigned integer; the behaviour is defined to be modulus arithmetic.  You can overflow a signed integer and, in theory (though not in practice on current mainstream systems), the overflow could trigger a fault (perhaps similar to a divide by zero fault).",
                "Generally speaking that is correct. Without knowing anything more about why you are looking for the differences I can't think of any other differentiators between signed and unsigned. ",
                "Signed integers in C represent numbers.  If a and b are variables of signed integer types, the standard will never require that a compiler make the expression a+=b store into a anything other than the arithmetic sum of their respective values.  To be sure, if the arithmetic sum would not fit into a, the processor might not be able to put it there, but the standard would not require the compiler to truncate or wrap the value, or do anything else for that matter if values that exceed the limits for their types.  Note that while the standard does not require it, C implementations are allowed to trap arithmetic overflows with signed values.aba+=baamightUnsigned integers in C behave as abstract algebraic rings of integers which are congruent modulo some power of two, except in scenarios involving conversions to, or operations with, larger types.  Converting an integer of any size to a 32-bit unsigned type will yield the member corresponding to things which are congruent to that integer mod 4,294,967,296.  The reason subtracting 3 from 2 yields 4,294,967,295 is that adding something congruent to 3 to something congruent to 4,294,967,295 will yield something congruent to 2.anyAbstract algebraic rings types are often handy things to have; unfortunately, C uses signedness as the deciding factor for whether a type should behave as a ring.  Worse, unsigned values are treated as numbers rather than ring members when converted to larger types, and unsigned values smaller than int get converted to numbers when any arithmetic is performed upon them.  If v is a uint32_t which equals 4,294,967,294, then v*=v; should make v=4.  Unfortunately, if int is 64 bits, then there's no telling what v*=v; could do.intvuint32_t4,294,967,294v*=v;v=4intv*=v;Given the standard as it is, I would suggest using unsigned types in situations where one wants the behavior associated with algebraic rings, and signed types when one wants to represent numbers.  It's unfortunate that C drew the distinctions the way it did, but they are what they are.",
                "\nYes, unsigned integer can store large value.\nNo, there are different ways to show positive and negative values.\nYes, signed integer can contain both positive and negative values.\nYes, unsigned integer can store large value.No, there are different ways to show positive and negative values.Yes, signed integer can contain both positive and negative values.",
                "(in answer to the second question) By only using a sign bit (and not 2's complement), you can end up with -0. Not very pretty.",
                "Unsigned integers are far more likely to catch you in a particular trap than are signed integers.  The trap comes from the fact that while 1 & 3 above are correct, both types of integers can be assigned a value outside the bounds of what it can \"hold\" and it will be silently converted.assignedunsigned int ui = -1;\nsigned int si = -1;\n\nif (ui < 0) {\n    printf(\"unsigned < 0\\n\");\n}\nif (si < 0) {\n    printf(\"signed < 0\\n\");\n}\nif (ui == si) {\n    printf(\"%d == %d\\n\", ui, si);\n    printf(\"%ud == %ud\\n\", ui, si);\n}\nunsigned int ui = -1;\nsigned int si = -1;\n\nif (ui < 0) {\n    printf(\"unsigned < 0\\n\");\n}\nif (si < 0) {\n    printf(\"signed < 0\\n\");\n}\nif (ui == si) {\n    printf(\"%d == %d\\n\", ui, si);\n    printf(\"%ud == %ud\\n\", ui, si);\n}\nWhen you run this, you'll get the following output even though both values were assigned to -1 and were declared differently.signed < 0\n-1 == -1\n4294967295d == 4294967295d\nsigned < 0\n-1 == -1\n4294967295d == 4294967295d\n",
                "The only guaranteed difference between a signed and an unsigned value in C is that the signed value can be negative, 0 or positive, while an unsigned can only be 0 or positive. The problem is that C doesn't define the format of types (so you don't know that your integers are in two's complement). Strictly speaking the first two points you mentioned are incorrect.guaranteedknow",
                "You must used unsigned Integers when programming on Embedded Systems. In loops, when there is no need for signed integers, using unsigned integers will save safe necessary for designing such systems.",
                "The best answer I found on this was thanks to IBM quoting the XDR standard:IBMXDR standard\nInteger\nAn XDR signed integer is a 32-bit piece of data that encodes\nan integer in the range [-2147483648,2147483647]. The integer is\nrepresented in two's complement notation. The most and least\nsignificant bytes are 0 and 3, respectively. The data description of\nintegers is integer.\nUnsigned integer\nAn XDR unsigned integer is a 32-bit piece of data\nthat encodes a nonnegative integer in the range [0,4294967295]. It is\nrepresented by an unsigned binary number whose most and least\nsignificant bytes are 0 and 3, respectively. The data description of\nunsigned integers is unsigned.\nIntegerIntegerAn XDR signed integer is a 32-bit piece of data that encodes\nan integer in the range [-2147483648,2147483647]. The integer is\nrepresented in two's complement notation. The most and least\nsignificant bytes are 0 and 3, respectively. The data description of\nintegers is integer.Unsigned integerUnsigned integerAn XDR unsigned integer is a 32-bit piece of data\nthat encodes a nonnegative integer in the range [0,4294967295]. It is\nrepresented by an unsigned binary number whose most and least\nsignificant bytes are 0 and 3, respectively. The data description of\nunsigned integers is unsigned.see XDR Standard on WikipediaXDR StandardWikipedia",
                "This is all about modeling :\nWhen you want to design a computer, you need to adopt conventions to how you represent data, and how you compute them. And of course, provide different models with different operations and properties (performance, memory space required, hardware implementation complexity etc.)Turns out, with computation based on electricity (thus electronics), the most convenient way we found to represent an information is to use the voltage level. ...And the most convenient way to compute with these voltage level is considering two states : Presence of a voltage and absence of voltage.\nHere comes the \"bit\".This is why we use binary to represent numbers : a succession of electronic pins with either a high voltage (1) or a low voltage (0).However, if you count using binary, you can only represent natural numbers (0, 1, 2, ...). Exactly 2^n (where n is the number of bits you have) numbers.This permits you to do addition multiplication, division, and subtraction if you ensure the first operand is greater than the second, end if you check the result would not exceed the number of bits you have.Then, some smart guys came and though : \"What happens when you do n - m with m > n, using exactly the same algorithm ?\"...And what happens is that it actually kinda work : you just have to add one to your number if you have a carry (wrap around) after, and consider that both 0...0 and 1...1 represents 0. That's One's complement Ones'_complement\nHowever, by doing so, you have to reserve one bit for the sign. Technically, you can represent values from -(2^(n-1)-1) \u2264 n \u2264 2^(n-1)-1\nWhich are : (2^n)-1 (two representations for 0). In this representation, you just have to swap all the bits to negate a number.Ones'_complementThen even smarter guys came and tell \"What if we consider there is always a wrap around when we negate the number ?\" ...That means you add one after you have swapped the bits. And you get 2's complement Two's complement\nUsing it, your zero has only One representation, and you can again represent 2^n numbers ( with 2^(n-1) \u2264 n \u2264 2^(n-1)-1 ). Plus, the computation of a-b really just is a+(-b), which only requires two kind of operation : add(a, add(swap(b), 1)))Two's complementa-ba+(-b)add(a, add(swap(b), 1)))Another nice thing about 2's complement, is that the addition algorithm is the same as the unsigned one. Therefore you get the same properties, and use the same hardware to do both. This is why it's the representation used in most computers.In short, signed and unsigned can represent the same count of numbers, but on a different range, and now, you know which precisely and why. For more detail about the algebraic structure obtained, read this response : https://stackoverflow.com/a/23304179/1745291https://stackoverflow.com/a/23304179/1745291Then use one or the other depending on the context (note however that for some operation, like <, the treatment is different when casting : ((signed) -1) < 5 but ((unsigned) -1) > 5<((signed) -1) < 5((unsigned) -1) > 5"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "How to convert float to int with Java",
                "how can you convert a float to an integer on a java jre?",
                "how do i convert the float to int in java?",
                "how do i convert floating to int in java?",
                "how do i convert float to int using java?",
                "how do i convert float to int with java?"
            ],
            "responses": [
                "Using Math.round() will round the float to the nearest integer.Math.round()",
                "Actually, there are different ways to downcast float to int, depending on the result you want to achieve:\n(for int i, float f)if\nround (the closest integer to given float)\ni = Math.round(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -3\n\nnote: this is, by contract, equal to (int) Math.floor(f + 0.5f)\ntruncate (i.e. drop everything after the decimal dot)\ni = (int) f;\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\n\nceil/floor (an integer always bigger/smaller than a given value if it has any fractional part)\ni = (int) Math.ceil(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  3 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\n\ni = (int) Math.floor(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -3 ; f = -2.68 -> i = -3\n\nround (the closest integer to given float)\ni = Math.round(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -3\n\nnote: this is, by contract, equal to (int) Math.floor(f + 0.5f)round (the closest integer to given float)i = Math.round(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -3\ni = Math.round(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -3\nnote: this is, by contract, equal to (int) Math.floor(f + 0.5f)(int) Math.floor(f + 0.5f)truncate (i.e. drop everything after the decimal dot)\ni = (int) f;\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\ntruncate (i.e. drop everything after the decimal dot)i = (int) f;\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\ni = (int) f;\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\nceil/floor (an integer always bigger/smaller than a given value if it has any fractional part)\ni = (int) Math.ceil(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  3 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\n\ni = (int) Math.floor(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -3 ; f = -2.68 -> i = -3\nceil/floor (an integer always bigger/smaller than a given value if it has any fractional part)ifi = (int) Math.ceil(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  3 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\n\ni = (int) Math.floor(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -3 ; f = -2.68 -> i = -3\ni = (int) Math.ceil(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  3 ; f =  2.68 -> i =  3\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2\n\ni = (int) Math.floor(f);\n  f =  2.0 -> i =  2 ; f =  2.22 -> i =  2 ; f =  2.68 -> i =  2\n  f = -2.0 -> i = -2 ; f = -2.22 -> i = -3 ; f = -2.68 -> i = -3\nFor rounding positive values, you can also just use (int)(f + 0.5), which works exactly as Math.Round in those cases (as per doc).positive(int)(f + 0.5)Math.RoundYou can also use Math.rint(f) to do the rounding to the nearest even integer; it's arguably useful if you expect to deal with a lot of floats with fractional part strictly equal to  .5 (note the possible IEEE rounding issues), and want to keep the average of the set in place; you'll introduce another bias, where even numbers will be more common than odd, though.Math.rint(f)rounding to the nearest even integerSeehttp://mindprod.com/jgloss/round.htmlhttp://mindprod.com/jgloss/round.htmlhttp://docs.oracle.com/javase/6/docs/api/java/lang/Math.htmlhttp://docs.oracle.com/javase/6/docs/api/java/lang/Math.htmlfor more information and some examples.",
                "Math.round(value) round the value to the nearest whole number.Math.round(value)Use 1) b=(int)(Math.round(a));\n\n2) a=Math.round(a);  \n   b=(int)a;\n1) b=(int)(Math.round(a));\n\n2) a=Math.round(a);  \n   b=(int)a;\n",
                "Instantiate a Float object by passing a float primitive to the constructor, then use the Float object you created to return an int primitive.FloatfloatFloatint\n\n\n\nExplanation\n\n\n\n\nSince number wrapper classes extend the java.lang.Number class, you can have any number wrapper object return any other number primitive type by using the .<type>Value() method.\n\n\n\n\n\n\nExplanation\n\n\n\n\nSince number wrapper classes extend the java.lang.Number class, you can have any number wrapper object return any other number primitive type by using the .<type>Value() method.\n\n\n\n\nExplanation\n\n\nExplanation\nExplanation\n\nSince number wrapper classes extend the java.lang.Number class, you can have any number wrapper object return any other number primitive type by using the .<type>Value() method.\n\n\nSince number wrapper classes extend the java.lang.Number class, you can have any number wrapper object return any other number primitive type by using the .<type>Value() method.\nSince number wrapper classes extend the java.lang.Number class, you can have any number wrapper object return any other number primitive type by using the .<type>Value() method.java.lang.Numbernumber wrapper objectnumber primitive.<type>Value()Steps\nCreate a Float object\nUse the .intValue() method to return a primitive int.\nCreate a Float objectUse the .intValue() method to return a primitive int..intValue()intExampleFloat mFloat = Float.valueOf(8.65f);\nint i = mFloat.intValue();\nFloat mFloat = Float.valueOf(8.65f);\nint i = mFloat.intValue();\n",
                "Math.round also returns an integer value, so you don't need to typecast.int b = Math.round(float a);\nint b = Math.round(float a);\n",
                "Use Math.round(value) then after type cast it to integer.Math.round(value)float a = 8.61f;\nint b = (int)Math.round(a);\nfloat a = 8.61f;\nint b = (int)Math.round(a);\n",
                "Math.round() is sufficientint b = Math.round(a)\nint b = Math.round(a)\nThis will do the Job",
                "If you want to convert a float value into an integer value, you have several ways to do it that depends on how do you want to round the float value.First way is floor rounding the float value:float myFloat = 3.14f;\nint myInteger = (int)myFloat;\nfloat myFloat = 3.14f;\nint myInteger = (int)myFloat;\nThe output of this code will be 3, even if the myFloat value is closer to 4.The second way is ceil rounding the float value:float myFloat = 3.14f;\nint myInteger = Math.ceil(myFloat);\nfloat myFloat = 3.14f;\nint myInteger = Math.ceil(myFloat);\nThe output of this code will be 4, because the rounding mode is always looking for the highest value.",
                "As to me, easier: (int) (a +.5)   // a is a Float. Return rounded value.(int) (a +.5)Not dependent on Java Math.round() typesNot dependent on Java Math.round() types"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "Convert boolean to int in Java",
                "convert boolean to int in java"
            ],
            "responses": [
                "int myInt = myBoolean ? 1 : 0;\nint myInt = myBoolean ? 1 : 0;\n^^PS : true = 1 and false = 0",
                "int val = b? 1 : 0;\nint val = b? 1 : 0;\n",
                "Using the ternary operator is the most simple, most efficient, and most readable way to do what you want. I encourage you to use this solution.However, I can't resist to propose an alternative, contrived, inefficient, unreadable solution.int boolToInt(Boolean b) {\n    return b.compareTo(false);\n}\nint boolToInt(Boolean b) {\n    return b.compareTo(false);\n}\nHey, people like to vote for such cool answers !EditEditBy the way, I often saw conversions from a boolean to an int for the sole purpose of doing a comparison of the two values (generally, in implementations of compareTo method). Boolean#compareTo is the way to go in those specific cases.compareToBoolean#compareToEdit 2Edit 2Java 7 introduced a new utility function that works with primitive types directly, Boolean#compare (Thanks shmosel)Boolean#compareshmoselint boolToInt(boolean b) {\n    return Boolean.compare(b, false);\n}\nint boolToInt(boolean b) {\n    return Boolean.compare(b, false);\n}\n",
                "boolean b = ....; \nint i = -(\"false\".indexOf(\"\" + b));\nboolean b = ....; \nint i = -(\"false\".indexOf(\"\" + b));\n",
                "import org.apache.commons.lang3.BooleanUtils;\nboolean x = true;   \nint y= BooleanUtils.toInteger(x);\nimport org.apache.commons.lang3.BooleanUtils;\nboolean x = true;   \nint y= BooleanUtils.toInteger(x);\n",
                "public int boolToInt(boolean b) {\n    return b ? 1 : 0;\n}\npublic int boolToInt(boolean b) {\n    return b ? 1 : 0;\n}\nsimple",
                "If you use Apache Commons Lang (which I think a lot of projects use it), you can just use it like this: Apache Commons Langint myInt = BooleanUtils.toInteger(boolean_expression); \nint myInt = BooleanUtils.toInteger(boolean_expression); \ntoInteger method returns 1 if boolean_expression is true, 0 otherwisetoIntegerboolean_expression",
                "That depends on the situation. Often the most simple approach is the best because it is easy to understand:if (something) {\n    otherThing = 1;\n} else {\n    otherThing = 0;\n}\nif (something) {\n    otherThing = 1;\n} else {\n    otherThing = 0;\n}\norint otherThing = something ? 1 : 0;\nint otherThing = something ? 1 : 0;\nBut sometimes it useful to use an Enum instead of a boolean flag. Let imagine there are synchronous and asynchronous processes:Process process = Process.SYNCHRONOUS;\nSystem.out.println(process.getCode());\nProcess process = Process.SYNCHRONOUS;\nSystem.out.println(process.getCode());\nIn Java, enum can have additional attributes and methods:public enum Process {\n\n    SYNCHRONOUS (0),\n    ASYNCHRONOUS (1);\n\n    private int code;\n    private Process (int code) {\n        this.code = code;\n    }\n\n    public int getCode() {\n        return code;\n    }\n}\npublic enum Process {\n\n    SYNCHRONOUS (0),\n    ASYNCHRONOUS (1);\n\n    private int code;\n    private Process (int code) {\n        this.code = code;\n    }\n\n    public int getCode() {\n        return code;\n    }\n}\n",
                "If true -> 1 and false -> 0 mapping is what you want, you can do:true -> 1false -> 0boolean b = true;\nint i = b ? 1 : 0; // assigns 1 to i.\nboolean b = true;\nint i = b ? 1 : 0; // assigns 1 to i.\n",
                "If you want to obfuscate, use this:System.out.println( 1 & Boolean.hashCode( true ) >> 1 );  // 1\nSystem.out.println( 1 & Boolean.hashCode( false ) >> 1 ); // 0\nSystem.out.println( 1 & Boolean.hashCode( true ) >> 1 );  // 1\nSystem.out.println( 1 & Boolean.hashCode( false ) >> 1 ); // 0\n",
                "Lets play trick with Boolean.compare(boolean, boolean). Default behavior of function: if both values are equal than it returns 0 otherwise -1.Boolean.compare(boolean, boolean)0-1public int valueOf(Boolean flag) {\n   return Boolean.compare(flag, Boolean.TRUE) + 1;\n}\npublic int valueOf(Boolean flag) {\n   return Boolean.compare(flag, Boolean.TRUE) + 1;\n}\nExplanation: As we know default return of Boolean.compare is -1 in case of mis-match so +1 make return value to 0 for False and 1 for TrueExplanation0False1True",
                "public static int convBool(boolean b)\n{\nint convBool = 0;\nif(b) convBool = 1;\nreturn convBool;\n}\npublic static int convBool(boolean b)\n{\nint convBool = 0;\nif(b) convBool = 1;\nreturn convBool;\n}\nThen use :convBool(aBool);\nconvBool(aBool);\n"
            ]
        },
        {
            "tag": "mysql",
            "patterns": [
                "What is the difference between tinyint, smallint, mediumint, bigint and int in MySQL?",
                "tell me the difference between mysql smallint bigint and smallint?",
                "tell me the difference between smallint bigint smallint and tinyint in mysql?",
                "tell me the difference between the int smallint and smallint in mysql?",
                "tell me the difference between int smallint and int in mysql?",
                "tell me the difference between int smallint mediumint and tinyint in mysql?",
                "tell me the difference between int smallint mediumint and int in mysql?",
                "tell me the difference between tinyint smallint mediumint bigint in mysql?"
            ],
            "responses": [
                "They take up different amounts of space and they have different ranges of acceptable values.Here are the sizes and ranges of values for SQL Server, other RDBMSes have similar documentation:Here are the sizes and ranges of values for SQL Server\nMySQL\nPostgres\nOracle (they just have a NUMBER datatype really)\nDB2\nMySQLMySQLPostgresPostgresOracle (they just have a NUMBER datatype really)OracleNUMBERDB2DB2Turns out they all use the same specification (with a few minor exceptions noted below) but support various combinations of those types (Oracle not included because it has just a NUMBER datatype, see the above link):NUMBER             | SQL Server    MySQL   Postgres    DB2\n---------------------------------------------------\ntinyint      |     X           X                \nsmallint     |     X           X         X        X\nmediumint    |                 X\nint/integer  |     X           X         X        X \nbigint       |     X           X         X        X\n             | SQL Server    MySQL   Postgres    DB2\n---------------------------------------------------\ntinyint      |     X           X                \nsmallint     |     X           X         X        X\nmediumint    |                 X\nint/integer  |     X           X         X        X \nbigint       |     X           X         X        X\nAnd they support the same value ranges (with one exception below) and all have the same storage requirements:            | Bytes    Range (signed)                               Range (unsigned)\n--------------------------------------------------------------------------------------------\ntinyint     | 1 byte   -128 to 127                                  0 to 255\nsmallint    | 2 bytes  -32768 to 32767                              0 to 65535\nmediumint   | 3 bytes  -8388608 to 8388607                          0 to 16777215\nint/integer | 4 bytes  -2147483648 to 2147483647                    0 to 4294967295\nbigint      | 8 bytes  -9223372036854775808 to 9223372036854775807  0 to 18446744073709551615 \n            | Bytes    Range (signed)                               Range (unsigned)\n--------------------------------------------------------------------------------------------\ntinyint     | 1 byte   -128 to 127                                  0 to 255\nsmallint    | 2 bytes  -32768 to 32767                              0 to 65535\nmediumint   | 3 bytes  -8388608 to 8388607                          0 to 16777215\nint/integer | 4 bytes  -2147483648 to 2147483647                    0 to 4294967295\nbigint      | 8 bytes  -9223372036854775808 to 9223372036854775807  0 to 18446744073709551615 \nThe \"unsigned\" types are only available in MySQL, and the rest just use the signed ranges, with one notable exception: tinyint in SQL Server is unsigned and has a value range of 0 to 255tinyint in SQL Server is unsignedtinyint",
                "The size of storage required and how big the numbers can be.size of storagehow bigOn SQL Server:\ntinyint  1 byte, 0 to 255\nsmallint 2 bytes, -215 (-32,768) to 215-1 (32,767)\nint 4 bytes, -231 (-2,147,483,648) to 231-1 (2,147,483,647)\nbigint 8 bytes, -263 (-9,223,372,036,854,775,808) to 263-1 (9,223,372,036,854,775,807)\ntinyint  1 byte, 0 to 255tinyintsmallint 2 bytes, -215 (-32,768) to 215-1 (32,767)smallint1515-1int 4 bytes, -231 (-2,147,483,648) to 231-1 (2,147,483,647)int3131-1bigint 8 bytes, -263 (-9,223,372,036,854,775,808) to 263-1 (9,223,372,036,854,775,807)bigint6363-1You can store the number 1 in all 4, but a bigint will use 8 bytes, while a tinyint will use 1 byte.biginttinyint",
                "Those seem to be MySQL data types.According to the documentation they take:documentation\ntinyint = 1 byte\nsmallint = 2 bytes\nmediumint = 3 bytes\nint = 4 bytes\nbigint = 8 bytes\ntinyint = 1 bytetinyintsmallint = 2 bytessmallintmediumint = 3 bytesmediumintint = 4 bytesintbigint = 8 bytesbigintAnd, naturally, accept increasingly larger ranges of numbers.",
                "When it gets to real world usage of these datatypes, it is very important that you understand that using certain integer types could just be an overkill or under used. For example, using integer datatype for employeeCount in a table say employee could be an overkill since it supports a range of integer values from ~ negative 2 billion to positive 2 billion or zero to approximately 4 billion (unsigned). So, even if you consider one of the US biggest employer such as Walmart with roughly about 2.2 million employees using an integer datatype for the employeeCount column would be unnecessary. In such a case you use mediumint (that supports from 0 to 16 million (unsigned)) for example. Having said that if your range is expected to be unusually large you might consider bigint which as you can see from Daniel's notes supports a range larger than I care to decipher.",
                "The difference is the amount of memory allocated to each integer, and how large a number they each can store.",
                "Data type   Range   Storagebigint  -2^63 (-9,223,372,036,854,775,808) to 2^63-1 (9,223,372,036,854,775,807)    8 Bytes\nint -2^31 (-2,147,483,648) to 2^31-1 (2,147,483,647)    4 Bytes\nsmallint    -2^15 (-32,768) to 2^15-1 (32,767)  2 Bytes\ntinyint 0 to 255    1 Byte\nbigint  -2^63 (-9,223,372,036,854,775,808) to 2^63-1 (9,223,372,036,854,775,807)    8 Bytes\nint -2^31 (-2,147,483,648) to 2^31-1 (2,147,483,647)    4 Bytes\nsmallint    -2^15 (-32,768) to 2^15-1 (32,767)  2 Bytes\ntinyint 0 to 255    1 Byte\nExampleExampleThe following example creates a table using the bigint, int, smallint, and tinyint data types. Values are inserted into each column and returned in the SELECT statement.CREATE TABLE dbo.MyTable\n(\n  MyBigIntColumn bigint\n ,MyIntColumn  int\n ,MySmallIntColumn smallint\n ,MyTinyIntColumn tinyint\n);\n\nGO\n\nINSERT INTO dbo.MyTable VALUES (9223372036854775807, 214483647,32767,255);\n GO\nSELECT MyBigIntColumn, MyIntColumn, MySmallIntColumn, MyTinyIntColumn\nFROM dbo.MyTable;\nCREATE TABLE dbo.MyTable\n(\n  MyBigIntColumn bigint\n ,MyIntColumn  int\n ,MySmallIntColumn smallint\n ,MyTinyIntColumn tinyint\n);\n\nGO\n\nINSERT INTO dbo.MyTable VALUES (9223372036854775807, 214483647,32767,255);\n GO\nSELECT MyBigIntColumn, MyIntColumn, MySmallIntColumn, MyTinyIntColumn\nFROM dbo.MyTable;\n"
            ]
        },
        {
            "tag": "javascript",
            "patterns": [
                "Convert boolean result into number/integer",
                "Convert boolean result into number/integer"
            ],
            "responses": [
                "Use the unary + operator, which converts its operand into a number.unary + operator++ true; // 1\n+ false; // 0\n+ true; // 1\n+ false; // 0\nNote, of course, that you should still sanitise the data on the server side, because a user can send any data to your sever, no matter what the client-side code says.",
                "Javascript has a ternary operator you could use:var i = result ? 1 : 0;\nvar i = result ? 1 : 0;\n",
                "Imho the best solution is:fooBar | 0\nfooBar | 0\nThis is used in asm.js to force integer type.",
                "I prefer to use the Number function. It takes an object and converts it to a number.Number functionExample:var myFalseBool = false;\nvar myTrueBool = true;\n\nvar myFalseInt = Number(myFalseBool);\nconsole.log(myFalseInt === 0);\n\nvar myTrueInt = Number(myTrueBool);\nconsole.log(myTrueInt === 1);\nvar myFalseBool = false;\nvar myTrueBool = true;\n\nvar myFalseInt = Number(myFalseBool);\nconsole.log(myFalseInt === 0);\n\nvar myTrueInt = Number(myTrueBool);\nconsole.log(myTrueInt === 1);\nYou can test it in a jsFiddle.jsFiddle",
                "The typed way to do this would be:Number(true) // 1\nNumber(false) // 0\nNumber(true) // 1\nNumber(false) // 0\n",
                "I created a JSperf comparison of all suggested answers.JSperfTL;DR - the best option for all current browsers is:val | 0;\nval | 0;\n.Update:Update:It seems like these days they are all pretty identical, except that the Number() function is the slowest, while the best being val === true ? 1 : 0;.Number()val === true ? 1 : 0;",
                "I just came across this shortcut today.~~(true)~~(false)People much smarter than I can explain: http://james.padolsey.com/javascript/double-bitwise-not/http://james.padolsey.com/javascript/double-bitwise-not/",
                "TL;DR: Avoid Number constructor and +bool; use a simple if by default; resort to bool | 0, 1 * bool if benchmarks in your project do better this way.Number+boolifbool | 01 * boolThis is quite an old question, and there exist many valid answers. Something I've noticed is that all benchmarks here are irrelevant - none take into account branch prediction. Also, nowadays, JS engines don't simply interpret the code, they JIT compile it to native machine code and optimize it prior to execution. This means that, besides branch prediction, the compiler can even substitute expressions with their final value.branchpredictionJITcompileNow, how do these 2 factors affect the performance of, well, boolean to integer conversion? Let's find out! Before we get into the benchmarks, it is important to know what we benchmark. For the conversion, we're using the following seven conversion methods:\nNumber constructor: Number(bool)\nIf statement (ternary used): bool ? 1 : 0\nUnary operator +: +bool\nBitwise OR: bool | 0\nBitwise AND: bool & 1\nBitwise double NOT: ~~bool\nNumber multiplication: bool * 1\nNumber constructor: Number(bool)Number(bool)If statement (ternary used): bool ? 1 : 0bool ? 1 : 0Unary operator +: +bool++boolBitwise OR: bool | 0bool | 0Bitwise AND: bool & 1bool & 1Bitwise double NOT: ~~bool~~boolNumber multiplication: bool * 1bool * 1\"Conversion\" means converting false to 0 and true to 11. Each conversion method is ran 100000 times, measuring operations/millisecond. In the following tables, conversion methods will be grouped to their results accordingly. The percentage after the result represents how slow this method is compared to the fastest, in the same browser. If there is no percentage, the method is either the fastest or the difference is negligible (<0.01%). Benchmarks are run on a Macbook Pro 16-inch machine, with the Apple M1 Pro 10-core CPU and 16GB of RAM. Browsers are Chrome 102, Firefox 101 and Safari 15.5.false0true11The first benchmark converts the constant true:benchmarktrue\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\n\n\nNumber(bool)\n31745.89\n392.35 - 91.48%\n31231.79\n\n\nbool ? 1 : 0\n31592.8 - 0.48%\n4602.64\n27533.47 - 11.84%\n\n\n+bool\n31332.57 - 1.3%\n4463.41 - 3.02%\n27378.7 - 12.34%\n\n\nbool | 0\n31488.5 - 0.81%\n4441.4 - 3.5%\n27222 - 12.84%\n\n\nbool & 1\n31383.17 - 1.14%\n4459.64 - 3.11%\n27317.41 - 12.53%\n\n\n~~bool\n31265.85 - 1.51%\n4442.35 - 3.48%\n27434.72 - 12.16%\n\n\nbool * 1\n31374.4 - 1.17%\n4444.05 - 3.45%\n27381.19 - 12.33%\n\n\n\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\n\n\nNumber(bool)\n31745.89\n392.35 - 91.48%\n31231.79\n\n\nbool ? 1 : 0\n31592.8 - 0.48%\n4602.64\n27533.47 - 11.84%\n\n\n+bool\n31332.57 - 1.3%\n4463.41 - 3.02%\n27378.7 - 12.34%\n\n\nbool | 0\n31488.5 - 0.81%\n4441.4 - 3.5%\n27222 - 12.84%\n\n\nbool & 1\n31383.17 - 1.14%\n4459.64 - 3.11%\n27317.41 - 12.53%\n\n\n~~bool\n31265.85 - 1.51%\n4442.35 - 3.48%\n27434.72 - 12.16%\n\n\nbool * 1\n31374.4 - 1.17%\n4444.05 - 3.45%\n27381.19 - 12.33%\n\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\nMethodChrome (V8)Firefox (Spidermonkey)Safari (Webkit)\n\nNumber(bool)\n31745.89\n392.35 - 91.48%\n31231.79\n\n\nbool ? 1 : 0\n31592.8 - 0.48%\n4602.64\n27533.47 - 11.84%\n\n\n+bool\n31332.57 - 1.3%\n4463.41 - 3.02%\n27378.7 - 12.34%\n\n\nbool | 0\n31488.5 - 0.81%\n4441.4 - 3.5%\n27222 - 12.84%\n\n\nbool & 1\n31383.17 - 1.14%\n4459.64 - 3.11%\n27317.41 - 12.53%\n\n\n~~bool\n31265.85 - 1.51%\n4442.35 - 3.48%\n27434.72 - 12.16%\n\n\nbool * 1\n31374.4 - 1.17%\n4444.05 - 3.45%\n27381.19 - 12.33%\n\n\nNumber(bool)\n31745.89\n392.35 - 91.48%\n31231.79\nNumber(bool)Number(bool)31745.89392.35 - 91.48%31231.79\nbool ? 1 : 0\n31592.8 - 0.48%\n4602.64\n27533.47 - 11.84%\nbool ? 1 : 0bool ? 1 : 031592.8 - 0.48%4602.6427533.47 - 11.84%\n+bool\n31332.57 - 1.3%\n4463.41 - 3.02%\n27378.7 - 12.34%\n+bool+bool31332.57 - 1.3%4463.41 - 3.02%27378.7 - 12.34%\nbool | 0\n31488.5 - 0.81%\n4441.4 - 3.5%\n27222 - 12.84%\nbool | 0bool | 031488.5 - 0.81%4441.4 - 3.5%27222 - 12.84%\nbool & 1\n31383.17 - 1.14%\n4459.64 - 3.11%\n27317.41 - 12.53%\nbool & 1bool & 131383.17 - 1.14%4459.64 - 3.11%27317.41 - 12.53%\n~~bool\n31265.85 - 1.51%\n4442.35 - 3.48%\n27434.72 - 12.16%\n~~bool~~bool31265.85 - 1.51%4442.35 - 3.48%27434.72 - 12.16%\nbool * 1\n31374.4 - 1.17%\n4444.05 - 3.45%\n27381.19 - 12.33%\nbool * 1bool * 131374.4 - 1.17%4444.05 - 3.45%27381.19 - 12.33%Interesting! V8 shows some huge numbers, all of them approximately the same! Spidermonkey doesn't really shine, but we can see that the bitwise and multiplication tricks come first, and the ternary if second. Finally, Webkit's Number does similarly to V8's and the other methods fall behind, but are all close to each other. What are the takeaways? Browsers mostly manage to replace our conversions with simply the value 1. This optimization will take place where we can mentally replace the boolean to a constant value. The Number constructor is an intriguing anomaly - it severly falls behind in Firefox (91% slower!), while in Safari it is the fastest!Number1NumberslowerThat above isn't a situation we'll ever encounter in real projects. So let's change our variables: the bool is now Math.random() < 0.5. This yields a 50% chance of true, 50% of false. Do our results change? Let's run this benchmark to see.Math.random() < 0.5truefalsebenchmark\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\n\n\nNumber(bool)\n1648.83 - 2.26%\n280.34 - 86.4%\n8014.69\n\n\nbool ? 1 : 0\n804.27 - 52.32%\n731.57 - 64.5%\n1294.02 - 83.85%\n\n\n+bool\n1670.79 - 0.95%\n2057.94\n7753.99 - 3.25%\n\n\nbool | 0\n1668.22 - 1.11%\n2054.17\n7764.81 - 3.12%\n\n\nbool & 1\n1675.52 - 0.67%\n2056.76\n7193.08 - 10.25%\n\n\n~~bool\n1676.24 - 0.63%\n2056.18\n7669.48 - 4.31%\n\n\nbool * 1\n1686.88\n2060.88\n7751.48 - 3.28%\n\n\n\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\n\n\nNumber(bool)\n1648.83 - 2.26%\n280.34 - 86.4%\n8014.69\n\n\nbool ? 1 : 0\n804.27 - 52.32%\n731.57 - 64.5%\n1294.02 - 83.85%\n\n\n+bool\n1670.79 - 0.95%\n2057.94\n7753.99 - 3.25%\n\n\nbool | 0\n1668.22 - 1.11%\n2054.17\n7764.81 - 3.12%\n\n\nbool & 1\n1675.52 - 0.67%\n2056.76\n7193.08 - 10.25%\n\n\n~~bool\n1676.24 - 0.63%\n2056.18\n7669.48 - 4.31%\n\n\nbool * 1\n1686.88\n2060.88\n7751.48 - 3.28%\n\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\nMethodChrome (V8)Firefox (Spidermonkey)Safari (Webkit)\n\nNumber(bool)\n1648.83 - 2.26%\n280.34 - 86.4%\n8014.69\n\n\nbool ? 1 : 0\n804.27 - 52.32%\n731.57 - 64.5%\n1294.02 - 83.85%\n\n\n+bool\n1670.79 - 0.95%\n2057.94\n7753.99 - 3.25%\n\n\nbool | 0\n1668.22 - 1.11%\n2054.17\n7764.81 - 3.12%\n\n\nbool & 1\n1675.52 - 0.67%\n2056.76\n7193.08 - 10.25%\n\n\n~~bool\n1676.24 - 0.63%\n2056.18\n7669.48 - 4.31%\n\n\nbool * 1\n1686.88\n2060.88\n7751.48 - 3.28%\n\n\nNumber(bool)\n1648.83 - 2.26%\n280.34 - 86.4%\n8014.69\nNumber(bool)Number(bool)1648.83 - 2.26%280.34 - 86.4%8014.69\nbool ? 1 : 0\n804.27 - 52.32%\n731.57 - 64.5%\n1294.02 - 83.85%\nbool ? 1 : 0bool ? 1 : 0804.27 - 52.32%731.57 - 64.5%1294.02 - 83.85%\n+bool\n1670.79 - 0.95%\n2057.94\n7753.99 - 3.25%\n+bool+bool1670.79 - 0.95%2057.947753.99 - 3.25%\nbool | 0\n1668.22 - 1.11%\n2054.17\n7764.81 - 3.12%\nbool | 0bool | 01668.22 - 1.11%2054.177764.81 - 3.12%\nbool & 1\n1675.52 - 0.67%\n2056.76\n7193.08 - 10.25%\nbool & 1bool & 11675.52 - 0.67%2056.767193.08 - 10.25%\n~~bool\n1676.24 - 0.63%\n2056.18\n7669.48 - 4.31%\n~~bool~~bool1676.24 - 0.63%2056.187669.48 - 4.31%\nbool * 1\n1686.88\n2060.88\n7751.48 - 3.28%\nbool * 1bool * 11686.882060.887751.48 - 3.28%The results are more consistent now. We see similar numbers for ternary if, bitwise, and multiplication methods across browsers, and the Number constructor again performs the worst on Firefox. Ternary falls behind, as it generates branches. Safari seems to be our top performer overall, each method yielding blazing fast results!NumberLet's see now how branch prediction affects our results with the following benchmark, where we change our boolean variable to Math.random() < 0.01, which means 1% true, 99% false.benchmarkMath.random() < 0.01truefalse\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\n\n\nNumber(bool)\n1643.13 - 1.68%\n280.06 - 86.4%\n8071.65\n\n\nbool ? 1 : 0\n1590.55 - 4.83%\n1970.66 - 4.32%\n7119.59 - 11.8%\n\n\n+bool\n1662.09 - 0.55%\n2054.09\n7762.03 - 3.84%\n\n\nbool | 0\n1669.35\n2051.85\n7743.95 - 4.06%\n\n\nbool & 1\n1661.09 - 0.61%\n2057.62\n7454.45 - 7.65%\n\n\n~~bool\n1662.94 - 0.5%\n2059.65\n7739.4 - 4.12%\n\n\nbool * 1\n1671.28\n2048.21\n7787.38 - 3.52%\n\n\n\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\n\n\nNumber(bool)\n1643.13 - 1.68%\n280.06 - 86.4%\n8071.65\n\n\nbool ? 1 : 0\n1590.55 - 4.83%\n1970.66 - 4.32%\n7119.59 - 11.8%\n\n\n+bool\n1662.09 - 0.55%\n2054.09\n7762.03 - 3.84%\n\n\nbool | 0\n1669.35\n2051.85\n7743.95 - 4.06%\n\n\nbool & 1\n1661.09 - 0.61%\n2057.62\n7454.45 - 7.65%\n\n\n~~bool\n1662.94 - 0.5%\n2059.65\n7739.4 - 4.12%\n\n\nbool * 1\n1671.28\n2048.21\n7787.38 - 3.52%\n\n\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\n\n\nMethod\nChrome (V8)\nFirefox (Spidermonkey)\nSafari (Webkit)\nMethodChrome (V8)Firefox (Spidermonkey)Safari (Webkit)\n\nNumber(bool)\n1643.13 - 1.68%\n280.06 - 86.4%\n8071.65\n\n\nbool ? 1 : 0\n1590.55 - 4.83%\n1970.66 - 4.32%\n7119.59 - 11.8%\n\n\n+bool\n1662.09 - 0.55%\n2054.09\n7762.03 - 3.84%\n\n\nbool | 0\n1669.35\n2051.85\n7743.95 - 4.06%\n\n\nbool & 1\n1661.09 - 0.61%\n2057.62\n7454.45 - 7.65%\n\n\n~~bool\n1662.94 - 0.5%\n2059.65\n7739.4 - 4.12%\n\n\nbool * 1\n1671.28\n2048.21\n7787.38 - 3.52%\n\n\nNumber(bool)\n1643.13 - 1.68%\n280.06 - 86.4%\n8071.65\nNumber(bool)Number(bool)1643.13 - 1.68%280.06 - 86.4%8071.65\nbool ? 1 : 0\n1590.55 - 4.83%\n1970.66 - 4.32%\n7119.59 - 11.8%\nbool ? 1 : 0bool ? 1 : 01590.55 - 4.83%1970.66 - 4.32%7119.59 - 11.8%\n+bool\n1662.09 - 0.55%\n2054.09\n7762.03 - 3.84%\n+bool+bool1662.09 - 0.55%2054.097762.03 - 3.84%\nbool | 0\n1669.35\n2051.85\n7743.95 - 4.06%\nbool | 0bool | 01669.352051.857743.95 - 4.06%\nbool & 1\n1661.09 - 0.61%\n2057.62\n7454.45 - 7.65%\nbool & 1bool & 11661.09 - 0.61%2057.627454.45 - 7.65%\n~~bool\n1662.94 - 0.5%\n2059.65\n7739.4 - 4.12%\n~~bool~~bool1662.94 - 0.5%2059.657739.4 - 4.12%\nbool * 1\n1671.28\n2048.21\n7787.38 - 3.52%\nbool * 1bool * 11671.282048.217787.38 - 3.52%Unexpected? Expected? I'd say the latter, because in this case branch prediction was successful in almost all cases, given the smaller difference between the ternary if and bitwise hacks. All other results are the same, not much else to say here. I'll still point out the horrific performance of Number in Firefox - why?NumberThis endeavour brings us back to the original question: how to convert bool to int in Javascript? Here are my suggestions:\nUse if statements, in general. Don't get smart - the browser will do better, usually, and usually means most of the situations. They are the most readable and clear out of all the methods here. While we're at readability, maybe use if (bool) instead of that ugly ternary! I wish Javascript had what Rust or Python have...\nUse the rest when it's truly necessary. Maybe benchmarks in your project perform sub-standard, and you found that a nasty if causes bad performance - if that's the case, feel free to get into branchless programming! But don't go too deep in that rabbit hole, nobody will benefit from things like -1 * (a < b) + 1 * (a > b), believe me.\nUse if statements, in general. Don't get smart - the browser will do better, usually, and usually means most of the situations. They are the most readable and clear out of all the methods here. While we're at readability, maybe use if (bool) instead of that ugly ternary! I wish Javascript had what Rust or Python have...if (bool)RustPythonUse the rest when it's truly necessary. Maybe benchmarks in your project perform sub-standard, and you found that a nasty if causes bad performance - if that's the case, feel free to get into branchless programming! But don't go too deep in that rabbit hole, nobody will benefit from things like -1 * (a < b) + 1 * (a > b), believe me.ifbranchlessprogramming-1 * (a < b) + 1 * (a > b)And some specifics:\nAvoid Number(bool). While it is true that the Chromium platform (Chrome + Edge) has about 68% market share globally, Safari 19% and Firefox a mere 3.6%, there are enough other fast-performing methods that won't fully sacrifice a percentage of your users. Firefox has 7% desktop market share, which amounts to a sizable number of 173 million users.\nIn older benchmarks, +bool performed similarly bad to Number in Firefox, maybe take this in consideration, too - bitwise hacks and multiplication give consistently performant results across all browsers, in all situations. bool | 0 has the best chance to be familiar to other developers.\nAvoid Number(bool). While it is true that the Chromium platform (Chrome + Edge) has about 68% market share globally, Safari 19% and Firefox a mere 3.6%, there are enough other fast-performing methods that won't fully sacrifice a percentage of your users. Firefox has 7% desktop market share, which amounts to a sizable number of 173 million users.Number(bool)In older benchmarks, +bool performed similarly bad to Number in Firefox, maybe take this in consideration, too - bitwise hacks and multiplication give consistently performant results across all browsers, in all situations. bool | 0 has the best chance to be familiar to other developers.+boolNumberbool | 0bool | 0I will be forever grateful to you for reading until the end - this is my first longer, significant StackOverflow answer and it means the world to me if it's been helpful and insightful. If you find any errors, feel free to correct me!EDIT: The previous benchmarking tool provided vague results, without an unit of measure. I've changed it, and also added benchmarks for Safari, which have influenced the conclusions.EDIT:\nDefined the conversion because it's not truly clear what boolean to integer means. For example, Go does not support this conversion at all.\nDefined the conversion because it's not truly clear what boolean to integer means. For example, Go does not support this conversion at all.Godoes not support this conversion at all",
                "When JavaScript is expecting a number value but receives a boolean instead it converts that boolean into a number: true and false convert into 1 and 0 respectively. So you can take advantage of this;\n\nvar t = true;\r\nvar f = false;\r\n\r\nconsole.log(t*1); // t*1 === 1\r\nconsole.log(f*1); // f*1 === 0 \r\n\r\nconsole.log(+t); // 0+t === 1 or shortened to +t === 1\r\nconsole.log(+f); //0+f === 0 or shortened to +f === 0\n\n\n\n\nvar t = true;\r\nvar f = false;\r\n\r\nconsole.log(t*1); // t*1 === 1\r\nconsole.log(f*1); // f*1 === 0 \r\n\r\nconsole.log(+t); // 0+t === 1 or shortened to +t === 1\r\nconsole.log(+f); //0+f === 0 or shortened to +f === 0\n\n\nvar t = true;\r\nvar f = false;\r\n\r\nconsole.log(t*1); // t*1 === 1\r\nconsole.log(f*1); // f*1 === 0 \r\n\r\nconsole.log(+t); // 0+t === 1 or shortened to +t === 1\r\nconsole.log(+f); //0+f === 0 or shortened to +f === 0\nvar t = true;\r\nvar f = false;\r\n\r\nconsole.log(t*1); // t*1 === 1\r\nconsole.log(f*1); // f*1 === 0 \r\n\r\nconsole.log(+t); // 0+t === 1 or shortened to +t === 1\r\nconsole.log(+f); //0+f === 0 or shortened to +f === 0var t = true;\r\nvar f = false;\r\n\r\nconsole.log(t*1); // t*1 === 1\r\nconsole.log(f*1); // f*1 === 0 \r\n\r\nconsole.log(+t); // 0+t === 1 or shortened to +t === 1\r\nconsole.log(+f); //0+f === 0 or shortened to +f === 0Further reading Type Conversions Chapter 3.8 of The Definitive Guide to Javascript.",
                "The unary + operator will take care of this:+var test = true;\n// +test === 1\ntest = false;\n// +test === 0\nvar test = true;\n// +test === 1\ntest = false;\n// +test === 0\nYou'll naturally want to sanity-check this on the server before storing it, so that might be a more sensible place to do this anyway, though.",
                "I was just dealing with this issue in some code I was writing. My solution was to use a bitwise and.var j = bool & 1;\nvar j = bool & 1;\nA quicker way to deal with a constant problem would be to create a function. It's more readable by other people, better for understanding at the maintenance stage, and gets rid of the potential for writing something wrong.function toInt( val ) {\n    return val & 1;\n}\n\nvar j = toInt(bool);\nfunction toInt( val ) {\n    return val & 1;\n}\n\nvar j = toInt(bool);\nEdit - September 10th, 2014Edit - September 10th, 2014No conversion using a ternary operator with the identical to operator is faster in Chrome for some reason. Makes no sense as to why it's faster, but I suppose it's some sort of low level optimization that makes sense somewhere along the way.var j = boolValue === true ? 1 : 0;\nvar j = boolValue === true ? 1 : 0;\nTest for yourself: http://jsperf.com/boolean-int-conversion/2http://jsperf.com/boolean-int-conversion/2In FireFox and Internet Explorer, using the version I posted is faster generally.Edit - July 14th, 2017Edit - July 14th, 2017Okay, I'm not going to tell you which one you should or shouldn't use. Every freaking browser has been going up and down in how fast they can do the operation with each method. Chrome at one point actually had the bitwise & version doing better than the others, but then it suddenly was much worse. I don't know what they're doing, so I'm just going to leave it at who cares. There's rarely any reason to care about how fast an operation like this is done. Even on mobile it's a nothing operation.Also, here's a newer method for adding a 'toInt' prototype that cannot be overwritten.Object.defineProperty(Boolean.prototype, \"toInt\", { value: function()\n{\n    return this & 1;\n}});\nObject.defineProperty(Boolean.prototype, \"toInt\", { value: function()\n{\n    return this & 1;\n}});\n",
                "You can also add 0, use shift operators or xor:val + 0;\nval ^ 0;\nval >> 0;\nval >>> 0;\nval << 0;\nval + 0;\nval ^ 0;\nval >> 0;\nval >>> 0;\nval << 0;\nThese have similar speeds as those from the others answers.",
                "In my context, React Native where I am getting opacity value from boolean, the easiest way: Use unary +  operator.+ true; // 1\n+ false; // 0\n+ true; // 1\n+ false; // 0\nThis converts the boolean into number;style={ opacity: +!isFirstStep() }\nstyle={ opacity: +!isFirstStep() }\n",
                "+!! allows you to apply this on a variable even when it's undefined:+!!undefined+!!undefined    // 0\n+!!false        // 0\n+!!true         // 1\n\n+!!(<boolean expression>)  // 1 if it evaluates to true, 0 otherwise\n+!!undefined    // 0\n+!!false        // 0\n+!!true         // 1\n\n+!!(<boolean expression>)  // 1 if it evaluates to true, 0 otherwise\n",
                "You could do this by simply extending the boolean prototypeBoolean.prototype.intval = function(){return ~~this}\nBoolean.prototype.intval = function(){return ~~this}\nIt is not too easy to understand what is going on there so an alternate version would be Boolean.prototype.intval = function(){return (this == true)?1:0}\nBoolean.prototype.intval = function(){return (this == true)?1:0}\nhaving done which you can do stuff likedocument.write(true.intval());\ndocument.write(true.intval());\nWhen I use booleans to store conditions I often convert them to bitfields in which case I end up using an extended version of the prototype functionBoolean.prototype.intval = function(places)\n{\n places = ('undefined' == typeof(places))?0:places; \n return (~~this) << places\n}\nBoolean.prototype.intval = function(places)\n{\n places = ('undefined' == typeof(places))?0:places; \n return (~~this) << places\n}\nwith which you can do document.write(true.intval(2))\ndocument.write(true.intval(2))\nwhich produces 4 as its output.",
                "let integerVariable = booleanVariable * 1;\nlet integerVariable = booleanVariable * 1;\n",
                "tryval*1\nval*1\n\n\nlet t=true;\r\nlet f=false;\r\n\r\nconsole.log(t*1);\r\nconsole.log(f*1)\n\n\n\n\nlet t=true;\r\nlet f=false;\r\n\r\nconsole.log(t*1);\r\nconsole.log(f*1)\n\n\nlet t=true;\r\nlet f=false;\r\n\r\nconsole.log(t*1);\r\nconsole.log(f*1)\nlet t=true;\r\nlet f=false;\r\n\r\nconsole.log(t*1);\r\nconsole.log(f*1)let t=true;\r\nlet f=false;\r\n\r\nconsole.log(t*1);\r\nconsole.log(f*1)",
                "I have tested all of this examples, I did a benchmark, and finally I recommend you choose the shorter one, it doesn't affect in performance.\nRunned in Ubuntu server 14.04, nodejs v8.12.0 - 26/10/18\nRunned in Ubuntu server 14.04, nodejs v8.12.0 - 26/10/18    let i = 0;\nconsole.time(\"TRUE test1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true ? 1 : 0;\n    }\nconsole.timeEnd(\"TRUE test1\")\n\n\nconsole.time(\"FALSE test2\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false ? 1 : 0;\n    }\nconsole.timeEnd(\"FALSE test2\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test1.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true === true ? 1 : 0;\n    }\nconsole.timeEnd(\"TRUE test1.1\")\n\n\nconsole.time(\"FALSE test2.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false === true ? 1 : 0;\n    }\nconsole.timeEnd(\"FALSE test2.1\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test3\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true | 0;\n    }\nconsole.timeEnd(\"TRUE test3\")\n\nconsole.time(\"FALSE test4\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false | 0;\n    }\nconsole.timeEnd(\"FALSE test4\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test5\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true * 1;\n    }\nconsole.timeEnd(\"TRUE test5\")\n\nconsole.time(\"FALSE test6\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false * 1;\n    }\nconsole.timeEnd(\"FALSE test6\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test7\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true & 1;\n    }\nconsole.timeEnd(\"TRUE test7\")\n\nconsole.time(\"FALSE test8\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false & 1;\n    }\nconsole.timeEnd(\"FALSE test8\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        +true;\n    }\nconsole.timeEnd(\"TRUE test9\")\n\nconsole.time(\"FALSE test10\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        +false;\n    }\nconsole.timeEnd(\"FALSE test10\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        0+true;\n    }\nconsole.timeEnd(\"TRUE test9.1\")\n\nconsole.time(\"FALSE test10.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        0+false;\n    }\nconsole.timeEnd(\"FALSE test10.1\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9.2\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        -true*-1;\n    }\nconsole.timeEnd(\"TRUE test9.2\")\n\nconsole.time(\"FALSE test10.2\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        -false*-1;\n    }\nconsole.timeEnd(\"FALSE test10.2\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9.3\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true-0;\n    }\nconsole.timeEnd(\"TRUE test9.3\")\n\nconsole.time(\"FALSE test10.3\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false-0;\n    }\nconsole.timeEnd(\"FALSE test10.3\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test11\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        Number(true);\n    }\nconsole.timeEnd(\"TRUE test11\")\n\nconsole.time(\"FALSE test12\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        Number(false);\n    }\nconsole.timeEnd(\"FALSE test12\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test13\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true + 0;\n    }\nconsole.timeEnd(\"TRUE test13\")\n\nconsole.time(\"FALSE test14\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false + 0;\n    }\nconsole.timeEnd(\"FALSE test14\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test15\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true ^ 0;\n    }\nconsole.timeEnd(\"TRUE test15\")\n\nconsole.time(\"FALSE test16\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false ^ 0;\n    }\nconsole.timeEnd(\"FALSE test16\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test17\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true ^ 0;\n    }\nconsole.timeEnd(\"TRUE test17\")\n\nconsole.time(\"FALSE test18\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false ^ 0;\n    }\nconsole.timeEnd(\"FALSE test18\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test19\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true >> 0;\n    }\nconsole.timeEnd(\"TRUE test19\")\n\nconsole.time(\"FALSE test20\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false >> 0;\n    }\nconsole.timeEnd(\"FALSE test20\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test21\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true >>> 0;\n    }\nconsole.timeEnd(\"TRUE test21\")\n\nconsole.time(\"FALSE test22\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false >>> 0;\n    }\nconsole.timeEnd(\"FALSE test22\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test23\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true << 0;\n    }\nconsole.timeEnd(\"TRUE test23\")\n\nconsole.time(\"FALSE test24\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false << 0;\n    }\nconsole.timeEnd(\"FALSE test24\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test25\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~~true;\n    }\nconsole.timeEnd(\"TRUE test25\")\n\nconsole.time(\"FALSE test26\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~~false;\n    }\nconsole.timeEnd(\"FALSE test26\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test25.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~true*-1-1;\n    }\nconsole.timeEnd(\"TRUE test25.1\")\n\nconsole.time(\"FALSE test26.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~false*-1-1;\n    }\nconsole.timeEnd(\"FALSE test26.1\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test27\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true/1;\n    }\nconsole.timeEnd(\"TRUE test27\")\n\nconsole.time(\"FALSE test28\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false/1;\n    }\nconsole.timeEnd(\"FALSE test28\")\n    let i = 0;\nconsole.time(\"TRUE test1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true ? 1 : 0;\n    }\nconsole.timeEnd(\"TRUE test1\")\n\n\nconsole.time(\"FALSE test2\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false ? 1 : 0;\n    }\nconsole.timeEnd(\"FALSE test2\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test1.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true === true ? 1 : 0;\n    }\nconsole.timeEnd(\"TRUE test1.1\")\n\n\nconsole.time(\"FALSE test2.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false === true ? 1 : 0;\n    }\nconsole.timeEnd(\"FALSE test2.1\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test3\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true | 0;\n    }\nconsole.timeEnd(\"TRUE test3\")\n\nconsole.time(\"FALSE test4\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false | 0;\n    }\nconsole.timeEnd(\"FALSE test4\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test5\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true * 1;\n    }\nconsole.timeEnd(\"TRUE test5\")\n\nconsole.time(\"FALSE test6\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false * 1;\n    }\nconsole.timeEnd(\"FALSE test6\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test7\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true & 1;\n    }\nconsole.timeEnd(\"TRUE test7\")\n\nconsole.time(\"FALSE test8\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false & 1;\n    }\nconsole.timeEnd(\"FALSE test8\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        +true;\n    }\nconsole.timeEnd(\"TRUE test9\")\n\nconsole.time(\"FALSE test10\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        +false;\n    }\nconsole.timeEnd(\"FALSE test10\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        0+true;\n    }\nconsole.timeEnd(\"TRUE test9.1\")\n\nconsole.time(\"FALSE test10.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        0+false;\n    }\nconsole.timeEnd(\"FALSE test10.1\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9.2\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        -true*-1;\n    }\nconsole.timeEnd(\"TRUE test9.2\")\n\nconsole.time(\"FALSE test10.2\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        -false*-1;\n    }\nconsole.timeEnd(\"FALSE test10.2\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test9.3\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true-0;\n    }\nconsole.timeEnd(\"TRUE test9.3\")\n\nconsole.time(\"FALSE test10.3\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false-0;\n    }\nconsole.timeEnd(\"FALSE test10.3\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test11\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        Number(true);\n    }\nconsole.timeEnd(\"TRUE test11\")\n\nconsole.time(\"FALSE test12\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        Number(false);\n    }\nconsole.timeEnd(\"FALSE test12\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test13\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true + 0;\n    }\nconsole.timeEnd(\"TRUE test13\")\n\nconsole.time(\"FALSE test14\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false + 0;\n    }\nconsole.timeEnd(\"FALSE test14\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test15\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true ^ 0;\n    }\nconsole.timeEnd(\"TRUE test15\")\n\nconsole.time(\"FALSE test16\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false ^ 0;\n    }\nconsole.timeEnd(\"FALSE test16\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test17\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true ^ 0;\n    }\nconsole.timeEnd(\"TRUE test17\")\n\nconsole.time(\"FALSE test18\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false ^ 0;\n    }\nconsole.timeEnd(\"FALSE test18\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test19\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true >> 0;\n    }\nconsole.timeEnd(\"TRUE test19\")\n\nconsole.time(\"FALSE test20\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false >> 0;\n    }\nconsole.timeEnd(\"FALSE test20\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test21\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true >>> 0;\n    }\nconsole.timeEnd(\"TRUE test21\")\n\nconsole.time(\"FALSE test22\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false >>> 0;\n    }\nconsole.timeEnd(\"FALSE test22\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test23\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true << 0;\n    }\nconsole.timeEnd(\"TRUE test23\")\n\nconsole.time(\"FALSE test24\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false << 0;\n    }\nconsole.timeEnd(\"FALSE test24\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test25\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~~true;\n    }\nconsole.timeEnd(\"TRUE test25\")\n\nconsole.time(\"FALSE test26\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~~false;\n    }\nconsole.timeEnd(\"FALSE test26\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test25.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~true*-1-1;\n    }\nconsole.timeEnd(\"TRUE test25.1\")\n\nconsole.time(\"FALSE test26.1\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        ~false*-1-1;\n    }\nconsole.timeEnd(\"FALSE test26.1\")\n\nconsole.log(\"----------------------------\")\n\nconsole.time(\"TRUE test27\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        true/1;\n    }\nconsole.timeEnd(\"TRUE test27\")\n\nconsole.time(\"FALSE test28\")\n    i=0;\n    for(;i<100000000;i=i+1){\n        false/1;\n    }\nconsole.timeEnd(\"FALSE test28\")\nResult TRUE test1: 93.301ms\nFALSE test2: 102.854ms\n----------------------------\nTRUE test1.1: 118.979ms\nFALSE test2.1: 119.061ms\n----------------------------\nTRUE test3: 97.265ms\nFALSE test4: 108.389ms\n----------------------------\nTRUE test5: 85.854ms\nFALSE test6: 87.449ms\n----------------------------\nTRUE test7: 83.126ms\nFALSE test8: 84.992ms\n----------------------------\nTRUE test9: 99.683ms\nFALSE test10: 87.080ms\n----------------------------\nTRUE test9.1: 85.587ms\nFALSE test10.1: 86.050ms\n----------------------------\nTRUE test9.2: 85.883ms\nFALSE test10.2: 89.066ms\n----------------------------\nTRUE test9.3: 86.722ms\nFALSE test10.3: 85.187ms\n----------------------------\nTRUE test11: 86.245ms\nFALSE test12: 85.808ms\n----------------------------\nTRUE test13: 84.192ms\nFALSE test14: 84.173ms\n----------------------------\nTRUE test15: 81.575ms\nFALSE test16: 81.699ms\n----------------------------\nTRUE test17: 81.979ms\nFALSE test18: 81.599ms\n----------------------------\nTRUE test19: 81.578ms\nFALSE test20: 81.452ms\n----------------------------\nTRUE test21: 115.886ms\nFALSE test22: 88.935ms\n----------------------------\nTRUE test23: 82.077ms\nFALSE test24: 81.822ms\n----------------------------\nTRUE test25: 81.904ms\nFALSE test26: 82.371ms\n----------------------------\nTRUE test25.1: 82.319ms\nFALSE test26.1: 96.648ms\n----------------------------\nTRUE test27: 89.943ms\nFALSE test28: 83.646ms\nTRUE test1: 93.301ms\nFALSE test2: 102.854ms\n----------------------------\nTRUE test1.1: 118.979ms\nFALSE test2.1: 119.061ms\n----------------------------\nTRUE test3: 97.265ms\nFALSE test4: 108.389ms\n----------------------------\nTRUE test5: 85.854ms\nFALSE test6: 87.449ms\n----------------------------\nTRUE test7: 83.126ms\nFALSE test8: 84.992ms\n----------------------------\nTRUE test9: 99.683ms\nFALSE test10: 87.080ms\n----------------------------\nTRUE test9.1: 85.587ms\nFALSE test10.1: 86.050ms\n----------------------------\nTRUE test9.2: 85.883ms\nFALSE test10.2: 89.066ms\n----------------------------\nTRUE test9.3: 86.722ms\nFALSE test10.3: 85.187ms\n----------------------------\nTRUE test11: 86.245ms\nFALSE test12: 85.808ms\n----------------------------\nTRUE test13: 84.192ms\nFALSE test14: 84.173ms\n----------------------------\nTRUE test15: 81.575ms\nFALSE test16: 81.699ms\n----------------------------\nTRUE test17: 81.979ms\nFALSE test18: 81.599ms\n----------------------------\nTRUE test19: 81.578ms\nFALSE test20: 81.452ms\n----------------------------\nTRUE test21: 115.886ms\nFALSE test22: 88.935ms\n----------------------------\nTRUE test23: 82.077ms\nFALSE test24: 81.822ms\n----------------------------\nTRUE test25: 81.904ms\nFALSE test26: 82.371ms\n----------------------------\nTRUE test25.1: 82.319ms\nFALSE test26.1: 96.648ms\n----------------------------\nTRUE test27: 89.943ms\nFALSE test28: 83.646ms\n",
                "Boolean to integer conversion in JavaScript can be done in the following ways:\nUsing Number()\nUsing Ternary\nUsing Unary Operators\nUsing Arithmetic Operators\nUsing Bitwise Operators\nUsing Bitwise Shift Operators\nUsing Number()Using Number()Number()Using TernaryUsing TernaryUsing Unary OperatorsUsing Unary OperatorsUsing Arithmetic OperatorsUsing Arithmetic OperatorsUsing Bitwise OperatorsUsing Bitwise OperatorsUsing Bitwise Shift OperatorsUsing Bitwise Shift OperatorsIn previous answers some of these have already been covered, however, you can find some that are missing as follows:// using arithmetic operators\n\ntrue + 0; // 1\nfalse + 0; // 0\n\ntrue - 0; // 1\nfalse - 0; // 0\n\ntrue * 1 // 1\nfalse * 1 // 0\n\ntrue / 1; // 1\nfalse / 1; // 0\n// using arithmetic operators\n\ntrue + 0; // 1\nfalse + 0; // 0\n\ntrue - 0; // 1\nfalse - 0; // 0\n\ntrue * 1 // 1\nfalse * 1 // 0\n\ntrue / 1; // 1\nfalse / 1; // 0\n// using bitwise operators\n\ntrue & 1; // 1\nfalse & 1; // 0\n\ntrue | 0; // 1\nfalse | 0; // 0\n\ntrue ^ 0; // 1\nfalse ^ 0; // 0\n// using bitwise operators\n\ntrue & 1; // 1\nfalse & 1; // 0\n\ntrue | 0; // 1\nfalse | 0; // 0\n\ntrue ^ 0; // 1\nfalse ^ 0; // 0\n// using bitwise shift operators\n\ntrue >> 0; // 1\nfalse >> 0; // 0\n\ntrue >>> 0; // 1\nfalse >>> 0; // 0\n\ntrue << 0; // 1\nfalse << 0; // 0\n// using bitwise shift operators\n\ntrue >> 0; // 1\nfalse >> 0; // 0\n\ntrue >>> 0; // 1\nfalse >>> 0; // 0\n\ntrue << 0; // 1\nfalse << 0; // 0\nThese work because JavaScript internally coerces booleans to their integer equivalents when performing these operations.An important point to note is that all these methods (except for using the ternary operator) can potentially return NaN when you're unsure of the variable always having a boolean value.using the ternary operatorNaNWrote a blog post for those interested in learning more.blog post",
                "Put suggested methods in jsben.ch:\nhttps://jsben.ch/d33N1.https://jsben.ch/d33N1It gives different results every test, but the best methods in every test are bitwise operations: 0|bool / bool|0 / 1&bool / 1&bool / ~~bool.0|boolbool|01&bool1&bool~~bool",
                "supported in all browsers, supports input as boolean or as a string representation of a booleanvar yourVarAsStringOrBoolean; \nyourVarAsStringOrBoolean = \"true\";   //1\nyourVarAsStringOrBoolean = \"True\";   //1\nyourVarAsStringOrBoolean = \"false\";  //0\nyourVarAsStringOrBoolean = false;    //0\n\nvar resultAsInterger = Number(JSON.parse(yourVarAsStringOrBoolean.toString().toLowerCase()));\nvar yourVarAsStringOrBoolean; \nyourVarAsStringOrBoolean = \"true\";   //1\nyourVarAsStringOrBoolean = \"True\";   //1\nyourVarAsStringOrBoolean = \"false\";  //0\nyourVarAsStringOrBoolean = false;    //0\n\nvar resultAsInterger = Number(JSON.parse(yourVarAsStringOrBoolean.toString().toLowerCase()));\nUse Chrome console to check it, it worksNumber(JSON.parse(false.toString().toLowerCase()));\nNumber(JSON.parse(\"TRUE\".toString().toLowerCase()));\nNumber(JSON.parse(false.toString().toLowerCase()));\nNumber(JSON.parse(\"TRUE\".toString().toLowerCase()));\n"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "How can I convert a character to a integer in Python, and viceversa?",
                "how do i convert the character in to the integer in python?",
                "how can i convert a character to an integer with python?"
            ],
            "responses": [
                "Use chr() and ord():chr()chr()ord()ord()>>> chr(97)\n'a'\n>>> ord('a')\n97\n>>> chr(97)\n'a'\n>>> ord('a')\n97\n",
                ">>> ord('a')\n97\n>>> chr(97)\n'a'\n>>> ord('a')\n97\n>>> chr(97)\n'a'\n",
                "ord and chr",
                "For long string you could use this. ''.join(map(str, map(ord, 'pantente')))\n ''.join(map(str, map(ord, 'pantente')))\n"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "Why doesn't Java support unsigned ints?",
                "why does java don't support unsigned ints?",
                "why isn't java supported for unsigned ints?",
                "why can't java support unsigned ints?",
                "why don't java support unsigned ints?",
                "why doesn't java support unsigned ints?"
            ],
            "responses": [
                "This is from an interview with Gosling and others, about simplicity:interview with Gosling and others\nGosling: For me as a language designer, which I don't really count myself as these days, what \"simple\" really ended up meaning was could I expect J. Random Developer to hold the spec in his head. That definition says that, for instance, Java isn't -- and in fact a lot of these languages end up with a lot of corner cases, things that nobody really understands. Quiz any C developer about unsigned, and pretty soon you discover that almost no C developers actually understand what goes on with unsigned, what unsigned arithmetic is. Things like that made C complex. The language part of Java is, I think, pretty simple. The libraries you have to look up.\nGosling: For me as a language designer, which I don't really count myself as these days, what \"simple\" really ended up meaning was could I expect J. Random Developer to hold the spec in his head. That definition says that, for instance, Java isn't -- and in fact a lot of these languages end up with a lot of corner cases, things that nobody really understands. Quiz any C developer about unsigned, and pretty soon you discover that almost no C developers actually understand what goes on with unsigned, what unsigned arithmetic is. Things like that made C complex. The language part of Java is, I think, pretty simple. The libraries you have to look up.",
                "Reading between the lines, I think the logic was something like this:\ngenerally, the Java designers wanted to simplify the repertoire of data types available\nfor everyday purposes, they felt that the most common need was for signed data types\nfor implementing certain algorithms, unsigned arithmetic is sometimes needed, but the kind of programmers that would be implementing such algorithms would also have the knowledge to \"work round\" doing unsigned arithmetic with signed data types\ngenerally, the Java designers wanted to simplify the repertoire of data types availablefor everyday purposes, they felt that the most common need was for signed data typesfor implementing certain algorithms, unsigned arithmetic is sometimes needed, but the kind of programmers that would be implementing such algorithms would also have the knowledge to \"work round\" doing unsigned arithmetic with signed data typesMostly, I'd say it was a reasonable decision. Possibly, I would have:\nmade byte unsigned, or at least have provided a signed/unsigned alternatives, possibly with different names, for this one data type (making it signed is good for consistency, but when do you ever need a signed byte?)\ndone away with 'short' (when did you last use 16-bit signed arithmetic?)\nmade byte unsigned, or at least have provided a signed/unsigned alternatives, possibly with different names, for this one data type (making it signed is good for consistency, but when do you ever need a signed byte?)done away with 'short' (when did you last use 16-bit signed arithmetic?)Still, with a bit of kludging, operations on unsigned values up to 32 bits aren't tooo bad, and most people don't need unsigned 64-bit division or comparison.",
                "This is an older question and pat did briefly mention char, I just thought I should expand upon this for others who will look at this down the road. Let's take a closer look at the Java primitive types:byte - 8-bit signed integerbyteshort - 16-bit signed integershortint - 32-bit signed integerintlong - 64-bit signed integerlongchar - 16-bit character (unsigned integer)charAlthough char does not support unsigned arithmetic, it essentially can be treated as an unsigned integer. You would have to explicitly cast arithmetic operations back into char, but it does provide you with a way to specify unsigned numbers.charunsignedunsignedcharunsignedchar a = 0;\nchar b = 6;\na += 1;\na = (char) (a * b);\na = (char) (a + b);\na = (char) (a - 16);\nb = (char) (b % 3);\nb = (char) (b / a);\n//a = -1; // Generates complier error, must be cast to char\nSystem.out.println(a); // Prints ? \nSystem.out.println((int) a); // Prints 65532\nSystem.out.println((short) a); // Prints -4\nshort c = -4;\nSystem.out.println((int) c); // Prints -4, notice the difference with char\na *= 2;\na -= 6;\na /= 3;\na %= 7;\na++;\na--;\nchar a = 0;\nchar b = 6;\na += 1;\na = (char) (a * b);\na = (char) (a + b);\na = (char) (a - 16);\nb = (char) (b % 3);\nb = (char) (b / a);\n//a = -1; // Generates complier error, must be cast to char\nSystem.out.println(a); // Prints ? \nSystem.out.println((int) a); // Prints 65532\nSystem.out.println((short) a); // Prints -4\nshort c = -4;\nSystem.out.println((int) c); // Prints -4, notice the difference with char\na *= 2;\na -= 6;\na /= 3;\na %= 7;\na++;\na--;\nYes, there isn't direct support for unsigned integers (obviously, I wouldn't have to cast most of my operations back into char if there was direct support). However, there certainly exists an unsigned primitive data type. I would liked to have seen an unsigned byte as well, but I guess doubling the memory cost and instead use char is a viable option.EditWith JDK8 there are new APIs for Long and Integer which provide helper methods when treating long and int values as unsigned values.LongLongIntegerIntegerlongint\ncompareUnsigned\ndivideUnsigned\nparseUnsignedInt\nparseUnsignedLong\nremainderUnsigned\ntoUnsignedLong\ntoUnsignedString\ncompareUnsignedcompareUnsigneddivideUnsigneddivideUnsignedparseUnsignedIntparseUnsignedIntparseUnsignedLongparseUnsignedLongremainderUnsignedremainderUnsignedtoUnsignedLongtoUnsignedLongtoUnsignedStringtoUnsignedStringAdditionally, Guava provides a number of helper methods to do similar things for at the integer types which helps close the gap left by the lack of native support for unsigned integers.Guavaunsigned",
                "Java does have unsigned types, or at least one:  char is an unsigned short.  So whatever excuse Gosling throws up it's really just his ignorance why there are no other unsigned types.Also Short types:  shorts are used all the time for multimedia.  The reason is you can fit 2 samples in a single 32-bit unsigned long and vectorize many operations.   Same thing with 8-bit data and unsigned byte.  You can fit 4 or 8 samples in a register for vectorizing.",
                "As soon as signed and unsigned ints are mixed in an expression things start to get messy and you probably will lose information. Restricting Java to signed ints only really clears things up. I\u2019m glad I don\u2019t have to worry about the whole signed/unsigned business, though I sometimes do miss the 8th bit in a byte.will",
                "http://skeletoncoder.blogspot.com/2006/09/java-tutorials-why-no-unsigned.htmlhttp://skeletoncoder.blogspot.com/2006/09/java-tutorials-why-no-unsigned.htmlThis guy says because the C standard defines operations involving unsigned and signed ints to be treated as unsigned. This could cause negative signed integers to roll around into a large unsigned int, potentially causing bugs.",
                "I think Java is fine as it is, adding unsigned would complicate it without much gain.\nEven with the simplified integer model, most Java programmers don't know how the basic numeric types behave - just read the book Java Puzzlers to see what misconceptions you might hold.Java PuzzlersAs for practical advice:\nIf your values are somewhat arbitrary size and don't fit into int, use long.\nIf they don't fit into long use BigInteger.\nUse the smaller types only for arrays when you need to save space.\nIf you need exactly 64/32/16/8 bits, use long/int/short/byte and stop worrying about the sign bit, except for division, comparison, right shift, and casting.\nIf your values are somewhat arbitrary size and don't fit into int, use long.\nIf they don't fit into long use BigInteger.If your values are somewhat arbitrary size and don't fit into int, use long.\nIf they don't fit into long use BigInteger.intlonglongBigIntegerUse the smaller types only for arrays when you need to save space.Use the smaller types only for arrays when you need to save space.If you need exactly 64/32/16/8 bits, use long/int/short/byte and stop worrying about the sign bit, except for division, comparison, right shift, and casting.If you need exactly 64/32/16/8 bits, use long/int/short/byte and stop worrying about the sign bit, except for division, comparison, right shift, and casting.longintshortbyteSee also this answer about \"porting a random number generator from C to Java\".this",
                "I know this post is too old; however for your interest, in Java 8 and later, you can use the int data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 232\u22121. Use the Integer class to use int data type as an unsigned integer and static methods like compareUnsigned(), divideUnsigned() etc. have been added to the Integer class to support the arithmetic operations for unsigned integers.int32IntegerintcompareUnsigned()divideUnsigned()Integer",
                "With JDK8 it does have some support for them.JDK8We may yet see full support of unsigned types in Java despite Gosling's concerns.",
                "I've heard stories that they were to be included close to the orignal Java release. Oak was the precursor to Java, and in some spec documents there was mention of usigned values. Unfortunately these never made it into the Java language. As far as anyone has been able to figure out they just didn't get implemented, likely due to a time constraint.",
                "I once took a C++ course with someone on the C++ standards committee who implied that Java made the right decision to avoid having unsigned integers because (1) most programs that use unsigned integers can do just as well with signed integers and this is more natural in terms of how people think, and (2) using unsigned integers results in lots easy to create but difficult to debug issues such as integer arithmetic overflow and losing significant bits when converting between signed and unsigned types. If you mistakenly subtract 1 from 0 using signed integers it often more quickly causes your program to crash and makes it easier to find the bug than if it wraps around to 2^32 - 1, and compilers and static analysis tools and runtime checks have to assume you know what you're doing since you chose to use unsigned arithmetic. Also, negative numbers like -1 can often represent something useful, like a field being ignored/defaulted/unset while if you were using unsigned you'd have to reserve a special value like 2^32 - 1 or something similar.Long ago, when memory was limited and processors did not automatically operate on 64 bits at once, every bit counted a lot more, so having signed vs unsigned bytes or shorts actually mattered a lot more often and was obviously the right design decision. Today just using a signed int is more than sufficient in almost all regular programming cases, and if your program really needs to use values bigger than 2^31 - 1, you often just want a long anyway. Once you're into the territory of using longs, it's even harder to come up with a reason why you really can't get by with 2^63 - 1 positive integers. Whenever we go to 128 bit processors it'll be even less of an issue.",
                "Your question is \"Why doesn't Java support unsigned ints\"?And my answer to your question is that Java wants that all of it's primitive types: byte, char, short, int and long should be treated as byte, word, dword and qword respectively, exactly like in assembly, and the Java operators are signed operations on all of it's primitive types except for char, but only on char they are unsigned 16 bit only.bytecharshortintlongbyteworddwordqwordsignedcharcharSo static methods suppose to be the unsigned operations also for both 32 and 64 bit.unsignedalsoYou need final class, whose static methods can be called for the unsigned operations.unsignedYou can create this final class, call it whatever name you want and implement it's static methods.If you have no idea about how to implement the static methods then this link may help you.linkIn my opinion, Java is not similar to C++ at all, if it neither support unsigned types nor operator overloading, so I think that Java should be treated as completely different language from both C++ and from C.notat allneithernorIt is also completely different in the name of the languages by the way.So I don't recommend in Java to type code similar to C and I don't recommend to type code similar to C++ at all, because then in Java you won't be able to do what you want to do next in C++, i.e. the code won't continue to be C++ like at all and for me this is bad to code like that, to change the style in the middle.I recommend to write and use static methods also for the signed operations, so you don't see in the code mixture of operators and static methods for both signed and unsigned operations, unless you need only signed operations in the code, and it's okay to use the operators only.Also I recommend to avoid using short, int and long primitive types, and use word, dword and qword respectively instead, and you are about call the static methods for unsigned operations and/or signed operations instead of using operators.shortintlongworddwordqwordIf you are about to do signed operations only and use the operators only in the code, then this is okay to use these primitive types short, int and long.shortintlongActually word, dword and qword don't exist in the language, but you can create new class for each and the implementation of each should be very easy:worddwordqwordn'tThe class word holds the primitive type short only, the class dword holds the primitive type int only and the class qword holds the primitive type long only. Now all the unsigned and the signed methods as static or not as your choice, you can implement in each class, i.e. all the 16 bit operations both unsigned and signed by giving meaning names on the word class, all the 32 bit operations both unsigned and signed by giving meaning names on the dword class and all the 64 bit operations both unsigned and signed by giving meaning names on the qword class.wordshortdwordintqwordlongworddwordqwordIf you don't like giving too many different names for each method, you can always use overloading in Java, good to read that Java didn't remove that too!n'tIf you want methods rather than operators for 8 bit signed operations and methods for 8 bit unsigned operations that have no operators at all, then you can create the Byte class (note that the first letter 'B' is capital, so this is not the primitive type byte) and implement the methods in this class.BytebyteAbout passing by value and passing by reference:If I am not wrong, like in C#, primitive objects are passed by value naturally, but class objects are passed by reference naturally, so that means that objects of type Byte, word, dword and qword will be passed by reference and not by value by default. I wish Java had struct objects as C# has, \nso all Byte, word, dword and qword could be implemented to be struct instead of class, so by default they were passed by value and not by reference by default, like any struct object in C#, like the primitive types, are passed by value and not by reference by default, but because that Java is worse than C# and we have to deal with that, then there is only classes and interfaces, that are passed by reference and not by value by default. So if you want to pass Byte, word, dword and qword objects by value and not by reference, like any other class object in Java and also in C#, you will have to simply use the copy constructor and that's it.ByteworddwordqwordstructByteworddwordqwordstructclassByteworddwordqwordThat's the only solution that I can think about. I just wish that I could just typedef the primitive types to word, dword and qword, but Java neither support typedef nor using at all, unlike C# that supports using, which is equivalent to the C's typedef.usingAbout output:For the same sequence of bits, you can print them in many ways: As binary, as decimal (like the meaning of %u in C printf), as octal (like the meaning of %o in C printf), as hexadecimal (like the meaning of %x in C printf) and as integer (like the meaning of the %d in C printf).sequence of bitsNote that C printf doesn't know the type of the variables being passed as parameters to the function, so printf knows the type of each variable only from the char* object passed to the first parameter of the function.So in each of the classes: Byte, word, dword and qword, you can implement print method and get the functionality of printf, even though the primitive type of the class is signed, you still can print it as unsigned by following some algorithm involving logical and shift operations to get the digits to print to the output.ByteworddwordqwordUnfortunately the link I gave you doesn't show how to implement these print methods, but I am sure you can google for the algorithms you need to implement these print methods.That's all I can answer your question and suggest you.",
                "Because unsigned type is pure evil.unsignedThe fact that in C unsigned - int produces unsigned is even more evil.unsigned - intunsignedHere is a snapshot of the problem that burned me more than once:// We have odd positive number of rays, \n// consecutive ones at angle delta from each other.\nassert( rays.size() > 0 && rays.size() % 2 == 1 );\n\n// Get a set of ray at delta angle between them.\nfor( size_t n = 0; n < rays.size(); ++n )\n{\n    // Compute the angle between nth ray and the middle one.\n    // The index of the middle one is (rays.size() - 1) / 2,\n    // the rays are evenly spaced at angle delta, therefore\n    // the magnitude of the angle between nth ray and the \n    // middle one is: \n    double angle = delta * fabs( n - (rays.size() - 1) / 2 ); \n\n    // Do something else ...\n}\n// We have odd positive number of rays, \n// consecutive ones at angle delta from each other.\nassert( rays.size() > 0 && rays.size() % 2 == 1 );\n\n// Get a set of ray at delta angle between them.\nfor( size_t n = 0; n < rays.size(); ++n )\n{\n    // Compute the angle between nth ray and the middle one.\n    // The index of the middle one is (rays.size() - 1) / 2,\n    // the rays are evenly spaced at angle delta, therefore\n    // the magnitude of the angle between nth ray and the \n    // middle one is: \n    double angle = delta * fabs( n - (rays.size() - 1) / 2 ); \n\n    // Do something else ...\n}\nHave you noticed the bug yet? I confess I only saw it after stepping in with the debugger. Because n is of unsigned type size_t the entire expression n - (rays.size() - 1) / 2 evaluates as unsigned. That expression is intended to be a signed position of the nth ray from the middle one: the 1st ray from the middle one on the left side would have position -1, the 1st one on the right would have position +1, etc. After taking abs value and multiplying by the delta angle I would get the angle between nth ray and the middle one.nsize_tn - (rays.size() - 1) / 2unsignedsignedndeltanUnfortunately for me the above expression contained the evil unsigned and instead of evaluating to, say, -1, it evaluated to 2^32-1. The subsequent conversion to double sealed the bug.doubleAfter a bug or two caused by misuse of unsigned arithmetic one has to start wondering whether the extra bit one gets is worth the extra trouble. I am trying, as much as feasible, to avoid any use of unsigned types in arithmetic, although still use it for non-arithmetic operations such as binary masks.unsignedunsigned",
                "There's a few gems in the 'C' spec that Java dropped for pragmatic reasons but which are slowly creeping back with developer demand (closures, etc).I mention a first one because it's related to this discussion; the adherence of pointer values to unsigned integer arithmetic. And, in relation to this thread topic, the difficulty of maintaining Unsigned semantics in the Signed world of Java.I would guess if one were to get a Dennis Ritchie alter ego to advise Gosling's design team it would have suggested giving Signed's a \"zero at infinity\", so that all address offset requests would first add their ALGEBRAIC RING SIZE to obviate negative values.That way, any offset thrown at the array can never generate a SEGFAULT. For example in an encapsulated class which I call RingArray of doubles that needs unsigned behaviour - in \"self rotating loop\" context:// ...\n// Housekeeping state variable\nlong entrycount;     // A sequence number\nint cycle;           // Number of loops cycled\nint size;            // Active size of the array because size<modulus during cycle 0\nint modulus;         // Maximal size of the array\n\n// Ring state variables\nprivate int head;   // The 'head' of the Ring\nprivate int tail;   // The ring iterator 'cursor'\n// tail may get the current cursor position\n// and head gets the old tail value\n// there are other semantic variations possible\n\n// The Array state variable\ndouble [] darray;    // The array of doubles\n\n// somewhere in constructor\npublic RingArray(int modulus) {\n    super();\n    this.modulus = modulus;\n    tail =  head =  cycle = 0;\n    darray = new double[modulus];\n// ...\n}\n// ...\ndouble getElementAt(int offset){\n    return darray[(tail+modulus+offset%modulus)%modulus];\n}\n//  remember, the above is treating steady-state where size==modulus\n// ...\n// ...\n// Housekeeping state variable\nlong entrycount;     // A sequence number\nint cycle;           // Number of loops cycled\nint size;            // Active size of the array because size<modulus during cycle 0\nint modulus;         // Maximal size of the array\n\n// Ring state variables\nprivate int head;   // The 'head' of the Ring\nprivate int tail;   // The ring iterator 'cursor'\n// tail may get the current cursor position\n// and head gets the old tail value\n// there are other semantic variations possible\n\n// The Array state variable\ndouble [] darray;    // The array of doubles\n\n// somewhere in constructor\npublic RingArray(int modulus) {\n    super();\n    this.modulus = modulus;\n    tail =  head =  cycle = 0;\n    darray = new double[modulus];\n// ...\n}\n// ...\ndouble getElementAt(int offset){\n    return darray[(tail+modulus+offset%modulus)%modulus];\n}\n//  remember, the above is treating steady-state where size==modulus\n// ...\nThe above RingArray would never ever 'get' from a negative index, even if a malicious requestor tried to. Remember, there are also many legitimate requests for asking for prior (negative) index values.NB: The outer %modulus de-references legitimate requests whereas the inner %modulus masks out blatant malice from negatives more negative than -modulus. If this were to ever appear in a Java +..+9 || 8+..+ spec, then the problem would genuinely become a 'programmer who cannot \"self rotate\" FAULT'.I'm sure the so-called Java unsigned int 'deficiency' can be made up for with the above one-liner.PS: Just to give context to above RingArray housekeeping, here's a candidate 'set' operation to match the above 'get' element operation:void addElement(long entrycount,double value){ // to be called only by the keeper of entrycount\n    this.entrycount= entrycount;\n    cycle = (int)entrycount/modulus;\n    if(cycle==0){                       // start-up is when the ring is being populated the first time around\n        size = (int)entrycount;         // during start-up, size is less than modulus so use modulo size arithmetic\n        tail = (int)entrycount%size;    //  during start-up\n    }\n    else {\n        size = modulus;\n        head = tail;\n        tail = (int)entrycount%modulus; //  after start-up\n    }\n    darray[head] = value;               //  always overwrite old tail\n}\nvoid addElement(long entrycount,double value){ // to be called only by the keeper of entrycount\n    this.entrycount= entrycount;\n    cycle = (int)entrycount/modulus;\n    if(cycle==0){                       // start-up is when the ring is being populated the first time around\n        size = (int)entrycount;         // during start-up, size is less than modulus so use modulo size arithmetic\n        tail = (int)entrycount%size;    //  during start-up\n    }\n    else {\n        size = modulus;\n        head = tail;\n        tail = (int)entrycount%modulus; //  after start-up\n    }\n    darray[head] = value;               //  always overwrite old tail\n}\n",
                "I can think of one unfortunate side-effect. In java embedded databases, the number of ids you can have with a 32bit id field is 2^31, not 2^32 (~2billion, not ~4billion).",
                "The reason IMHO is because they are/were too lazy to implement/correct that mistake. \nSuggesting that C/C++ programmers does not understand unsigned, structure, union, bit flag... Is just preposterous.Ether you were talking with a basic/bash/java programmer on the verge of beginning programming a la C, without any real knowledge this language or you are just talking out of your own mind. ;)when you deal every day on format either from file or hardware you begin to question, what in the hell they were thinking.A good example here would be trying to use an unsigned byte as a self rotating loop. \nFor those of you who do not understand the last sentence, how on earth you call yourself a programmer. DC"
            ]
        },
        {
            "tag": "ios",
            "patterns": [
                "Converting String to Int with Swift",
                "the conversion from string to int in swift is"
            ],
            "responses": [
                "Updated answer for Swift 2.0+:Updated answer for Swift 2.0+toInt() method gives an error, as it was removed from String in Swift 2.x. Instead, the Int type now has an initializer that accepts a String:toInt()StringIntStringlet a: Int? = Int(firstTextField.text)\nlet b: Int? = Int(secondTextField.text)\nlet a: Int? = Int(firstTextField.text)\nlet b: Int? = Int(secondTextField.text)\n",
                "Basic Idea, note that this only works in Swift 1.x (check out ParaSara's answer to see how it works in Swift 2.x):note that this only works in Swift 1.xParaSara's answer    // toInt returns optional that's why we used a:Int?\n    let a:Int? = firstText.text.toInt() // firstText is UITextField\n    let b:Int? = secondText.text.toInt() // secondText is UITextField\n\n    // check a and b before unwrapping using !\n    if a && b {\n        var ans = a! + b!\n        answerLabel.text = \"Answer is \\(ans)\" // answerLabel ie UILabel\n    } else {\n        answerLabel.text = \"Input values are not numeric\"\n    }\n    // toInt returns optional that's why we used a:Int?\n    let a:Int? = firstText.text.toInt() // firstText is UITextField\n    let b:Int? = secondText.text.toInt() // secondText is UITextField\n\n    // check a and b before unwrapping using !\n    if a && b {\n        var ans = a! + b!\n        answerLabel.text = \"Answer is \\(ans)\" // answerLabel ie UILabel\n    } else {\n        answerLabel.text = \"Input values are not numeric\"\n    }\nUpdate for Swift 4...\nlet a:Int? = Int(firstText.text) // firstText is UITextField\nlet b:Int? = Int(secondText.text) // secondText is UITextField\n...\n...\nlet a:Int? = Int(firstText.text) // firstText is UITextField\nlet b:Int? = Int(secondText.text) // secondText is UITextField\n...\n",
                "myString.toInt() -  convert the string value into int .myString.toInt()Swift 3.x Swift 3.xIf you have an integer hiding inside a string, you can convertby using the integer's constructor, like this:let myInt = Int(textField.text)\nlet myInt = Int(textField.text)\nAs with other data types (Float and Double) you can also convert by using NSString:let myString = \"556\"\nlet myInt = (myString as NSString).integerValue\nlet myString = \"556\"\nlet myInt = (myString as NSString).integerValue\n",
                "You can use NSNumberFormatter().numberFromString(yourNumberString). It's great because it returns an an optional that you can then test with if let to determine if the conversion was successful. \neg. NSNumberFormatter().numberFromString(yourNumberString)if letvar myString = \"\\(10)\"\nif let myNumber = NSNumberFormatter().numberFromString(myString) {\n    var myInt = myNumber.integerValue\n    // do what you need to do with myInt\n} else {\n    // what ever error code you need to write\n}\nvar myString = \"\\(10)\"\nif let myNumber = NSNumberFormatter().numberFromString(myString) {\n    var myInt = myNumber.integerValue\n    // do what you need to do with myInt\n} else {\n    // what ever error code you need to write\n}\nSwift 5var myString = \"\\(10)\"\nif let myNumber = NumberFormatter().number(from: myString) {\n    var myInt = myNumber.intValue\n    // do what you need to do with myInt\n  } else {\n    // what ever error code you need to write\n  }\nvar myString = \"\\(10)\"\nif let myNumber = NumberFormatter().number(from: myString) {\n    var myInt = myNumber.intValue\n    // do what you need to do with myInt\n  } else {\n    // what ever error code you need to write\n  }\n",
                "edit/update: Xcode 11.4 \u2022 Swift 5.2Xcode 11.4 \u2022 Swift 5.2Please check the comments through the codeIntegerField.swift file contents:IntegerField.swiftimport UIKit\n\nclass IntegerField: UITextField {\n\n    // returns the textfield contents, removes non digit characters and converts the result to an integer value\n    var value: Int { string.digits.integer ?? 0 }\n\n    var maxValue: Int = 999_999_999\n    private var lastValue: Int = 0\n\n    override func willMove(toSuperview newSuperview: UIView?) {\n        // adds a target to the textfield to monitor when the text changes\n        addTarget(self, action: #selector(editingChanged), for: .editingChanged)\n        // sets the keyboard type to digits only\n        keyboardType = .numberPad\n        // set the text alignment to right\n        textAlignment = .right\n        // sends an editingChanged action to force the textfield to be updated\n        sendActions(for: .editingChanged)\n    }\n    // deletes the last digit of the text field\n    override func deleteBackward() {\n        // note that the field text property default value is an empty string so force unwrap its value is safe\n        // note also that collection remove at requires a non empty collection which is true as well in this case so no need to check if the collection is not empty.\n        text!.remove(at: text!.index(before: text!.endIndex))\n        // sends an editingChanged action to force the textfield to be updated\n        sendActions(for: .editingChanged)\n    }\n    @objc func editingChanged() {\n        guard value <= maxValue else {\n            text = Formatter.decimal.string(for: lastValue)\n            return\n        }\n        // This will format the textfield respecting the user device locale and settings\n        text = Formatter.decimal.string(for: value)\n        print(\"Value:\", value)\n        lastValue = value\n    }\n}\nimport UIKit\n\nclass IntegerField: UITextField {\n\n    // returns the textfield contents, removes non digit characters and converts the result to an integer value\n    var value: Int { string.digits.integer ?? 0 }\n\n    var maxValue: Int = 999_999_999\n    private var lastValue: Int = 0\n\n    override func willMove(toSuperview newSuperview: UIView?) {\n        // adds a target to the textfield to monitor when the text changes\n        addTarget(self, action: #selector(editingChanged), for: .editingChanged)\n        // sets the keyboard type to digits only\n        keyboardType = .numberPad\n        // set the text alignment to right\n        textAlignment = .right\n        // sends an editingChanged action to force the textfield to be updated\n        sendActions(for: .editingChanged)\n    }\n    // deletes the last digit of the text field\n    override func deleteBackward() {\n        // note that the field text property default value is an empty string so force unwrap its value is safe\n        // note also that collection remove at requires a non empty collection which is true as well in this case so no need to check if the collection is not empty.\n        text!.remove(at: text!.index(before: text!.endIndex))\n        // sends an editingChanged action to force the textfield to be updated\n        sendActions(for: .editingChanged)\n    }\n    @objc func editingChanged() {\n        guard value <= maxValue else {\n            text = Formatter.decimal.string(for: lastValue)\n            return\n        }\n        // This will format the textfield respecting the user device locale and settings\n        text = Formatter.decimal.string(for: value)\n        print(\"Value:\", value)\n        lastValue = value\n    }\n}\nYou would need to add those extensions to your project as well:Extensions UITextField.swift file contents:Extensions UITextField.swiftimport UIKit\nextension UITextField {\n    var string: String { text ?? \"\" }\n}\nimport UIKit\nextension UITextField {\n    var string: String { text ?? \"\" }\n}\nExtensions Formatter.swift file contents:Extensions Formatter.swiftimport Foundation\nextension Formatter {\n    static let decimal = NumberFormatter(numberStyle: .decimal)\n}\nimport Foundation\nextension Formatter {\n    static let decimal = NumberFormatter(numberStyle: .decimal)\n}\nExtensions NumberFormatter.swift file contents:Extensions NumberFormatter.swiftimport Foundation\nextension NumberFormatter {\n    convenience init(numberStyle: Style) {\n        self.init()\n        self.numberStyle = numberStyle\n    }\n}\nimport Foundation\nextension NumberFormatter {\n    convenience init(numberStyle: Style) {\n        self.init()\n        self.numberStyle = numberStyle\n    }\n}\nExtensions StringProtocol.swift file contents:Extensions StringProtocol.swiftextension StringProtocol where Self: RangeReplaceableCollection {\n    var digits: Self { filter(\\.isWholeNumber) }\n    var integer: Int? { Int(self) }\n}\nextension StringProtocol where Self: RangeReplaceableCollection {\n    var digits: Self { filter(\\.isWholeNumber) }\n    var integer: Int? { Int(self) }\n}\nSample projectSample project",
                "swift 4.0swift 4.0let stringNumber = \"123\"\nlet number = Int(stringNumber) //here number is of type \"Int?\"\n\n\n//using Forced Unwrapping\n\nif number != nil {         \n //string is converted to Int\n}\nlet stringNumber = \"123\"\nlet number = Int(stringNumber) //here number is of type \"Int?\"\n\n\n//using Forced Unwrapping\n\nif number != nil {         \n //string is converted to Int\n}\nyou could also use Optional Binding other than forced binding.eg:  if let number = Int(stringNumber) { \n   // number is of type Int \n  }\n  if let number = Int(stringNumber) { \n   // number is of type Int \n  }\n",
                "//Xcode 8.1 and swift 3.0//Xcode 8.1 and swift 3.0We can also handle it by Optional Binding, Simplylet occur = \"10\"\n\nif let occ = Int(occur) {\n        print(\"By optional binding :\", occ*2) // 20\n\n    }\nlet occur = \"10\"\n\nif let occ = Int(occur) {\n        print(\"By optional binding :\", occ*2) // 20\n\n    }\n",
                "In Swift 4.2 and Xcode 10.1Swift 4.2Xcode 10.1let string = \"789\"\nif let intValue = Int(string) {\n    print(intValue)\n}\nlet string = \"789\"\nif let intValue = Int(string) {\n    print(intValue)\n}\n\nlet integerValue = 789\nlet stringValue = String(integerValue)\n\nOR\nlet stringValue = \"\\(integerValue)\"\nprint(stringValue)\n\nlet integerValue = 789\nlet stringValue = String(integerValue)\nlet integerValue = 789\nlet stringValue = String(integerValue)\nORlet stringValue = \"\\(integerValue)\"\nprint(stringValue)\nlet stringValue = \"\\(integerValue)\"\nprint(stringValue)\n",
                "Swift 3Swift 3The simplest and more secure way is:@IBOutlet var textFieldA  : UITextField\n@IBOutlet var textFieldB  : UITextField\n@IBOutlet var answerLabel : UILabel\n\n@IBAction func calculate(sender : AnyObject) {\n\n      if let intValueA = Int(textFieldA),\n            let intValueB = Int(textFieldB) {\n            let result = intValueA + intValueB\n            answerLabel.text = \"The acceleration is \\(result)\"\n      }\n      else {\n             answerLabel.text = \"The value \\(intValueA) and/or \\(intValueB) are not a valid integer value\"\n      }        \n}\n@IBOutlet var textFieldA  : UITextField\n@IBOutlet var textFieldB  : UITextField\n@IBOutlet var answerLabel : UILabel\n\n@IBAction func calculate(sender : AnyObject) {\n\n      if let intValueA = Int(textFieldA),\n            let intValueB = Int(textFieldB) {\n            let result = intValueA + intValueB\n            answerLabel.text = \"The acceleration is \\(result)\"\n      }\n      else {\n             answerLabel.text = \"The value \\(intValueA) and/or \\(intValueB) are not a valid integer value\"\n      }        \n}\nAvoid invalid values setting keyboard type to number pad: textFieldA.keyboardType = .numberPad\n textFieldB.keyboardType = .numberPad\n textFieldA.keyboardType = .numberPad\n textFieldB.keyboardType = .numberPad\n",
                "In Swift 4:extension String {            \n    var numberValue:NSNumber? {\n        let formatter = NumberFormatter()\n        formatter.numberStyle = .decimal\n        return formatter.number(from: self)\n    }\n}\nlet someFloat = \"12\".numberValue\nextension String {            \n    var numberValue:NSNumber? {\n        let formatter = NumberFormatter()\n        formatter.numberStyle = .decimal\n        return formatter.number(from: self)\n    }\n}\nlet someFloat = \"12\".numberValue\n",
                "Useful for String to Int and other typeextension String {\n        //Converts String to Int\n        public func toInt() -> Int? {\n            if let num = NumberFormatter().number(from: self) {\n                return num.intValue\n            } else {\n                return nil\n            }\n        }\n\n        //Converts String to Double\n        public func toDouble() -> Double? {\n            if let num = NumberFormatter().number(from: self) {\n                return num.doubleValue\n            } else {\n                return nil\n            }\n        }\n\n        /// EZSE: Converts String to Float\n        public func toFloat() -> Float? {\n            if let num = NumberFormatter().number(from: self) {\n                return num.floatValue\n            } else {\n                return nil\n            }\n        }\n\n        //Converts String to Bool\n        public func toBool() -> Bool? {\n            return (self as NSString).boolValue\n        }\n    }\nextension String {\n        //Converts String to Int\n        public func toInt() -> Int? {\n            if let num = NumberFormatter().number(from: self) {\n                return num.intValue\n            } else {\n                return nil\n            }\n        }\n\n        //Converts String to Double\n        public func toDouble() -> Double? {\n            if let num = NumberFormatter().number(from: self) {\n                return num.doubleValue\n            } else {\n                return nil\n            }\n        }\n\n        /// EZSE: Converts String to Float\n        public func toFloat() -> Float? {\n            if let num = NumberFormatter().number(from: self) {\n                return num.floatValue\n            } else {\n                return nil\n            }\n        }\n\n        //Converts String to Bool\n        public func toBool() -> Bool? {\n            return (self as NSString).boolValue\n        }\n    }\nUse it like : \"123\".toInt() // 123\n\"123\".toInt() // 123\n",
                "i have made a simple program, where you have 2 txt field you take input form the user and add them to make it simpler to understand please find the code below. @IBOutlet weak var result: UILabel!\n@IBOutlet weak var one: UITextField!\n@IBOutlet weak var two: UITextField!\n\n@IBAction func add(sender: AnyObject) {        \n    let count = Int(one.text!)\n    let cal = Int(two.text!)\n    let sum = count! + cal!\n    result.text = \"Sum is \\(sum)\"\n}\n@IBOutlet weak var result: UILabel!\n@IBOutlet weak var one: UITextField!\n@IBOutlet weak var two: UITextField!\n\n@IBAction func add(sender: AnyObject) {        \n    let count = Int(one.text!)\n    let cal = Int(two.text!)\n    let sum = count! + cal!\n    result.text = \"Sum is \\(sum)\"\n}\nhope this helps.",
                "Swift 3.0Swift 3.0Try this, you don't need to check for any condition I have done everything just use this function. Send anything string, number, float, double ,etc,. you get a number as a value or 0 if it is unable to convert your valueSend anything string, number, float, double ,etc,.Function:Function:func getNumber(number: Any?) -> NSNumber {\n    guard let statusNumber:NSNumber = number as? NSNumber else\n    {\n        guard let statString:String = number as? String else\n        {\n            return 0\n        }\n        if let myInteger = Int(statString)\n        {\n            return NSNumber(value:myInteger)\n        }\n        else{\n            return 0\n        }\n    }\n    return statusNumber\n}\nfunc getNumber(number: Any?) -> NSNumber {\n    guard let statusNumber:NSNumber = number as? NSNumber else\n    {\n        guard let statString:String = number as? String else\n        {\n            return 0\n        }\n        if let myInteger = Int(statString)\n        {\n            return NSNumber(value:myInteger)\n        }\n        else{\n            return 0\n        }\n    }\n    return statusNumber\n}\nUsage: \nAdd the above function in code and to convert use\nlet myNumber = getNumber(number: myString)\n if the myString has a number or string it returns the number else it returns 0Usage:let myNumber = getNumber(number: myString)myString0Example 1:Example 1:let number:String = \"9834\"\nprint(\"printing number \\(getNumber(number: number))\")\nlet number:String = \"9834\"\nprint(\"printing number \\(getNumber(number: number))\")\nOutput: printing number 9834printing number 9834Example 2:Example 2:let number:Double = 9834\nprint(\"printing number \\(getNumber(number: number))\")\nlet number:Double = 9834\nprint(\"printing number \\(getNumber(number: number))\")\nOutput: printing number 9834printing number 9834Example 3:Example 3:let number = 9834\nprint(\"printing number \\(getNumber(number: number))\")\nlet number = 9834\nprint(\"printing number \\(getNumber(number: number))\")\nOutput: printing number 9834printing number 9834",
                "About int() and Swift 2.x: if you get a nil value after conversion check if you try to convert a string with a big number (for example: 1073741824), in this case try:let bytesInternet : Int64 = Int64(bytesInternetString)!\nlet bytesInternet : Int64 = Int64(bytesInternetString)!\n",
                "Latest swift3 this code is simply to convert string to intLatest swift3let myString = \"556\"\nlet myInt = Int(myString)\nlet myString = \"556\"\nlet myInt = Int(myString)\n",
                "Because a string might contain non-numerical characters you should use a guard to protect the operation. Example:guardguard let labelInt:Int = Int(labelString) else {\n    return\n}\n\nuseLabelInt()\nguard let labelInt:Int = Int(labelString) else {\n    return\n}\n\nuseLabelInt()\n",
                "I recently got the same issue. Below solution is work for me:        let strValue = \"123\"\n        let result = (strValue as NSString).integerValue\n        let strValue = \"123\"\n        let result = (strValue as NSString).integerValue\n",
                "Swift5 float or int string to int:Swift5 float or int string to int:extension String {\n    func convertStringToInt() -> Int {\n        return Int(Double(self) ?? 0.0)\n    }\n}\n\nlet doubleStr = \"4.2\"\n// print 4\nprint(doubleStr.convertStringToInt())\n\nlet intStr = \"4\"\n// print 4\nprint(intStr.convertStringToInt())\nextension String {\n    func convertStringToInt() -> Int {\n        return Int(Double(self) ?? 0.0)\n    }\n}\n\nlet doubleStr = \"4.2\"\n// print 4\nprint(doubleStr.convertStringToInt())\n\nlet intStr = \"4\"\n// print 4\nprint(intStr.convertStringToInt())\n",
                "Use this:// get the values from text boxes\n    let a:Double = firstText.text.bridgeToObjectiveC().doubleValue\n    let b:Double = secondText.text.bridgeToObjectiveC().doubleValue\n\n//  we checking against 0.0, because above function return 0.0 if it gets failed to convert\n    if (a != 0.0) && (b != 0.0) {\n        var ans = a + b\n        answerLabel.text = \"Answer is \\(ans)\"\n    } else {\n        answerLabel.text = \"Input values are not numberic\"\n    }\n// get the values from text boxes\n    let a:Double = firstText.text.bridgeToObjectiveC().doubleValue\n    let b:Double = secondText.text.bridgeToObjectiveC().doubleValue\n\n//  we checking against 0.0, because above function return 0.0 if it gets failed to convert\n    if (a != 0.0) && (b != 0.0) {\n        var ans = a + b\n        answerLabel.text = \"Answer is \\(ans)\"\n    } else {\n        answerLabel.text = \"Input values are not numberic\"\n    }\nORMake your UITextField KeyboardType as DecimalTab from your XIB or storyboard, and remove any if condition for doing any calculation, ie.var ans = a + b\nanswerLabel.text = \"Answer is \\(ans)\"\nvar ans = a + b\nanswerLabel.text = \"Answer is \\(ans)\"\nBecause keyboard type is DecimalPad there is no chance to enter other 0-9 or .Hope this help !!",
                "//  To convert user input (i.e string) to int for calculation.I did this , and it works.\n\n\n    let num:Int? = Int(firstTextField.text!);\n\n    let sum:Int = num!-2\n\n    print(sum);\n//  To convert user input (i.e string) to int for calculation.I did this , and it works.\n\n\n    let num:Int? = Int(firstTextField.text!);\n\n    let sum:Int = num!-2\n\n    print(sum);\n",
                "This works for me   var a:Int? = Int(userInput.text!)\nvar a:Int? = Int(userInput.text!)\n",
                "for Swift3.xextension String {\n    func toInt(defaultValue: Int) -> Int {\n        if let n = Int(self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)) {\n            return n\n        } else {\n            return defaultValue\n        }\n    }\n}\nextension String {\n    func toInt(defaultValue: Int) -> Int {\n        if let n = Int(self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)) {\n            return n\n        } else {\n            return defaultValue\n        }\n    }\n}\n",
                "Swift 4, Swift 5Swift 4, Swift 5There are different cases to convert from something to something data type, it depends the input.If the input data type is Any, we have to use as before convert to actual data type, then convert to data type what we want. For example:Anyasfunc justGetDummyString() -> Any {\n  return \"2000\"\n}\nlet dummyString: String = (justGetDummyString() as? String) ?? \"\" // output = \"2000\"\nlet dummyInt: Int = Int(dummyString) ?? 0 // output = 2000\nfunc justGetDummyString() -> Any {\n  return \"2000\"\n}\nlet dummyString: String = (justGetDummyString() as? String) ?? \"\" // output = \"2000\"\nlet dummyInt: Int = Int(dummyString) ?? 0 // output = 2000\n",
                "for Alternative solution. You can use extension a native type. You can test with playground. extension String {\n    func add(a: Int) -> Int? {\n        if let b = Int(self) {\n            return b + a\n        }\n        else {\n            return nil\n        }\n    }     \n}\nextension String {\n    func add(a: Int) -> Int? {\n        if let b = Int(self) {\n            return b + a\n        }\n        else {\n            return nil\n        }\n    }     \n}\n\"2\".add(1)",
                "My solution is to have a general extension for string to int conversion.extension String {\n\n // default: it is a number suitable for your project if the string is not an integer\n\n    func toInt(default: Int) -> Int {\n        if let result = Int(self) {\n            return result\n        }\n        else {\n            return default  \n        }\n    }\n\n}\nextension String {\n\n // default: it is a number suitable for your project if the string is not an integer\n\n    func toInt(default: Int) -> Int {\n        if let result = Int(self) {\n            return result\n        }\n        else {\n            return default  \n        }\n    }\n\n}\n",
                "@IBAction func calculateAclr(_ sender: Any) {\n    if let addition = addition(arrayString: [txtBox1.text, txtBox2.text, txtBox3.text]) {\n      print(\"Answer = \\(addition)\")\n      lblAnswer.text = \"\\(addition)\"\n    }\n}\n\nfunc addition(arrayString: [Any?]) -> Int? {\n\n    var answer:Int?\n    for arrayElement in arrayString {\n        if let stringValue = arrayElement, let intValue = Int(stringValue)  {\n            answer = (answer ?? 0) + intValue\n        }\n    }\n\n    return answer\n}\n@IBAction func calculateAclr(_ sender: Any) {\n    if let addition = addition(arrayString: [txtBox1.text, txtBox2.text, txtBox3.text]) {\n      print(\"Answer = \\(addition)\")\n      lblAnswer.text = \"\\(addition)\"\n    }\n}\n\nfunc addition(arrayString: [Any?]) -> Int? {\n\n    var answer:Int?\n    for arrayElement in arrayString {\n        if let stringValue = arrayElement, let intValue = Int(stringValue)  {\n            answer = (answer ?? 0) + intValue\n        }\n    }\n\n    return answer\n}\n",
                "Question : string \"4.0000\" can not be convert into integer using Int(\"4.000\")?Answer : Int() check string is integer or not if yes then give you integer and otherwise nil. but Float or Double can convert any number string to respective Float or Double without giving nil. Example if you have \"45\" integer string but using Float(\"45\") gives you 45.0 float value or using Double(\"4567\") gives you 45.0.Solution : NSString(string: \"45.000\").integerValue or Int(Float(\"45.000\")!)! to get correct result.",
                "An Int in Swift contains an initializer that accepts a String. It returns an optional Int? as the conversion can fail if the string contains not a number.By using an if let statement you can validate whether the conversion succeeded. So your code become something like this: @IBOutlet var txtBox1 : UITextField\n@IBOutlet var txtBox2 : UITextField\n@IBOutlet var txtBox3 : UITextField\n@IBOutlet var lblAnswer : UILabel\n\n@IBAction func btn1(sender : AnyObject) {\n\n    let answer1 = \"The acceleration is\"\n    var answer2 = txtBox1\n    var answer3 = txtBox2\n    var answer4 = txtBox3\n\n    if let intAnswer = Int(txtBox1.text) {\n      // Correctly converted\n    }\n}\n@IBOutlet var txtBox1 : UITextField\n@IBOutlet var txtBox2 : UITextField\n@IBOutlet var txtBox3 : UITextField\n@IBOutlet var lblAnswer : UILabel\n\n@IBAction func btn1(sender : AnyObject) {\n\n    let answer1 = \"The acceleration is\"\n    var answer2 = txtBox1\n    var answer3 = txtBox2\n    var answer4 = txtBox3\n\n    if let intAnswer = Int(txtBox1.text) {\n      // Correctly converted\n    }\n}\n",
                "Swift 5.0 and AboveSwift 5.0 and AboveWorkingWorkingIn case if you are splitting the String it creates two substrings and not two Strings . This below method will check for Any and convert it t0 NSNumber its easy to convert a NSNumber to Int, Float what ever data type you need.StringsubstringsStringsAnyNSNumberNSNumberIntFloatActual CodeActual Code//Convert Any To Number Object Removing Optional Key Word.\npublic func getNumber(number: Any) -> NSNumber{\n guard let statusNumber:NSNumber = number as? NSNumber  else {\n    guard let statString:String = number as? String else {\n        guard let statSubStr : Substring = number as? Substring else {\n            return 0\n        }\n        if let myInteger = Int(statSubStr) {\n            return NSNumber(value:myInteger)\n        }\n        else{\n            return 0\n        }\n    }\n\n    if let myInteger = Int(statString) {\n        return NSNumber(value:myInteger)\n    }\n    else if let myFloat = Float(statString) {\n        return NSNumber(value:myFloat)\n    }else {\n        return 0\n    }\n}\nreturn statusNumber }\n//Convert Any To Number Object Removing Optional Key Word.\npublic func getNumber(number: Any) -> NSNumber{\n guard let statusNumber:NSNumber = number as? NSNumber  else {\n    guard let statString:String = number as? String else {\n        guard let statSubStr : Substring = number as? Substring else {\n            return 0\n        }\n        if let myInteger = Int(statSubStr) {\n            return NSNumber(value:myInteger)\n        }\n        else{\n            return 0\n        }\n    }\n\n    if let myInteger = Int(statString) {\n        return NSNumber(value:myInteger)\n    }\n    else if let myFloat = Float(statString) {\n        return NSNumber(value:myFloat)\n    }else {\n        return 0\n    }\n}\nreturn statusNumber }\nUsageUsageif let hourVal = getNumber(number: hourStr) as? Int {\n\n}\nif let hourVal = getNumber(number: hourStr) as? Int {\n\n}\nPassing String to check and convert to DoubleStringDoubleDouble(getNumber(number:  dict[\"OUT\"] ?? 0)\nDouble(getNumber(number:  dict[\"OUT\"] ?? 0)\n",
                "As of swift 3, I have to force my #%@! string & int with a \"!\" otherwise it just doesn't work.swift 3For example:let prefs = UserDefaults.standard\nvar counter: String!\ncounter = prefs.string(forKey:\"counter\")\nprint(\"counter: \\(counter!)\")\n\n\nvar counterInt = Int(counter!)\ncounterInt = counterInt! + 1\nprint(\"counterInt: \\(counterInt!)\")\n\nOUTPUT:\ncounter: 1\ncounterInt: 2\nlet prefs = UserDefaults.standard\nvar counter: String!\ncounter = prefs.string(forKey:\"counter\")\nprint(\"counter: \\(counter!)\")\n\n\nvar counterInt = Int(counter!)\ncounterInt = counterInt! + 1\nprint(\"counterInt: \\(counterInt!)\")\n\nOUTPUT:\ncounter: 1\ncounterInt: 2\n"
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "How do you express binary literals in Python?",
                "how do i create binary literals in python?",
                "what can i do to express binary literals in python?",
                "how do you express binary literals in python?"
            ],
            "responses": [
                "For reference\u2014future Python possibilities:\nStarting with Python 2.6 you can express binary literals using the prefix 0b or 0B:future0b0B>>> 0b101111\n47\n>>> 0b101111\n47\nYou can also use the new bin function to get the binary representation of a number:bin>>> bin(173)\n'0b10101101'\n>>> bin(173)\n'0b10101101'\nDevelopment version of the documentation: What's New in Python 2.6What's New in Python 2.6",
                ">>> print int('01010101111',2)\n687\n>>> print int('11111111',2)\n255\n>>> print int('01010101111',2)\n687\n>>> print int('11111111',2)\n255\nAnother way.",
                "\nHow do you express binary literals in Python?\nHow do you express binary literals in Python?They're not \"binary\" literals, but rather, \"integer literals\". You can express integer literals with a binary format with a 0 followed by a B or b followed by a series of zeros and ones, for example:0Bb>>> 0b0010101010\n170\n>>> 0B010101\n21\n>>> 0b0010101010\n170\n>>> 0B010101\n21\nFrom the Python 3 docs, these are the ways of providing integer literals in Python:docs\nInteger literals are described by the following lexical definitions:\ninteger      ::=  decinteger | bininteger | octinteger | hexinteger\ndecinteger   ::=  nonzerodigit ([\"_\"] digit)* | \"0\"+ ([\"_\"] \"0\")*\nbininteger   ::=  \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+\noctinteger   ::=  \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+\nhexinteger   ::=  \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+\nnonzerodigit ::=  \"1\"...\"9\"\ndigit        ::=  \"0\"...\"9\"\nbindigit     ::=  \"0\" | \"1\"\noctdigit     ::=  \"0\"...\"7\"\nhexdigit     ::=  digit | \"a\"...\"f\" | \"A\"...\"F\"\n\nThere is no limit for the length of integer literals apart from what\n  can be stored in available memory.\nNote that leading zeros in a non-zero decimal number are not allowed.\n  This is for disambiguation with C-style octal literals, which Python\n  used before version 3.0.\nSome examples of integer literals:\n7     2147483647                        0o177    0b100110111\n3     79228162514264337593543950336     0o377    0xdeadbeef\n      100_000_000_000                   0b_1110_0101\n\nChanged in version 3.6: Underscores are now allowed for grouping purposes in literals.\nInteger literals are described by the following lexical definitions:integer      ::=  decinteger | bininteger | octinteger | hexinteger\ndecinteger   ::=  nonzerodigit ([\"_\"] digit)* | \"0\"+ ([\"_\"] \"0\")*\nbininteger   ::=  \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+\noctinteger   ::=  \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+\nhexinteger   ::=  \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+\nnonzerodigit ::=  \"1\"...\"9\"\ndigit        ::=  \"0\"...\"9\"\nbindigit     ::=  \"0\" | \"1\"\noctdigit     ::=  \"0\"...\"7\"\nhexdigit     ::=  digit | \"a\"...\"f\" | \"A\"...\"F\"\ninteger      ::=  decinteger | bininteger | octinteger | hexinteger\ndecinteger   ::=  nonzerodigit ([\"_\"] digit)* | \"0\"+ ([\"_\"] \"0\")*\nbininteger   ::=  \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+\noctinteger   ::=  \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+\nhexinteger   ::=  \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+\nnonzerodigit ::=  \"1\"...\"9\"\ndigit        ::=  \"0\"...\"9\"\nbindigit     ::=  \"0\" | \"1\"\noctdigit     ::=  \"0\"...\"7\"\nhexdigit     ::=  digit | \"a\"...\"f\" | \"A\"...\"F\"\nThere is no limit for the length of integer literals apart from what\n  can be stored in available memory.Note that leading zeros in a non-zero decimal number are not allowed.\n  This is for disambiguation with C-style octal literals, which Python\n  used before version 3.0.Some examples of integer literals:7     2147483647                        0o177    0b100110111\n3     79228162514264337593543950336     0o377    0xdeadbeef\n      100_000_000_000                   0b_1110_0101\n7     2147483647                        0o177    0b100110111\n3     79228162514264337593543950336     0o377    0xdeadbeef\n      100_000_000_000                   0b_1110_0101\nChanged in version 3.6: Underscores are now allowed for grouping purposes in literals.Changed in version 3.6:Other ways of expressing binary:You can have the zeros and ones in a string object which can be manipulated (although you should probably just do bitwise operations on the integer in most cases) - just pass int the string of zeros and ones and the base you are converting from (2):>>> int('010101', 2)\n21\n>>> int('010101', 2)\n21\nYou can optionally have the 0b or 0B prefix:0b0B>>> int('0b0010101010', 2)\n170\n>>> int('0b0010101010', 2)\n170\nIf you pass it 0 as the base, it will assume base 10 if the string doesn't specify with a prefix:0>>> int('10101', 0)\n10101\n>>> int('0b10101', 0)\n21\n>>> int('10101', 0)\n10101\n>>> int('0b10101', 0)\n21\nConverting from int back to human readable binary:You can pass an integer to bin to see the string representation of a binary literal:>>> bin(21)\n'0b10101'\n>>> bin(21)\n'0b10101'\nAnd you can combine bin and int to go back and forth:binint>>> bin(int('010101', 2))\n'0b10101'\n>>> bin(int('010101', 2))\n'0b10101'\nYou can use a format specification as well, if you want to have minimum width with preceding zeros:>>> format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))\n'0000010101'\n>>> format(int('010101', 2), '010b')\n'0000010101'\n>>> format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))\n'0000010101'\n>>> format(int('010101', 2), '010b')\n'0000010101'\n",
                "I've tried this in Python 3.6.9I've tried this in Python 3.6.9Convert Binary to DecimalConvert Binary to Decimal>>> 0b101111\n47\n\n>>> int('101111',2)\n47\n>>> 0b101111\n47\n\n>>> int('101111',2)\n47\nConvert Decimal to binaryConvert Decimal to binary>>> bin(47)\n'0b101111'\n>>> bin(47)\n'0b101111'\nPlace a 0 as the second parameter python assumes it as decimal.Place a 0 as the second parameter python assumes it as decimal.>>> int('101111',0)\n101111\n>>> int('101111',0)\n101111\n",
                "0 in the start here specifies that the base is 8 (not 10), which is pretty easy to see: >>> int('010101', 0)\n4161\n>>> int('010101', 0)\n4161\nIf you don't start with a 0, then python assumes the number is base 10.>>> int('10101', 0)\n10101\n>>> int('10101', 0)\n10101\n",
                "Another good method to get an integer representation from binary is to use eval()Like so:def getInt(binNum = 0):\n    return eval(eval('0b' + str(n)))\ndef getInt(binNum = 0):\n    return eval(eval('0b' + str(n)))\nI guess this is a way to do it too.\nI hope this is a satisfactory answer :D",
                "As far as I can tell Python, up through 2.5, only supports hexadecimal & octal literals.  I did find some discussions about adding binary to future versions but nothing definite.",
                "I am pretty sure this is one of the things due to change in Python 3.0 with perhaps bin() to go with hex() and oct().EDIT:\nlbrandy's answer is correct in all cases."
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Python strings and integer concatenation [duplicate]",
                "Python strings and integer concatenation [duplicate]"
            ],
            "responses": [
                "NOTE:The method used in this answer (backticks) is deprecated in later versions of Python 2, and removed in Python 3. Use the str() function instead.str()str()You can use:string = 'string'\nfor i in range(11):\n    string +=`i`\nprint string\nstring = 'string'\nfor i in range(11):\n    string +=`i`\nprint string\nIt will print string012345678910.string012345678910To get string0, string1 ..... string10 you can use this as YOU suggested:string0, string1 ..... string10YOU suggested>>> string = \"string\"\n>>> [string+`i` for i in range(11)]\n>>> string = \"string\"\n>>> [string+`i` for i in range(11)]\nFor Python 3You can use:string = 'string'\nfor i in range(11):\n    string += str(i)\nprint string\nstring = 'string'\nfor i in range(11):\n    string += str(i)\nprint string\nIt will print string012345678910.string012345678910To get string0, string1 ..... string10, you can use this as YOU suggested:string0, string1 ..... string10YOU suggested>>> string = \"string\"\n>>> [string+str(i) for i in range(11)]\n>>> string = \"string\"\n>>> [string+str(i) for i in range(11)]\n",
                "for i in range (1,10):\n    string=\"string\"+str(i)\nfor i in range (1,10):\n    string=\"string\"+str(i)\nTo get string0, string1 ..... string10, you could do likestring0, string1 ..... string10>>> [\"string\"+str(i) for i in range(11)]\n['string0', 'string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7', 'string8', 'string9', 'string10']\n>>> [\"string\"+str(i) for i in range(11)]\n['string0', 'string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7', 'string8', 'string9', 'string10']\n",
                "for i in range[1,10]: \n  string = \"string\" + str(i)\nfor i in range[1,10]: \n  string = \"string\" + str(i)\nThe str(i) function converts the integer into a string.str(i)",
                "string = 'string%d' % (i,)\nstring = 'string%d' % (i,)\n",
                "for i in range(11):\n    string = \"string{0}\".format(i)\nfor i in range(11):\n    string = \"string{0}\".format(i)\nYou did (range[1,10]):range[1,10]\na TypeError since brackets denote an index (a[3]) or a slice (a[3:5]) of a list,\na SyntaxError since [1,10] is invalid, and\na double off-by-one error since range(1,10) is [1, 2, 3, 4, 5, 6, 7, 8, 9], and you seem to want [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\na TypeError since brackets denote an index (a[3]) or a slice (a[3:5]) of a list,a[3]a[3:5]a SyntaxError since [1,10] is invalid, and[1,10]a double off-by-one error since range(1,10) is [1, 2, 3, 4, 5, 6, 7, 8, 9], and you seem to want [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]range(1,10)[1, 2, 3, 4, 5, 6, 7, 8, 9][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]And string = \"string\" + i is a TypeError since you can't add an integer to a string (unlike JavaScript).string = \"string\" + iLook at the documentation for Python's new string formatting method. It is very powerful.Python's new string formatting method",
                "You can use a generator to do this!def sequence_generator(limit):\n    \"\"\" A generator to create strings of pattern -> string1,string2..stringN \"\"\"\n    inc  = 0\n    while inc < limit:\n        yield 'string' + str(inc)\n        inc += 1\n\n# To generate a generator. Notice I have used () instead of []\na_generator  =  (s for s in sequence_generator(10))\n\n# To generate a list\na_list  =  [s for s in sequence_generator(10)]\n\n# To generate a string\na_string =  '['+ \", \".join(s for s in sequence_generator(10)) + ']'\ndef sequence_generator(limit):\n    \"\"\" A generator to create strings of pattern -> string1,string2..stringN \"\"\"\n    inc  = 0\n    while inc < limit:\n        yield 'string' + str(inc)\n        inc += 1\n\n# To generate a generator. Notice I have used () instead of []\na_generator  =  (s for s in sequence_generator(10))\n\n# To generate a list\na_list  =  [s for s in sequence_generator(10)]\n\n# To generate a string\na_string =  '['+ \", \".join(s for s in sequence_generator(10)) + ']'\n",
                "If we want output like 'string0123456789' then we can use the map function and join method of string.'string0123456789'mapjoinstring>>> 'string' + \"\".join(map(str, xrange(10)))\n'string0123456789'\n>>> 'string' + \"\".join(map(str, xrange(10)))\n'string0123456789'\nIf we want a list of string values then use the list comprehension method.listlist comprehension>>> ['string'+i for i in map(str,xrange(10))]\n['string0', 'string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7', 'string8', 'string9']\n>>> ['string'+i for i in map(str,xrange(10))]\n['string0', 'string1', 'string2', 'string3', 'string4', 'string5', 'string6', 'string7', 'string8', 'string9']\nNote:Note:Use xrange() for Python 2.x.xrange()Use range() for Python 3.x.range()",
                "I did something else.I wanted to replace a word, in lists of lists, that contained phrases.I wanted to replace that string / word with a new word that will be a join between string and number, and that number / digit will indicate the position of the phrase / sublist / lists of lists.That is, I replaced a string with a string and an incremental number that follow it.myoldlist_1 = [[' myoldword'], [''], ['tttt myoldword'], ['jjjj ddmyoldwordd']]\n    No_ofposition = []\n    mynewlist_2 = []\n    for i in xrange(0, 4, 1):\n        mynewlist_2.append([x.replace('myoldword', \"%s\" % i + \"_mynewword\") for x in myoldlist_1[i]])\n        if len(mynewlist_2[i]) > 0:\n            No_ofposition.append(i)\n\nmynewlist_2\nNo_ofposition\nmyoldlist_1 = [[' myoldword'], [''], ['tttt myoldword'], ['jjjj ddmyoldwordd']]\n    No_ofposition = []\n    mynewlist_2 = []\n    for i in xrange(0, 4, 1):\n        mynewlist_2.append([x.replace('myoldword', \"%s\" % i + \"_mynewword\") for x in myoldlist_1[i]])\n        if len(mynewlist_2[i]) > 0:\n            No_ofposition.append(i)\n\nmynewlist_2\nNo_ofposition\n",
                "Concatenation of a string and integer is simple:\njust useabhishek+str(2)\nabhishek+str(2)\n"
            ]
        },
        {
            "tag": "java",
            "patterns": [
                "Declaring an unsigned int in Java",
                "declaring an unsigned int in java"
            ],
            "responses": [
                "Java does not have a datatype for unsigned integers.unsigned integersYou can define a long instead of an int if you need to store large values.longlongintYou can also use a signed integer as if it were unsigned. The benefit of two's complement representation is that most operations (such as addition, subtraction, multiplication, and left shift) are identical on a binary level for signed and unsigned integers. A few operations (division, right shift, comparison, and casting), however, are different. As of Java SE 8, new methods in the Integer class allow you to fully use the int data type to perform unsigned arithmetic:two's complement representationIntegerIntegerintto perform unsigned arithmetic\nIn Java SE 8 and later, you can use the int data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 2^32-1. Use the Integer class to use int data type as an unsigned integer. Static methods like compareUnsigned, divideUnsigned etc have been added to the Integer class to support the arithmetic operations for unsigned integers.\nIn Java SE 8 and later, you can use the int data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 2^32-1. Use the Integer class to use int data type as an unsigned integer. Static methods like compareUnsigned, divideUnsigned etc have been added to the Integer class to support the arithmetic operations for unsigned integers.compareUnsignedcompareUnsigneddivideUnsigneddivideUnsignedNote that int variables are still signed when declared but unsigned arithmetic is now possible by using those methods in the Integer class.intInteger",
                "Whether a value in an int is signed or unsigned depends on how the bits are interpreted - Java interprets bits as a signed value (it doesn't have unsigned primitives).If you have an int that you want to interpret as an unsigned value (e.g. you read an int from a DataInputStream that you know should be interpreted as an unsigned value) then you can do the following trick.DataInputStreamint fourBytesIJustRead = someObject.getInt();\nlong unsignedValue = fourBytesIJustRead & 0xffffffffL;\nint fourBytesIJustRead = someObject.getInt();\nlong unsignedValue = fourBytesIJustRead & 0xffffffffL;\nNote, that it is important that the hex literal is a long literal, not an int literal - hence the 'L' at the end.",
                "We needed unsigned numbers to model MySQL's unsigned TINYINT, SMALLINT, INT, BIGINT in jOOQ, which is why we have created jOOU, a minimalistic library offering wrapper types for unsigned integer numbers in Java. Example:TINYINTSMALLINTINTBIGINTjOOQjOOUimport static org.joou.Unsigned.*;\n\n// and then...\nUByte    b = ubyte(1);\nUShort   s = ushort(1);\nUInteger i = uint(1);\nULong    l = ulong(1);\nimport static org.joou.Unsigned.*;\n\n// and then...\nUByte    b = ubyte(1);\nUShort   s = ushort(1);\nUInteger i = uint(1);\nULong    l = ulong(1);\nAll of these types extend java.lang.Number and can be converted into higher-order primitive types and BigInteger. Hope this helps.java.lang.NumberBigInteger(Disclaimer: I work for the company behind these libraries)",
                "For unsigned numbers you can use these classes from Guava library:Guava libraryGuava library\nUnsignedInteger\nUnsignedLong\nUnsignedIntegerUnsignedIntegerUnsignedLongUnsignedLongThey support various operations:\nplus\nminus\ntimes\nmod\ndividedBy\nplusminustimesmoddividedByThe thing that seems missing at the moment are byte shift operators. If you need those you can use BigInteger from Java.",
                "Use char for 16 bit unsigned integers.char",
                "Perhaps this is what you meant?long getUnsigned(int signed) {\n    return signed >= 0 ? signed : 2 * (long) Integer.MAX_VALUE + 2 + signed;\n}\nlong getUnsigned(int signed) {\n    return signed >= 0 ? signed : 2 * (long) Integer.MAX_VALUE + 2 + signed;\n}\n\ngetUnsigned(0) \u2192 0\ngetUnsigned(1) \u2192 1\ngetUnsigned(Integer.MAX_VALUE) \u2192 2147483647\ngetUnsigned(Integer.MIN_VALUE) \u2192 2147483648\ngetUnsigned(Integer.MIN_VALUE + 1) \u2192 2147483649\ngetUnsigned(0) \u2192 0getUnsigned(0)getUnsigned(1) \u2192 1getUnsigned(1)getUnsigned(Integer.MAX_VALUE) \u2192 2147483647getUnsigned(Integer.MAX_VALUE)getUnsigned(Integer.MIN_VALUE) \u2192 2147483648getUnsigned(Integer.MIN_VALUE)getUnsigned(Integer.MIN_VALUE + 1) \u2192 2147483649getUnsigned(Integer.MIN_VALUE + 1)",
                "There are good answers here, but I don\u2019t see any demonstrations of bitwise operations. Like Visser (the currently accepted answer) says, Java signs integers by default (Java 8 has unsigned integers, but I have never used them). Without further ado, let\u2018s do it...RFC 868 ExampleWhat happens if you need to write an unsigned integer to IO? Practical example is when you want to output the time according to RFC 868. This requires a 32-bit, big-endian, unsigned integer that encodes the number of seconds since 12:00 A.M. January 1, 1900. How would you encode this?RFC 868Make your own unsigned 32-bit integer like this:Declare a byte array of 4 bytes (32 bits)Byte my32BitUnsignedInteger[] = new Byte[4] // represents the time (s)\nByte my32BitUnsignedInteger[] = new Byte[4] // represents the time (s)\nThis initializes the array, see Are byte arrays initialised to zero in Java?. Now you have to fill each byte in the array with information in the big-endian order (or little-endian if you want to wreck havoc). Assuming you have a long containing the time (long integers are 64 bits long in Java) called secondsSince1900 (Which only utilizes the first 32 bits worth, and you\u2018ve handled the fact that Date references 12:00 A.M. January 1, 1970), then you can use the logical AND to extract bits from it and shift those bits into positions (digits) that will not be ignored when coersed into a Byte, and in big-endian order.Are byte arrays initialised to zero in Java?secondsSince1900my32BitUnsignedInteger[0] = (byte) ((secondsSince1900 & 0x00000000FF000000L) >> 24); // first byte of array contains highest significant bits, then shift these extracted FF bits to first two positions in preparation for coersion to Byte (which only adopts the first 8 bits)\nmy32BitUnsignedInteger[1] = (byte) ((secondsSince1900 & 0x0000000000FF0000L) >> 16);\nmy32BitUnsignedInteger[2] = (byte) ((secondsSince1900 & 0x000000000000FF00L) >> 8);\nmy32BitUnsignedInteger[3] = (byte) ((secondsSince1900 & 0x00000000000000FFL); // no shift needed\nmy32BitUnsignedInteger[0] = (byte) ((secondsSince1900 & 0x00000000FF000000L) >> 24); // first byte of array contains highest significant bits, then shift these extracted FF bits to first two positions in preparation for coersion to Byte (which only adopts the first 8 bits)\nmy32BitUnsignedInteger[1] = (byte) ((secondsSince1900 & 0x0000000000FF0000L) >> 16);\nmy32BitUnsignedInteger[2] = (byte) ((secondsSince1900 & 0x000000000000FF00L) >> 8);\nmy32BitUnsignedInteger[3] = (byte) ((secondsSince1900 & 0x00000000000000FFL); // no shift needed\nOur my32BitUnsignedInteger is now equivalent to an unsigned 32-bit, big-endian integer that adheres to the RCF 868 standard. Yes, the long datatype is signed, but we ignored that fact, because we assumed that the secondsSince1900 only used the lower 32 bits). Because of coersing the long into a byte, all bits higher than 2^7 (first two digits in hex) will be ignored.my32BitUnsignedIntegerSource referenced: Java Network Programming, 4th Edition.",
                "It seems that you can handle the signing problem by doing a \"logical AND\" on the values before you use them:Example (Value of byte[] header[0] is 0x86 ):byte[]header[0]0x86System.out.println(\"Integer \"+(int)header[0]+\" = \"+((int)header[0]&0xff));\nSystem.out.println(\"Integer \"+(int)header[0]+\" = \"+((int)header[0]&0xff));\nResult:Integer -122 = 134\nInteger -122 = 134\n",
                "Just made this piece of code, wich converts \"this.altura\" from negative to positive number. Hope this helps someone in need       if(this.altura < 0){    \n\n                        String aux = Integer.toString(this.altura);\n                        char aux2[] = aux.toCharArray();\n                        aux = \"\";\n                        for(int con = 1; con < aux2.length; con++){\n                            aux += aux2[con];\n                        }\n                        this.altura = Integer.parseInt(aux);\n                        System.out.println(\"New Value: \" + this.altura);\n                    }\n       if(this.altura < 0){    \n\n                        String aux = Integer.toString(this.altura);\n                        char aux2[] = aux.toCharArray();\n                        aux = \"\";\n                        for(int con = 1; con < aux2.length; con++){\n                            aux += aux2[con];\n                        }\n                        this.altura = Integer.parseInt(aux);\n                        System.out.println(\"New Value: \" + this.altura);\n                    }\n",
                "You can use the Math.abs(number) function. It returns a positive number."
            ]
        },
        {
            "tag": "php",
            "patterns": [
                "Extract a single (unsigned) integer from a string",
                "extract a single integer unsigned from a string",
                "remove a single unsigned integer from a string",
                "extract a single unsigned integer from a string"
            ],
            "responses": [
                "If you just want to filter everything other than the numbers out, the easiest is to use filter_var:filter_var$str = 'In My Cart : 11 items';\n$int = (int) filter_var($str, FILTER_SANITIZE_NUMBER_INT);\n$str = 'In My Cart : 11 items';\n$int = (int) filter_var($str, FILTER_SANITIZE_NUMBER_INT);\n",
                "$str = 'In My Cart : 11 12 items';\npreg_match_all('!\\d+!', $str, $matches);\nprint_r($matches);\n$str = 'In My Cart : 11 12 items';\npreg_match_all('!\\d+!', $str, $matches);\nprint_r($matches);\n",
                "preg_replace('/[^0-9]/', '', $string);\npreg_replace('/[^0-9]/', '', $string);\nThis should do better job!...",
                "Using preg_replace:preg_replace$str = '(111) 111-1111';\n$str = preg_replace('/\\D/', '', $str);\necho $str;\n$str = '(111) 111-1111';\n$str = preg_replace('/\\D/', '', $str);\necho $str;\nOutput: 1111111111 ",
                "For floating numbers,preg_match_all('!\\d+\\.?\\d+!', $string ,$match);\npreg_match_all('!\\d+\\.?\\d+!', $string ,$match);\nThanks for pointing out the mistake.  @mickmackusa",
                "I do not own the credit for this, but I just have to share it. This regex will get numbers from a string, including decimal points/places, as well as commas:/((?:[0-9]+,)*[0-9]+(?:\\.[0-9]+)?)//((?:[0-9]+,)*[0-9]+(?:\\.[0-9]+)?)/Cited from here:\nphp - regex - how to extract a number with decimal (dot and comma) from a string (e.g. 1,120.01)?php - regex - how to extract a number with decimal (dot and comma) from a string (e.g. 1,120.01)?",
                "You can use preg_match:preg_match$s = \"In My Cart : 11 items\";\npreg_match(\"|\\d+|\", $s, $m);\nvar_dump($m);\n$s = \"In My Cart : 11 items\";\npreg_match(\"|\\d+|\", $s, $m);\nvar_dump($m);\n",
                "Using preg_replacepreg_replace$str = 'In My Cart : 11 12 items';\n$str = preg_replace('/\\D/', '', $str);\necho $str;\n$str = 'In My Cart : 11 12 items';\n$str = preg_replace('/\\D/', '', $str);\necho $str;\n",
                "$value = '25%';\n$value = '25%';\nOr$value = '25.025$';\n$value = '25.025$';\nOr$value = 'I am numeric 25';\n$onlyNumeric = filter_var($value, FILTER_SANITIZE_NUMBER_FLOAT, FILTER_FLAG_ALLOW_FRACTION);\n$value = 'I am numeric 25';\n$onlyNumeric = filter_var($value, FILTER_SANITIZE_NUMBER_FLOAT, FILTER_FLAG_ALLOW_FRACTION);\nThis will return only the numeric value",
                "The top resource-friendly solutionsresource-friendly solutions<?php\n    var $string = \"In My Cart : 11 items\";\n?>\n<?php\n    var $string = \"In My Cart : 11 items\";\n?>\n1. Fastest: filter_var \u2014 Filters a variable with a specified filterfilter_varfilter_varFilters a variable with a specified filter<?php\n    filter_var($string, FILTER_SANITIZE_NUMBER_INT); // string(2) \"11\"\n?>\n<?php\n    filter_var($string, FILTER_SANITIZE_NUMBER_INT); // string(2) \"11\"\n?>\n2. Almost the fastest: str_replace \u2014 Replace all occurrences of the search string with the replacement stringstr_replacestr_replace<?php\n    str_replace(array('In My Cart : ',' item', 's'),\"\", $string); // string(2) \"11\"\n?>\n<?php\n    str_replace(array('In My Cart : ',' item', 's'),\"\", $string); // string(2) \"11\"\n?>\n3. Fast enough: preg_replace \u2014 Perform a regular expression search and replacepreg_replacepreg_replacePerform a regular expression search and replace<?php\n    preg_replace(\"/[^0-9]/\",\"\",$string); // string(2) \"11\"\n?>\n<?php\n    preg_replace(\"/[^0-9]/\",\"\",$string); // string(2) \"11\"\n?>\nHowever\nthe simplicity of str_replace cause speed, but even limited use cases\npreg_replace is much more versatile than str_replace or filter_var\ninstead is possible to use a function to specify what to replace using preg_replace_callback\nwith preg_replace_callback can do multiple replacements in one call\nfilter_var limited in sanitation options\nthe simplicity of str_replace cause speed, but even limited use casesstr_replacepreg_replace is much more versatile than str_replace or filter_varpreg_replacemore versatilestr_replacefilter_varinstead is possible to use a function to specify what to replace using preg_replace_callbackfunctionpreg_replace_callbackpreg_replace_callbackwith preg_replace_callback can do multiple replacements in one callpreg_replace_callbackfilter_var limited in sanitation optionsfilter_varsanitation options",
                "You can use following function:  function extract_numbers($string)\n{\n   preg_match_all('/([\\d]+)/', $string, $match);\n\n   return $match[0];\n}\nfunction extract_numbers($string)\n{\n   preg_match_all('/([\\d]+)/', $string, $match);\n\n   return $match[0];\n}\n",
                "Since there is only 1 numeric value to isolate in your string, I would endorse and personally use filter_var() with FILTER_SANITIZE_NUMBER_INT.filter_var()FILTER_SANITIZE_NUMBER_INTecho filter_var($string, FILTER_SANITIZE_NUMBER_INT);\necho filter_var($string, FILTER_SANITIZE_NUMBER_INT);\nA whackier technique which works because there is only 1 numeric value AND the only characters that come before the integer are letters, colons, or spaces is to use ltrim() with a character mask then cast the remaining string as an integer.ltrim()DemoDemo$string = \"In My Cart : 11 items\";\necho (int)ltrim($string, 'A..z: ');\n// 11\n$string = \"In My Cart : 11 items\";\necho (int)ltrim($string, 'A..z: ');\n// 11\nIf for some reason there was more than one integer value and you wanted to grab the first one, then regex would be a direct technique.DemoDemoecho preg_match('/\\d+/', $string, $m) ? $m[0] : '';\necho preg_match('/\\d+/', $string, $m) ? $m[0] : '';\nsscanf() is rather handy if you need to explicitly cast the numeric string as an integer (or float).  If it is possible/unknown for the integer value to occur at the start of the string, then prepend a non-numeric character to the input string before scanning it.  The following technique matches leading non-digits (and ignores them with * after the %), then matches the first occurring sequence of digits and casts the returned substring as an integer.sscanf()*%DemoDemovar_dump(sscanf(' ' . $string, '%*[^0-9]%d')[0]);\nvar_dump(sscanf(' ' . $string, '%*[^0-9]%d')[0]);\nTo adapt this technique to extract a float value, just change the d to f.  For more information on the (currently undocumented) assignment suppression feature of sscanf(), see this post.dfsscanf()this post",
                "preg_match_all('!\\d+!', $some_string, $matches);\n$string_of_numbers = implode(' ', $matches[0]);\npreg_match_all('!\\d+!', $some_string, $matches);\n$string_of_numbers = implode(' ', $matches[0]);\nThe first argument in implode in this specific case says \"separate each element in matches[0] with a single space.\" Implode will not put a space (or whatever your first argument is) before the first number or after the last number.Something else to note is $matches[0] is where the array of matches (that match this regular expression) found are stored. For further clarification on what the other indexes in the array are for see: http://php.net/manual/en/function.preg-match-all.phphttp://php.net/manual/en/function.preg-match-all.php",
                "try this,use preg_replacepreg_replacepreg_replace$string = \"Hello! 123 test this? 456. done? 100%\";\n$int = intval(preg_replace('/[^0-9]+/', '', $string), 10);\necho $int;\n$string = \"Hello! 123 test this? 456. done? 100%\";\n$int = intval(preg_replace('/[^0-9]+/', '', $string), 10);\necho $int;\nDEMODEMODEMO",
                "we can extract int from it like $string = 'In My Car_Price : 50660.00';\n\necho intval(preg_replace('/[^0-9.]/','',$string));  # without number format   output: 50660\necho number_format(intval(preg_replace('/[^0-9.]/','',$string)));  # with number format  output :50,660\n$string = 'In My Car_Price : 50660.00';\n\necho intval(preg_replace('/[^0-9.]/','',$string));  # without number format   output: 50660\necho number_format(intval(preg_replace('/[^0-9.]/','',$string)));  # with number format  output :50,660\ndemo : http://sandbox.onlinephpfunctions.com/code/82d58b5983e85a0022a99882c7d0de90825aa398http://sandbox.onlinephpfunctions.com/code/82d58b5983e85a0022a99882c7d0de90825aa398",
                "Follow this step it will convert string to number$value = '$0025.123';\n$onlyNumeric = filter_var($value, FILTER_SANITIZE_NUMBER_FLOAT, FILTER_FLAG_ALLOW_FRACTION);\nsettype($onlyNumeric,\"float\");\n\n$result=($onlyNumeric+100);\necho $result;\n$value = '$0025.123';\n$onlyNumeric = filter_var($value, FILTER_SANITIZE_NUMBER_FLOAT, FILTER_FLAG_ALLOW_FRACTION);\nsettype($onlyNumeric,\"float\");\n\n$result=($onlyNumeric+100);\necho $result;\nAnother way to do it :$res = preg_replace(\"/[^0-9.]/\", \"\", \"$15645623.095605659\");\n$res = preg_replace(\"/[^0-9.]/\", \"\", \"$15645623.095605659\");\n",
                "other way(unicode string even):$res = array();\n$str = 'test 1234 555 2.7 string ..... 2.2 3.3';\n$str = preg_replace(\"/[^0-9\\.]/\", \" \", $str);\n$str = trim(preg_replace('/\\s+/u', ' ', $str));\n$arr = explode(' ', $str);\nfor ($i = 0; $i < count($arr); $i++) {\n    if (is_numeric($arr[$i])) {\n        $res[] = $arr[$i];\n    }\n}\nprint_r($res); //Array ( [0] => 1234 [1] => 555 [2] => 2.7 [3] => 2.2 [4] => 3.3 ) \n$res = array();\n$str = 'test 1234 555 2.7 string ..... 2.2 3.3';\n$str = preg_replace(\"/[^0-9\\.]/\", \" \", $str);\n$str = trim(preg_replace('/\\s+/u', ' ', $str));\n$arr = explode(' ', $str);\nfor ($i = 0; $i < count($arr); $i++) {\n    if (is_numeric($arr[$i])) {\n        $res[] = $arr[$i];\n    }\n}\nprint_r($res); //Array ( [0] => 1234 [1] => 555 [2] => 2.7 [3] => 2.2 [4] => 3.3 ) \n",
                "An alternative solution with sscanf:$str = \"In My Cart : 11 items\";\nlist($count) = sscanf($str, 'In My Cart : %s items');\n$str = \"In My Cart : 11 items\";\nlist($count) = sscanf($str, 'In My Cart : %s items');\n",
                "Depending on your use case, this might also be an option:$str = 'In My Cart : 11 items';\n$num = '';\n\nfor ($i = 0; $i < strlen($str); $i++) {\n\n    if (is_numeric($str[$i])) {\n        $num .= $str[$i];\n    }\n}\n\necho $num; // 11\n$str = 'In My Cart : 11 items';\n$num = '';\n\nfor ($i = 0; $i < strlen($str); $i++) {\n\n    if (is_numeric($str[$i])) {\n        $num .= $str[$i];\n    }\n}\n\necho $num; // 11\nThough I'd agree a regex or filter_var() would be more useful in the stated case.filter_var()",
                "for utf8 str:function unicodeStrDigits($str) {\n    $arr = array();\n    $sub = '';\n    for ($i = 0; $i < strlen($str); $i++) { \n        if (is_numeric($str[$i])) {\n            $sub .= $str[$i];\n            continue;\n        } else {\n            if ($sub) {\n                array_push($arr, $sub);\n                $sub = '';\n            }\n        }\n    }\n\n    if ($sub) {\n        array_push($arr, $sub); \n    }\n\n    return $arr;\n}\nfunction unicodeStrDigits($str) {\n    $arr = array();\n    $sub = '';\n    for ($i = 0; $i < strlen($str); $i++) { \n        if (is_numeric($str[$i])) {\n            $sub .= $str[$i];\n            continue;\n        } else {\n            if ($sub) {\n                array_push($arr, $sub);\n                $sub = '';\n            }\n        }\n    }\n\n    if ($sub) {\n        array_push($arr, $sub); \n    }\n\n    return $arr;\n}\n",
                "\nIf you don't know which format the number is? int or floating, then use this :\nIf you don't know which format the number is? int or floating, then use this :$string = '$125.22';\n\n$string2 = '$125';\n\npreg_match_all('/(\\d+.?\\d+)/',$string,$matches); // $matches[1] = 125.22\n\npreg_match_all('/(\\d+.?\\d+)/',$string2,$matches); // $matches[1] = 125\n$string = '$125.22';\n\n$string2 = '$125';\n\npreg_match_all('/(\\d+.?\\d+)/',$string,$matches); // $matches[1] = 125.22\n\npreg_match_all('/(\\d+.?\\d+)/',$string2,$matches); // $matches[1] = 125\n",
                "This functions will also handle the floating numbers$str = \"Doughnuts, 4; doughnuts holes, 0.08; glue, 3.4\";\n$str = preg_replace('/[^0-9\\.]/','-', $str);\n$str = preg_replace('/(\\-+)(\\.\\.+)/','-', $str);\n$str = trim($str, '-');\n$arr = explode('-', $str);\n$str = \"Doughnuts, 4; doughnuts holes, 0.08; glue, 3.4\";\n$str = preg_replace('/[^0-9\\.]/','-', $str);\n$str = preg_replace('/(\\-+)(\\.\\.+)/','-', $str);\n$str = trim($str, '-');\n$arr = explode('-', $str);\n",
                "This script creates a file at first , write numbers to a line and changes to a next line if gets a character other than number. At last, again it sorts out the numbers to a list.string1 = \"hello my name 12 is after 198765436281094and14 and 124de\"\nf= open(\"created_file.txt\",\"w+\")\nfor a in string1:\n    if a in ['1','2','3','4','5','6','7','8','9','0']:\n        f.write(a)\n    else:\n        f.write(\"\\n\" +a+ \"\\n\")\nf.close()\n\n\n#desired_numbers=[x for x in open(\"created_file.txt\")]\n\n#print(desired_numbers)\n\nk=open(\"created_file.txt\",\"r\")\ndesired_numbers=[]\nfor x in k:\n    l=x.rstrip()\n    print(len(l))\n    if len(l)==15:\n        desired_numbers.append(l)\n\n\n#desired_numbers=[x for x in k if len(x)==16]\nprint(desired_numbers)\nstring1 = \"hello my name 12 is after 198765436281094and14 and 124de\"\nf= open(\"created_file.txt\",\"w+\")\nfor a in string1:\n    if a in ['1','2','3','4','5','6','7','8','9','0']:\n        f.write(a)\n    else:\n        f.write(\"\\n\" +a+ \"\\n\")\nf.close()\n\n\n#desired_numbers=[x for x in open(\"created_file.txt\")]\n\n#print(desired_numbers)\n\nk=open(\"created_file.txt\",\"r\")\ndesired_numbers=[]\nfor x in k:\n    l=x.rstrip()\n    print(len(l))\n    if len(l)==15:\n        desired_numbers.append(l)\n\n\n#desired_numbers=[x for x in k if len(x)==16]\nprint(desired_numbers)\n"
            ]
        },
        {
            "tag": "string",
            "patterns": [
                "Leading zeros for Int in Swift",
                "Leading zeros for Int in Swift"
            ],
            "responses": [
                "Assuming you want a field length of 2 with leading zeros you'd do this:import Foundation\n\nfor myInt in 1 ... 3 {\n    print(String(format: \"%02d\", myInt))\n}\nimport Foundation\n\nfor myInt in 1 ... 3 {\n    print(String(format: \"%02d\", myInt))\n}\noutput:\n01\n02\n03\n\n01\n02\n03\n01\n02\n03\nThis requires import Foundation so technically it is not a part of the Swift language but a capability provided by the Foundation framework.  Note that both import UIKit and import Cocoa include Foundation so it isn't necessary to import it again if you've already imported Cocoa or UIKit.import FoundationFoundationimport UIKitimport CocoaFoundationCocoaUIKitThe format string can specify the format of multiple items.  For instance, if you are trying to format 3 hours, 15 minutes and 7 seconds into 03:15:07 you could do it like this:315703:15:07let hours = 3\nlet minutes = 15\nlet seconds = 7\nprint(String(format: \"%02d:%02d:%02d\", hours, minutes, seconds))\nlet hours = 3\nlet minutes = 15\nlet seconds = 7\nprint(String(format: \"%02d:%02d:%02d\", hours, minutes, seconds))\noutput:\n03:15:07\n\n03:15:07\n03:15:07\n",
                "With Swift 5, you may choose one of the three examples shown below in order to solve your problem.three examples#1. Using String's init(format:_:) initializerStringinit(format:_:)Foundation provides Swift String a init(format:_:) initializer. init(format:_:) has the following declaration:FoundationStringinit(format:_:)init(format:_:)init(format: String, _ arguments: CVarArg...)\ninit(format: String, _ arguments: CVarArg...)\n\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted.\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted.StringThe following Playground code shows how to create a String formatted from Int with at least two integer digits by using init(format:_:):StringIntinit(format:_:)import Foundation\n\nlet string0 = String(format: \"%02d\", 0) // returns \"00\"\nlet string1 = String(format: \"%02d\", 1) // returns \"01\"\nlet string2 = String(format: \"%02d\", 10) // returns \"10\"\nlet string3 = String(format: \"%02d\", 100) // returns \"100\"\nimport Foundation\n\nlet string0 = String(format: \"%02d\", 0) // returns \"00\"\nlet string1 = String(format: \"%02d\", 1) // returns \"01\"\nlet string2 = String(format: \"%02d\", 10) // returns \"10\"\nlet string3 = String(format: \"%02d\", 100) // returns \"100\"\n#2. Using String's init(format:arguments:) initializerStringinit(format:arguments:)Foundation provides Swift String a init(format:arguments:) initializer. init(format:arguments:) has the following declaration:FoundationStringinit(format:arguments:)init(format:arguments:)init(format: String, arguments: [CVarArg])\ninit(format: String, arguments: [CVarArg])\n\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted according to the user\u2019s default locale.\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted according to the user\u2019s default locale.StringThe following Playground code shows how to create a String formatted from Int with at least two integer digits by using init(format:arguments:):StringIntinit(format:arguments:)import Foundation\n\nlet string0 = String(format: \"%02d\", arguments: [0]) // returns \"00\"\nlet string1 = String(format: \"%02d\", arguments: [1]) // returns \"01\"\nlet string2 = String(format: \"%02d\", arguments: [10]) // returns \"10\"\nlet string3 = String(format: \"%02d\", arguments: [100]) // returns \"100\"\nimport Foundation\n\nlet string0 = String(format: \"%02d\", arguments: [0]) // returns \"00\"\nlet string1 = String(format: \"%02d\", arguments: [1]) // returns \"01\"\nlet string2 = String(format: \"%02d\", arguments: [10]) // returns \"10\"\nlet string3 = String(format: \"%02d\", arguments: [100]) // returns \"100\"\n#3. Using NumberFormatterNumberFormatterFoundation provides NumberFormatter. Apple states about it:NumberFormatterNumberFormatter\nInstances of NSNumberFormatter format the textual representation of cells that contain NSNumber objects and convert textual representations of numeric values into NSNumber objects. The representation encompasses integers, floats, and doubles; floats and doubles can be formatted to a specified decimal position.\nInstances of NSNumberFormatter format the textual representation of cells that contain NSNumber objects and convert textual representations of numeric values into NSNumber objects. The representation encompasses integers, floats, and doubles; floats and doubles can be formatted to a specified decimal position.NSNumberFormatterNSNumberNSNumberThe following Playground code shows how to create a NumberFormatter that returns String? from a Int with at least two integer digits:NumberFormatterString?Intimport Foundation\n\nlet formatter = NumberFormatter()\nformatter.minimumIntegerDigits = 2\n\nlet optionalString0 = formatter.string(from: 0) // returns Optional(\"00\")\nlet optionalString1 = formatter.string(from: 1) // returns Optional(\"01\")\nlet optionalString2 = formatter.string(from: 10) // returns Optional(\"10\")\nlet optionalString3 = formatter.string(from: 100) // returns Optional(\"100\")\nimport Foundation\n\nlet formatter = NumberFormatter()\nformatter.minimumIntegerDigits = 2\n\nlet optionalString0 = formatter.string(from: 0) // returns Optional(\"00\")\nlet optionalString1 = formatter.string(from: 1) // returns Optional(\"01\")\nlet optionalString2 = formatter.string(from: 10) // returns Optional(\"10\")\nlet optionalString3 = formatter.string(from: 100) // returns Optional(\"100\")\n",
                "For left padding add a string extension like this:Swift 5.0 +Swift 5.0 +extension String {\n    func PadLeft( totalWidth: Int,byString:String) -> String {\n    let toPad = totalWidth - self.count\n    if toPad < 1 {\n        return self\n    }\n    \n    return \"\".padding(toLength: toPad, withPad: byString, startingAt: 0) + self\n}\n}\nextension String {\n    func PadLeft( totalWidth: Int,byString:String) -> String {\n    let toPad = totalWidth - self.count\n    if toPad < 1 {\n        return self\n    }\n    \n    return \"\".padding(toLength: toPad, withPad: byString, startingAt: 0) + self\n}\n}\nUsing this method:Using this method:for myInt in 1...3 {\n    print(\"\\(myInt)\".padLeft(totalWidth: 2, with: \"0\"))\n}\nfor myInt in 1...3 {\n    print(\"\\(myInt)\".padLeft(totalWidth: 2, with: \"0\"))\n}\n",
                "Swift 3.0+Swift 3.0+Left padding String extension similar to padding(toLength:withPad:startingAt:) in FoundationStringpadding(toLength:withPad:startingAt:)Foundationextension String {\n    func leftPadding(toLength: Int, withPad: String = \" \") -> String {\n\n        guard toLength > self.characters.count else { return self }\n\n        let padding = String(repeating: withPad, count: toLength - self.characters.count)\n        return padding + self\n    }\n}\nextension String {\n    func leftPadding(toLength: Int, withPad: String = \" \") -> String {\n\n        guard toLength > self.characters.count else { return self }\n\n        let padding = String(repeating: withPad, count: toLength - self.characters.count)\n        return padding + self\n    }\n}\nUsage:let s = String(123)\ns.leftPadding(toLength: 8, withPad: \"0\") // \"00000123\"\nlet s = String(123)\ns.leftPadding(toLength: 8, withPad: \"0\") // \"00000123\"\n",
                "Swift 5@imanuo answers is already great, but if you are working with an application full of number, you can consider an extension like this:extension String {\n\n    init(withInt int: Int, leadingZeros: Int = 2) {\n        self.init(format: \"%0\\(leadingZeros)d\", int)\n    }\n\n    func leadingZeros(_ zeros: Int) -> String {\n        if let int = Int(self) {\n            return String(withInt: int, leadingZeros: zeros)\n        }\n        print(\"Warning: \\(self) is not an Int\")\n        return \"\"\n    }\n    \n}\nextension String {\n\n    init(withInt int: Int, leadingZeros: Int = 2) {\n        self.init(format: \"%0\\(leadingZeros)d\", int)\n    }\n\n    func leadingZeros(_ zeros: Int) -> String {\n        if let int = Int(self) {\n            return String(withInt: int, leadingZeros: zeros)\n        }\n        print(\"Warning: \\(self) is not an Int\")\n        return \"\"\n    }\n    \n}\nIn this way you can call wherever:String(withInt: 3) \n// prints 03\n\nString(withInt: 23, leadingZeros: 4) \n// prints 0023\n\n\"42\".leadingZeros(2)\n// prints 42\n\n\"54\".leadingZeros(3)\n// prints 054\nString(withInt: 3) \n// prints 03\n\nString(withInt: 23, leadingZeros: 4) \n// prints 0023\n\n\"42\".leadingZeros(2)\n// prints 42\n\n\"54\".leadingZeros(3)\n// prints 054\n",
                "Using Swift 5\u2019s fancy new extendible interpolation:extension DefaultStringInterpolation {\n    mutating func appendInterpolation(pad value: Int, toWidth width: Int, using paddingCharacter: Character = \"0\") {\n        appendInterpolation(String(format: \"%\\(paddingCharacter)\\(width)d\", value))\n    }\n}\n\nlet pieCount = 3\nprint(\"I ate \\(pad: pieCount, toWidth: 3, using: \"0\") pies\")  // => `I ate 003 pies`\nprint(\"I ate \\(pad: 1205, toWidth: 3, using: \"0\") pies\")  // => `I ate 1205 pies`\nextension DefaultStringInterpolation {\n    mutating func appendInterpolation(pad value: Int, toWidth width: Int, using paddingCharacter: Character = \"0\") {\n        appendInterpolation(String(format: \"%\\(paddingCharacter)\\(width)d\", value))\n    }\n}\n\nlet pieCount = 3\nprint(\"I ate \\(pad: pieCount, toWidth: 3, using: \"0\") pies\")  // => `I ate 003 pies`\nprint(\"I ate \\(pad: 1205, toWidth: 3, using: \"0\") pies\")  // => `I ate 1205 pies`\n",
                "in Xcode 8.3.2, iOS 10.3\nThats is good to nowSample1:Sample1:let dayMoveRaw = 5 \nlet dayMove = String(format: \"%02d\", arguments: [dayMoveRaw])\nprint(dayMove) // 05\nlet dayMoveRaw = 5 \nlet dayMove = String(format: \"%02d\", arguments: [dayMoveRaw])\nprint(dayMove) // 05\nSample2:Sample2:let dayMoveRaw = 55 \nlet dayMove = String(format: \"%02d\", arguments: [dayMoveRaw])\nprint(dayMove) // 55\nlet dayMoveRaw = 55 \nlet dayMove = String(format: \"%02d\", arguments: [dayMoveRaw])\nprint(dayMove) // 55\n",
                "The other answers are good if you are dealing only with numbers using the format string, but this is good when you may have strings that need to be padded (although admittedly a little diffent than the question asked, seems similar in spirit). Also, be careful if the string is longer than the pad.    let str = \"a str\"\n   let padAmount = max(10, str.count)\n   String(repeatElement(\"-\", count: padAmount - str.count)) + str\n   let str = \"a str\"\n   let padAmount = max(10, str.count)\n   String(repeatElement(\"-\", count: padAmount - str.count)) + str\nOutput \"-----a str\"\"-----a str\"",
                "Swift 4* and above you can try this also:func leftPadding(valueString: String, toLength: Int, withPad: String = \" \") -> String {\n        guard toLength > valueString.count else { return valueString }\n        \n        let padding = String(repeating: withPad, count: toLength - valueString.count)\n        return padding + valueString\n    }\nfunc leftPadding(valueString: String, toLength: Int, withPad: String = \" \") -> String {\n        guard toLength > valueString.count else { return valueString }\n        \n        let padding = String(repeating: withPad, count: toLength - valueString.count)\n        return padding + valueString\n    }\ncall the function:call the function:leftPadding(valueString: \"12\", toLength: 5, withPad: \"0\")\nleftPadding(valueString: \"12\", toLength: 5, withPad: \"0\")\nOutput:\n\"00012\"Output:",
                "The below code generates a 3 digits string with 0 padding in front:import Foundation\n\nvar randomInt = Int.random(in: 0..<1000)\nvar str = String(randomInt)\nvar paddingZero = String(repeating: \"0\", count: 3 - str.count)\n\nprint(str, str.count, paddingZero + str)\nimport Foundation\n\nvar randomInt = Int.random(in: 0..<1000)\nvar str = String(randomInt)\nvar paddingZero = String(repeating: \"0\", count: 3 - str.count)\n\nprint(str, str.count, paddingZero + str)\nOutput:5 1 005\n88 2 088\n647 3 647\n5 1 005\n88 2 088\n647 3 647\n",
                "DetailsXcode 9.0.1, swift 4.0SolutionsDataDataimport Foundation\n\nlet array = [0,1,2,3,4,5,6,7,8]\nimport Foundation\n\nlet array = [0,1,2,3,4,5,6,7,8]\nSolution 1Solution 1extension Int {\n\n    func getString(prefix: Int) -> String {\n        return \"\\(prefix)\\(self)\"\n    }\n\n    func getString(prefix: String) -> String {\n        return \"\\(prefix)\\(self)\"\n    }\n}\n\nfor item in array {\n    print(item.getString(prefix: 0))\n}\n\nfor item in array {\n    print(item.getString(prefix: \"0x\"))\n}\nextension Int {\n\n    func getString(prefix: Int) -> String {\n        return \"\\(prefix)\\(self)\"\n    }\n\n    func getString(prefix: String) -> String {\n        return \"\\(prefix)\\(self)\"\n    }\n}\n\nfor item in array {\n    print(item.getString(prefix: 0))\n}\n\nfor item in array {\n    print(item.getString(prefix: \"0x\"))\n}\nSolution 2Solution 2for item in array {\n    print(String(repeatElement(\"0\", count: 2)) + \"\\(item)\")\n}\nfor item in array {\n    print(String(repeatElement(\"0\", count: 2)) + \"\\(item)\")\n}\nSolution 3Solution 3extension String {\n\n    func repeate(count: Int, string: String? = nil) -> String {\n\n        if count > 1 {\n            let repeatedString = string ?? self\n            return repeatedString + repeate(count: count-1, string: repeatedString)\n        }\n        return self\n    }\n}\n\nfor item in array {\n    print(\"0\".repeate(count: 3) + \"\\(item)\")\n}\nextension String {\n\n    func repeate(count: Int, string: String? = nil) -> String {\n\n        if count > 1 {\n            let repeatedString = string ?? self\n            return repeatedString + repeate(count: count-1, string: repeatedString)\n        }\n        return self\n    }\n}\n\nfor item in array {\n    print(\"0\".repeate(count: 3) + \"\\(item)\")\n}\n",
                "Unlike the other answers that use a formatter, you can also just add an \"0\" text in front of each number inside of the loop, like this: for myInt in 1...3 {\n    println(\"0\" + \"\\(myInt)\")\n}\nfor myInt in 1...3 {\n    println(\"0\" + \"\\(myInt)\")\n}\nBut formatter is often better when you have to add suppose a designated amount of 0s for each seperate number. If you only need to add one 0, though, then it's really just your pick."
            ]
        },
        {
            "tag": "python",
            "patterns": [
                "Convert floats to ints in Pandas?"
            ],
            "responses": [
                "To modify the float output do this:df= pd.DataFrame(range(5), columns=['a'])\ndf.a = df.a.astype(float)\ndf\n\nOut[33]:\n\n          a\n0 0.0000000\n1 1.0000000\n2 2.0000000\n3 3.0000000\n4 4.0000000\n\npd.options.display.float_format = '{:,.0f}'.format\ndf\n\nOut[35]:\n\n   a\n0  0\n1  1\n2  2\n3  3\n4  4\ndf= pd.DataFrame(range(5), columns=['a'])\ndf.a = df.a.astype(float)\ndf\n\nOut[33]:\n\n          a\n0 0.0000000\n1 1.0000000\n2 2.0000000\n3 3.0000000\n4 4.0000000\n\npd.options.display.float_format = '{:,.0f}'.format\ndf\n\nOut[35]:\n\n   a\n0  0\n1  1\n2  2\n3  3\n4  4\n",
                "Use the pandas.DataFrame.astype(<type>) function to manipulate column dtypes.pandas.DataFrame.astype(<type>)pandas.DataFrame.astype(<type>)>>> df = pd.DataFrame(np.random.rand(3,4), columns=list(\"ABCD\"))\n>>> df\n          A         B         C         D\n0  0.542447  0.949988  0.669239  0.879887\n1  0.068542  0.757775  0.891903  0.384542\n2  0.021274  0.587504  0.180426  0.574300\n>>> df[list(\"ABCD\")] = df[list(\"ABCD\")].astype(int)\n>>> df\n   A  B  C  D\n0  0  0  0  0\n1  0  0  0  0\n2  0  0  0  0\n>>> df = pd.DataFrame(np.random.rand(3,4), columns=list(\"ABCD\"))\n>>> df\n          A         B         C         D\n0  0.542447  0.949988  0.669239  0.879887\n1  0.068542  0.757775  0.891903  0.384542\n2  0.021274  0.587504  0.180426  0.574300\n>>> df[list(\"ABCD\")] = df[list(\"ABCD\")].astype(int)\n>>> df\n   A  B  C  D\n0  0  0  0  0\n1  0  0  0  0\n2  0  0  0  0\nEDIT:To handle missing values:>>> df\n          A         B     C         D\n0  0.475103  0.355453  0.66  0.869336\n1  0.260395  0.200287   NaN  0.617024\n2  0.517692  0.735613  0.18  0.657106\n>>> df[list(\"ABCD\")] = df[list(\"ABCD\")].fillna(0.0).astype(int)\n>>> df\n   A  B  C  D\n0  0  0  0  0\n1  0  0  0  0\n2  0  0  0  0\n>>> df\n          A         B     C         D\n0  0.475103  0.355453  0.66  0.869336\n1  0.260395  0.200287   NaN  0.617024\n2  0.517692  0.735613  0.18  0.657106\n>>> df[list(\"ABCD\")] = df[list(\"ABCD\")].fillna(0.0).astype(int)\n>>> df\n   A  B  C  D\n0  0  0  0  0\n1  0  0  0  0\n2  0  0  0  0\n",
                "Considering the following data frame:>>> df = pd.DataFrame(10*np.random.rand(3, 4), columns=list(\"ABCD\"))\n>>> print(df)\n...           A         B         C         D\n... 0  8.362940  0.354027  1.916283  6.226750\n... 1  1.988232  9.003545  9.277504  8.522808\n... 2  1.141432  4.935593  2.700118  7.739108\n>>> df = pd.DataFrame(10*np.random.rand(3, 4), columns=list(\"ABCD\"))\n>>> print(df)\n...           A         B         C         D\n... 0  8.362940  0.354027  1.916283  6.226750\n... 1  1.988232  9.003545  9.277504  8.522808\n... 2  1.141432  4.935593  2.700118  7.739108\nUsing a list of column names, change the type for multiple columns with applymap():applymap()>>> cols = ['A', 'B']\n>>> df[cols] = df[cols].applymap(np.int64)\n>>> print(df)\n...    A  B         C         D\n... 0  8  0  1.916283  6.226750\n... 1  1  9  9.277504  8.522808\n... 2  1  4  2.700118  7.739108\n>>> cols = ['A', 'B']\n>>> df[cols] = df[cols].applymap(np.int64)\n>>> print(df)\n...    A  B         C         D\n... 0  8  0  1.916283  6.226750\n... 1  1  9  9.277504  8.522808\n... 2  1  4  2.700118  7.739108\nOr for a single column with apply():apply()>>> df['C'] = df['C'].apply(np.int64)\n>>> print(df)\n...    A  B  C         D\n... 0  8  0  1  6.226750\n... 1  1  9  9  8.522808\n... 2  1  4  2  7.739108\n>>> df['C'] = df['C'].apply(np.int64)\n>>> print(df)\n...    A  B  C         D\n... 0  8  0  1  6.226750\n... 1  1  9  9  8.522808\n... 2  1  4  2  7.739108\n",
                "To convert all float columns to int>>> df = pd.DataFrame(np.random.rand(5, 4) * 10, columns=list('PQRS'))\n>>> print(df)\n...     P           Q           R           S\n... 0   4.395994    0.844292    8.543430    1.933934\n... 1   0.311974    9.519054    6.171577    3.859993\n... 2   2.056797    0.836150    5.270513    3.224497\n... 3   3.919300    8.562298    6.852941    1.415992\n... 4   9.958550    9.013425    8.703142    3.588733\n\n>>> float_col = df.select_dtypes(include=['float64']) # This will select float columns only\n>>> # list(float_col.columns.values)\n\n>>> for col in float_col.columns.values:\n...     df[col] = df[col].astype('int64')\n\n>>> print(df)\n...     P   Q   R   S\n... 0   4   0   8   1\n... 1   0   9   6   3\n... 2   2   0   5   3\n... 3   3   8   6   1\n... 4   9   9   8   3\n>>> df = pd.DataFrame(np.random.rand(5, 4) * 10, columns=list('PQRS'))\n>>> print(df)\n...     P           Q           R           S\n... 0   4.395994    0.844292    8.543430    1.933934\n... 1   0.311974    9.519054    6.171577    3.859993\n... 2   2.056797    0.836150    5.270513    3.224497\n... 3   3.919300    8.562298    6.852941    1.415992\n... 4   9.958550    9.013425    8.703142    3.588733\n\n>>> float_col = df.select_dtypes(include=['float64']) # This will select float columns only\n>>> # list(float_col.columns.values)\n\n>>> for col in float_col.columns.values:\n...     df[col] = df[col].astype('int64')\n\n>>> print(df)\n...     P   Q   R   S\n... 0   4   0   8   1\n... 1   0   9   6   3\n... 2   2   0   5   3\n... 3   3   8   6   1\n... 4   9   9   8   3\n",
                "This is a quick solution in case you want to convert more columns of your pandas.DataFrame from float to integer considering also the case that you can have NaN values.pandas.DataFramecols = ['col_1', 'col_2', 'col_3', 'col_4']\nfor col in cols:\n   df[col] = df[col].apply(lambda x: int(x) if x == x else \"\")\ncols = ['col_1', 'col_2', 'col_3', 'col_4']\nfor col in cols:\n   df[col] = df[col].apply(lambda x: int(x) if x == x else \"\")\nI tried with else x) and else None), but the result is still having the float number, so I used else \"\".else x)else None)else \"\"",
                "Use 'Int64' for NaN support'Int64'\nastype(int) and astype('int64') cannot handle missing values (numpy int)\nastype('Int64') (note the capital I) can handle missing values (pandas int)\nastype(int) and astype('int64') cannot handle missing values (numpy int)astype(int)astype('int64')cannot(numpy int)astype('Int64') (note the capital I) can handle missing values (pandas int)astype('Int64')Ican handle missing valuescan(pandas int)df['A'] = df['A'].astype('Int64') # capital I\ndf['A'] = df['A'].astype('Int64') # capital I\nThis assumes you want to keep missing values as NaN. If you plan to impute them, you could fillna first as Ryan suggested.fillnaas Ryan suggestedExamples of 'Int64' (capital I)'Int64'I\nIf the floats are already rounded, just use astype:\ndf = pd.DataFrame({'A': [99.0, np.nan, 42.0]})\n\ndf['A'] = df['A'].astype('Int64')\n#       A\n# 0    99\n# 1  <NA>\n# 2    42\n\n\nIf the floats are not rounded yet, round before astype:\ndf = pd.DataFrame({'A': [3.14159, np.nan, 1.61803]})\n\ndf['A'] = df['A'].round().astype('Int64')\n#       A\n# 0     3\n# 1  <NA>\n# 2     2\n\n\nTo read int+NaN data from a file, use dtype='Int64' to avoid the need for converting at all:\ncsv = io.StringIO('''\nid,rating\nfoo,5\nbar,\nbaz,2\n''')\n\ndf = pd.read_csv(csv, dtype={'rating': 'Int64'})\n#     id  rating\n# 0  foo       5\n# 1  bar    <NA>\n# 2  baz       2\n\n\nIf the floats are already rounded, just use astype:\ndf = pd.DataFrame({'A': [99.0, np.nan, 42.0]})\n\ndf['A'] = df['A'].astype('Int64')\n#       A\n# 0    99\n# 1  <NA>\n# 2    42\n\nIf the floats are already rounded, just use astype:astypeastypedf = pd.DataFrame({'A': [99.0, np.nan, 42.0]})\n\ndf['A'] = df['A'].astype('Int64')\n#       A\n# 0    99\n# 1  <NA>\n# 2    42\ndf = pd.DataFrame({'A': [99.0, np.nan, 42.0]})\n\ndf['A'] = df['A'].astype('Int64')\n#       A\n# 0    99\n# 1  <NA>\n# 2    42\nIf the floats are not rounded yet, round before astype:\ndf = pd.DataFrame({'A': [3.14159, np.nan, 1.61803]})\n\ndf['A'] = df['A'].round().astype('Int64')\n#       A\n# 0     3\n# 1  <NA>\n# 2     2\n\nIf the floats are not rounded yet, round before astype:notroundroundastypeastypedf = pd.DataFrame({'A': [3.14159, np.nan, 1.61803]})\n\ndf['A'] = df['A'].round().astype('Int64')\n#       A\n# 0     3\n# 1  <NA>\n# 2     2\ndf = pd.DataFrame({'A': [3.14159, np.nan, 1.61803]})\n\ndf['A'] = df['A'].round().astype('Int64')\n#       A\n# 0     3\n# 1  <NA>\n# 2     2\nTo read int+NaN data from a file, use dtype='Int64' to avoid the need for converting at all:\ncsv = io.StringIO('''\nid,rating\nfoo,5\nbar,\nbaz,2\n''')\n\ndf = pd.read_csv(csv, dtype={'rating': 'Int64'})\n#     id  rating\n# 0  foo       5\n# 1  bar    <NA>\n# 2  baz       2\n\nTo read int+NaN data from a file, use dtype='Int64' to avoid the need for converting at all:dtype='Int64'csv = io.StringIO('''\nid,rating\nfoo,5\nbar,\nbaz,2\n''')\n\ndf = pd.read_csv(csv, dtype={'rating': 'Int64'})\n#     id  rating\n# 0  foo       5\n# 1  bar    <NA>\n# 2  baz       2\ncsv = io.StringIO('''\nid,rating\nfoo,5\nbar,\nbaz,2\n''')\n\ndf = pd.read_csv(csv, dtype={'rating': 'Int64'})\n#     id  rating\n# 0  foo       5\n# 1  bar    <NA>\n# 2  baz       2\nNotes\n'Int64' is an alias for Int64Dtype:\ndf['A'] = df['A'].astype(pd.Int64Dtype()) # same as astype('Int64')\n\n\nSized/signed aliases are available:\n\n\n\n\n\nlower bound\nupper bound\n\n\n\n\n'Int8'\n-128\n127\n\n\n'Int16'\n-32,768\n32,767\n\n\n'Int32'\n-2,147,483,648\n2,147,483,647\n\n\n'Int64'\n-9,223,372,036,854,775,808\n9,223,372,036,854,775,807\n\n\n'UInt8'\n0\n255\n\n\n'UInt16'\n0\n65,535\n\n\n'UInt32'\n0\n4,294,967,295\n\n\n'UInt64'\n0\n18,446,744,073,709,551,615\n\n\n\n\n'Int64' is an alias for Int64Dtype:\ndf['A'] = df['A'].astype(pd.Int64Dtype()) # same as astype('Int64')\n\n'Int64' is an alias for Int64Dtype:'Int64'Int64DtypeInt64Dtypedf['A'] = df['A'].astype(pd.Int64Dtype()) # same as astype('Int64')\ndf['A'] = df['A'].astype(pd.Int64Dtype()) # same as astype('Int64')\nSized/signed aliases are available:\n\n\n\n\n\nlower bound\nupper bound\n\n\n\n\n'Int8'\n-128\n127\n\n\n'Int16'\n-32,768\n32,767\n\n\n'Int32'\n-2,147,483,648\n2,147,483,647\n\n\n'Int64'\n-9,223,372,036,854,775,808\n9,223,372,036,854,775,807\n\n\n'UInt8'\n0\n255\n\n\n'UInt16'\n0\n65,535\n\n\n'UInt32'\n0\n4,294,967,295\n\n\n'UInt64'\n0\n18,446,744,073,709,551,615\n\n\n\nSized/signed aliases are available:\n\n\n\n\nlower bound\nupper bound\n\n\n\n\n'Int8'\n-128\n127\n\n\n'Int16'\n-32,768\n32,767\n\n\n'Int32'\n-2,147,483,648\n2,147,483,647\n\n\n'Int64'\n-9,223,372,036,854,775,808\n9,223,372,036,854,775,807\n\n\n'UInt8'\n0\n255\n\n\n'UInt16'\n0\n65,535\n\n\n'UInt32'\n0\n4,294,967,295\n\n\n'UInt64'\n0\n18,446,744,073,709,551,615\n\n\n\n\n\n\n\nlower bound\nupper bound\n\n\n\n\n'Int8'\n-128\n127\n\n\n'Int16'\n-32,768\n32,767\n\n\n'Int32'\n-2,147,483,648\n2,147,483,647\n\n\n'Int64'\n-9,223,372,036,854,775,808\n9,223,372,036,854,775,807\n\n\n'UInt8'\n0\n255\n\n\n'UInt16'\n0\n65,535\n\n\n'UInt32'\n0\n4,294,967,295\n\n\n'UInt64'\n0\n18,446,744,073,709,551,615\n\n\n\n\n\nlower bound\nupper bound\n\n\n\nlower bound\nupper bound\nlower boundupper bound\n\n'Int8'\n-128\n127\n\n\n'Int16'\n-32,768\n32,767\n\n\n'Int32'\n-2,147,483,648\n2,147,483,647\n\n\n'Int64'\n-9,223,372,036,854,775,808\n9,223,372,036,854,775,807\n\n\n'UInt8'\n0\n255\n\n\n'UInt16'\n0\n65,535\n\n\n'UInt32'\n0\n4,294,967,295\n\n\n'UInt64'\n0\n18,446,744,073,709,551,615\n\n\n'Int8'\n-128\n127\n'Int8''Int8''Int8'-128127\n'Int16'\n-32,768\n32,767\n'Int16''Int16''Int16'-32,76832,767\n'Int32'\n-2,147,483,648\n2,147,483,647\n'Int32''Int32''Int32'-2,147,483,6482,147,483,647\n'Int64'\n-9,223,372,036,854,775,808\n9,223,372,036,854,775,807\n'Int64''Int64''Int64'-9,223,372,036,854,775,8089,223,372,036,854,775,807\n'UInt8'\n0\n255\n'UInt8''UInt8''UInt8'0255\n'UInt16'\n0\n65,535\n'UInt16''UInt16''UInt16'065,535\n'UInt32'\n0\n4,294,967,295\n'UInt32''UInt32''UInt32'04,294,967,295\n'UInt64'\n0\n18,446,744,073,709,551,615\n'UInt64''UInt64''UInt64'018,446,744,073,709,551,615",
                "Expanding on @Ryan G mentioned usage of the pandas.DataFrame.astype(<type>) method, one can use the errors=ignore argument to only convert those columns that do not produce an error, which notably simplifies the syntax. Obviously, caution should be applied when ignoring errors, but for this task it comes very handy.pandas.DataFrame.astype(<type>)errors=ignore>>> df = pd.DataFrame(np.random.rand(3, 4), columns=list('ABCD'))\n>>> df *= 10\n>>> print(df)\n...           A       B       C       D\n... 0   2.16861 8.34139 1.83434 6.91706\n... 1   5.85938 9.71712 5.53371 4.26542\n... 2   0.50112 4.06725 1.99795 4.75698\n\n>>> df['E'] = list('XYZ')\n>>> df.astype(int, errors='ignore')\n>>> print(df)\n...     A   B   C   D   E\n... 0   2   8   1   6   X\n... 1   5   9   5   4   Y\n... 2   0   4   1   4   Z\n>>> df = pd.DataFrame(np.random.rand(3, 4), columns=list('ABCD'))\n>>> df *= 10\n>>> print(df)\n...           A       B       C       D\n... 0   2.16861 8.34139 1.83434 6.91706\n... 1   5.85938 9.71712 5.53371 4.26542\n... 2   0.50112 4.06725 1.99795 4.75698\n\n>>> df['E'] = list('XYZ')\n>>> df.astype(int, errors='ignore')\n>>> print(df)\n...     A   B   C   D   E\n... 0   2   8   1   6   X\n... 1   5   9   5   4   Y\n... 2   0   4   1   4   Z\nFrom pandas.DataFrame.astype docs:pandas.DataFrame.astype\nerrors : {\u2018raise\u2019, \u2018ignore\u2019}, default \u2018raise\u2019\nControl raising of exceptions on invalid data for provided dtype.\n\nraise : allow exceptions to be raised\nignore : suppress exceptions. On error return original object\n\nNew in version 0.20.0.\nerrors : {\u2018raise\u2019, \u2018ignore\u2019}, default \u2018raise\u2019Control raising of exceptions on invalid data for provided dtype.\nraise : allow exceptions to be raised\nignore : suppress exceptions. On error return original object\nraise : allow exceptions to be raisedignore : suppress exceptions. On error return original objectignore : suppress exceptions. On error return original objectNew in version 0.20.0.",
                "The columns that needs to be converted to int can be mentioned in a dictionary also as belowdf = df.astype({'col1': 'int', 'col2': 'int', 'col3': 'int'})\ndf = df.astype({'col1': 'int', 'col2': 'int', 'col3': 'int'})\n",
                ">>> import pandas as pd\n>>> right = pd.DataFrame({'C': [1.002, 2.003], 'D': [1.009, 4.55], 'key': ['K0', 'K1']})\n>>> print(right)\n           C      D key\n    0  1.002  1.009  K0\n    1  2.003  4.550  K1\n>>> right['C'] = right.C.astype(int)\n>>> print(right)\n       C      D key\n    0  1  1.009  K0\n    1  2  4.550  K1\n>>> import pandas as pd\n>>> right = pd.DataFrame({'C': [1.002, 2.003], 'D': [1.009, 4.55], 'key': ['K0', 'K1']})\n>>> print(right)\n           C      D key\n    0  1.002  1.009  K0\n    1  2.003  4.550  K1\n>>> right['C'] = right.C.astype(int)\n>>> print(right)\n       C      D key\n    0  1  1.009  K0\n    1  2  4.550  K1\n",
                "In the text of the question is explained that the data comes from a csv. S\u00f3, I think that show options to make the conversion when the data is read and not after are relevant to the topic.When importing spreadsheets or csv in a dataframe, \"only integer columns\" are commonly converted to float because excel stores all numerical values as floats and how the underlying libraries works.When the file is read with read_excel or read_csv there are a couple of options avoid the after import conversion:read_excelread_csv\nparameter dtype allows a pass a dictionary of column names and target types like dtype = {\"my_column\": \"Int64\"}\nparameter converters can be used to pass a function that makes the conversion, for example changing NaN's with 0. converters = {\"my_column\": lambda x: int(x) if x else 0}\nparameter convert_float will convert \"integral floats to int (i.e., 1.0 \u2013> 1)\", but take care with corner cases like NaN's. This parameter is only available in read_excel\nparameter dtype allows a pass a dictionary of column names and target types like dtype = {\"my_column\": \"Int64\"}dtypedtype = {\"my_column\": \"Int64\"}parameter converters can be used to pass a function that makes the conversion, for example changing NaN's with 0. converters = {\"my_column\": lambda x: int(x) if x else 0}convertersconverters = {\"my_column\": lambda x: int(x) if x else 0}parameter convert_float will convert \"integral floats to int (i.e., 1.0 \u2013> 1)\", but take care with corner cases like NaN's. This parameter is only available in read_excelconvert_floatread_excelTo make the conversion in an existing dataframe several alternatives have been given in other comments, but since v1.0.0 pandas has a interesting function for this cases: convert_dtypes, that \"Convert columns to best possible dtypes using dtypes supporting pd.NA.\"convert_dtypesAs example:In [3]: import numpy as np                                                                                                                                                                                         \n\nIn [4]: import pandas as pd                                                                                                                                                                                        \n\nIn [5]: df = pd.DataFrame( \n   ...:     { \n   ...:         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int64\")), \n   ...:         \"b\": pd.Series([1.0, 2.0, 3.0], dtype=np.dtype(\"float\")), \n   ...:         \"c\": pd.Series([1.0, np.nan, 3.0]), \n   ...:         \"d\": pd.Series([1, np.nan, 3]), \n   ...:     } \n   ...: )                                                                                                                                                                                                          \n\nIn [6]: df                                                                                                                                                                                                         \nOut[6]: \n   a    b    c    d\n0  1  1.0  1.0  1.0\n1  2  2.0  NaN  NaN\n2  3  3.0  3.0  3.0\n\nIn [7]: df.dtypes                                                                                                                                                                                                  \nOut[7]: \na      int64\nb    float64\nc    float64\nd    float64\ndtype: object\n\nIn [8]: converted = df.convert_dtypes()                                                                                                                                                                            \n\nIn [9]: converted.dtypes                                                                                                                                                                                           \nOut[9]: \na    Int64\nb    Int64\nc    Int64\nd    Int64\ndtype: object\n\nIn [10]: converted                                                                                                                                                                                                 \nOut[10]: \n   a  b     c     d\n0  1  1     1     1\n1  2  2  <NA>  <NA>\n2  3  3     3     3\n\nIn [3]: import numpy as np                                                                                                                                                                                         \n\nIn [4]: import pandas as pd                                                                                                                                                                                        \n\nIn [5]: df = pd.DataFrame( \n   ...:     { \n   ...:         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int64\")), \n   ...:         \"b\": pd.Series([1.0, 2.0, 3.0], dtype=np.dtype(\"float\")), \n   ...:         \"c\": pd.Series([1.0, np.nan, 3.0]), \n   ...:         \"d\": pd.Series([1, np.nan, 3]), \n   ...:     } \n   ...: )                                                                                                                                                                                                          \n\nIn [6]: df                                                                                                                                                                                                         \nOut[6]: \n   a    b    c    d\n0  1  1.0  1.0  1.0\n1  2  2.0  NaN  NaN\n2  3  3.0  3.0  3.0\n\nIn [7]: df.dtypes                                                                                                                                                                                                  \nOut[7]: \na      int64\nb    float64\nc    float64\nd    float64\ndtype: object\n\nIn [8]: converted = df.convert_dtypes()                                                                                                                                                                            \n\nIn [9]: converted.dtypes                                                                                                                                                                                           \nOut[9]: \na    Int64\nb    Int64\nc    Int64\nd    Int64\ndtype: object\n\nIn [10]: converted                                                                                                                                                                                                 \nOut[10]: \n   a  b     c     d\n0  1  1     1     1\n1  2  2  <NA>  <NA>\n2  3  3     3     3\n\n",
                "Although there are many options here,\nYou can also convert the format of specific columns using a dictionaryData = pd.read_csv('Your_Data.csv')\n\nData_2 = Data.astype({\"Column a\":\"int32\", \"Column_b\": \"float64\", \"Column_c\": \"int32\"})\n\nprint(Data_2 .dtypes) # Check the dtypes of the columns\nData = pd.read_csv('Your_Data.csv')\n\nData_2 = Data.astype({\"Column a\":\"int32\", \"Column_b\": \"float64\", \"Column_c\": \"int32\"})\n\nprint(Data_2 .dtypes) # Check the dtypes of the columns\nThis is an useful and very fast way to change the data format of specific columns for quick data analysis."
            ]
        },
        {
            "tag": "c#",
            "patterns": [
                "How can I divide two integers to get a double?",
                "how do i split two integers to get double?",
                "how do you divide two integers to obtain a double?",
                "what can i do to divide two integers to get double?",
                "how do you divide two integers to get a double?",
                "how do i divide two integers to get double?"
            ],
            "responses": [
                "You want to cast the numbers:double num3 = (double)num1/(double)num2;\ndouble num3 = (double)num1/(double)num2;\nNote: If any of the arguments in C# is a double, a double divide is used which results in a double. So, the following would work too:doubledoubledoubledouble num3 = (double)num1/num2;\ndouble num3 = (double)num1/num2;\nFor more information see: Dot Net PerlsDot Net Perls",
                "Complementing the @NoahD's answerTo have a greater precision you can cast to decimal:(decimal)100/863\n//0.1158748551564310544611819235\n(decimal)100/863\n//0.1158748551564310544611819235\nOr:Decimal.Divide(100, 863)\n//0.1158748551564310544611819235\nDecimal.Divide(100, 863)\n//0.1158748551564310544611819235\nDouble are represented allocating 64 bits while decimal uses 128(double)100/863\n//0.11587485515643106\n(double)100/863\n//0.11587485515643106\nIn depth explanation of \"precision\"For more details about the floating point representation in binary and its precision take a look at this article from Jon Skeet where he talks about floats and doubles and this one where he talks about decimals.this articlefloatsdoublesthis onedecimals",
                "cast the integers to doubles.",
                "Convert one of them to a double first.  This form works in many languages: real_result = (int_numerator + 0.0) / int_denominator\n real_result = (int_numerator + 0.0) / int_denominator\n",
                "var firstNumber=5000,\nsecondeNumber=37;\n\nvar decimalResult = decimal.Divide(firstNumber,secondeNumber);\n\nConsole.WriteLine(decimalResult );\nvar firstNumber=5000,\nsecondeNumber=37;\n\nvar decimalResult = decimal.Divide(firstNumber,secondeNumber);\n\nConsole.WriteLine(decimalResult );\n",
                "var result = decimal.ToDouble(decimal.Divide(5, 2));\nvar result = decimal.ToDouble(decimal.Divide(5, 2));\n",
                "I have went through most of the answers and im pretty sure that it's unachievable. Whatever you try to divide two int into double or float is not gonna happen.\nBut you have tons of methods to make the calculation happen, just cast them into float or double before the calculation will be fine.",
                "The easiest way to do that is adding decimal places to your integer.Ex.:var v1 = 1 / 30 //the result is 0\nvar v2 = 1.00 / 30.00 //the result is 0.033333333333333333\nvar v1 = 1 / 30 //the result is 0\nvar v2 = 1.00 / 30.00 //the result is 0.033333333333333333\n"
            ]
        }
    ]
}